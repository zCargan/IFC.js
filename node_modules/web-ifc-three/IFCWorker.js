class Vector {
    constructor(vector) {
        this._data = {};
        this._size = vector.size;
        const keys = Object.keys(vector).filter((key) => key.indexOf('size') === -1).map(key => parseInt(key));
        keys.forEach((key) => this._data[key] = vector[key]);
    }
    size() {
        return this._size;
    }
    get(index) {
        return this._data[index];
    }
}

class IfcGeometry {
    constructor(vector) {
        this._GetVertexData = vector.GetVertexData;
        this._GetVertexDataSize = vector.GetVertexDataSize;
        this._GetIndexData = vector.GetIndexData;
        this._GetIndexDataSize = vector.GetIndexDataSize;
    }
    GetVertexData() {
        return this._GetVertexData;
    }
    GetVertexDataSize() {
        return this._GetVertexDataSize;
    }
    GetIndexData() {
        return this._GetIndexData;
    }
    GetIndexDataSize() {
        return this._GetIndexDataSize;
    }
}

class FlatMesh {
    constructor(serializer, flatMesh) {
        this.expressID = flatMesh.expressID;
        this.geometries = serializer.reconstructVector(flatMesh.geometries);
    }
}

class FlatMeshVector {
    constructor(serializer, vector) {
        this._data = {};
        this._size = vector.size;
        const keys = Object.keys(vector).filter((key) => key.indexOf('size') === -1).map(key => parseInt(key));
        keys.forEach(key => this._data[key] = serializer.reconstructFlatMesh(vector[key]));
    }
    size() {
        return this._size;
    }
    get(index) {
        return this._data[index];
    }
}

/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = '149';
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const NormalBlending = 1;
const AddEquation = 100;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const LessEqualDepth = 3;
const MultiplyOperation = 0;

const UVMapping = 300;
const RepeatWrapping = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const LinearFilter = 1006;
const LinearMipmapLinearFilter = 1008;
const UnsignedByteType = 1009;
const RGBAFormat = 1023;
const LinearEncoding = 3000;
const TangentSpaceNormalMap = 0;
const SRGBColorSpace = 'srgb';
const LinearSRGBColorSpace = 'srgb-linear';
const KeepStencilOp = 7680;
const AlwaysStencilFunc = 519;

const StaticDrawUsage = 35044;

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

class EventDispatcher {

	addEventListener( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		const listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	}

	hasEventListener( type, listener ) {

		if ( this._listeners === undefined ) return false;

		const listeners = this._listeners;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	}

	removeEventListener( type, listener ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			const index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	}

	dispatchEvent( event ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			// Make a copy, in case listeners are removed while iterating.
			const array = listenerArray.slice( 0 );

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				array[ i ].call( this, event );

			}

			event.target = null;

		}

	}

}

const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];

// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function generateUUID() {

	const d0 = Math.random() * 0xffffffff | 0;
	const d1 = Math.random() * 0xffffffff | 0;
	const d2 = Math.random() * 0xffffffff | 0;
	const d3 = Math.random() * 0xffffffff | 0;
	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

	// .toLowerCase() here flattens concatenated strings to save heap memory space.
	return uuid.toLowerCase();

}

function clamp( value, min, max ) {

	return Math.max( min, Math.min( max, value ) );

}

// compute euclidean modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function euclideanModulo( n, m ) {

	return ( ( n % m ) + m ) % m;

}

// https://en.wikipedia.org/wiki/Linear_interpolation
function lerp( x, y, t ) {

	return ( 1 - t ) * x + t * y;

}

function denormalize( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint16Array:

			return value / 65535.0;

		case Uint8Array:

			return value / 255.0;

		case Int16Array:

			return Math.max( value / 32767.0, - 1.0 );

		case Int8Array:

			return Math.max( value / 127.0, - 1.0 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}

function normalize( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint16Array:

			return Math.round( value * 65535.0 );

		case Uint8Array:

			return Math.round( value * 255.0 );

		case Int16Array:

			return Math.round( value * 32767.0 );

		case Int8Array:

			return Math.round( value * 127.0 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}

class Vector2 {

	constructor( x = 0, y = 0 ) {

		Vector2.prototype.isVector2 = true;

		this.x = x;
		this.y = y;

	}

	get width() {

		return this.x;

	}

	set width( value ) {

		this.x = value;

	}

	get height() {

		return this.y;

	}

	set height( value ) {

		this.y = value;

	}

	set( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	}

	add( v ) {

		this.x += v.x;
		this.y += v.y;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	}

	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;

		return this;

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y;

	}

	cross( v ) {

		return this.x * v.y - this.y * v.x;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	angle() {

		// computes the angle in radians with respect to the positive x-axis

		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

		return angle;

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	}

	rotateAround( center, angle ) {

		const c = Math.cos( angle ), s = Math.sin( angle );

		const x = this.x - center.x;
		const y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;

	}

}

class Matrix3 {

	constructor() {

		Matrix3.prototype.isMatrix3 = true;

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

	}

	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrix3Column( this, 0 );
		yAxis.setFromMatrix3Column( this, 1 );
		zAxis.setFromMatrix3Column( this, 2 );

		return this;

	}

	setFromMatrix4( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	}

	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	}

	invert() {

		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	}

	transpose() {

		let tmp;
		const m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	}

	getNormalMatrix( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).invert().transpose();

	}

	transposeIntoArray( r ) {

		const m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	}

	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

		const c = Math.cos( rotation );
		const s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

		return this;

	}

	//

	scale( sx, sy ) {

		this.premultiply( _m3.makeScale( sx, sy ) );

		return this;

	}

	rotate( theta ) {

		this.premultiply( _m3.makeRotation( - theta ) );

		return this;

	}

	translate( tx, ty ) {

		this.premultiply( _m3.makeTranslation( tx, ty ) );

		return this;

	}

	// for 2D Transforms

	makeTranslation( x, y ) {

		this.set(

			1, 0, x,
			0, 1, y,
			0, 0, 1

		);

		return this;

	}

	makeRotation( theta ) {

		// counterclockwise

		const c = Math.cos( theta );
		const s = Math.sin( theta );

		this.set(

			c, - s, 0,
			s, c, 0,
			0, 0, 1

		);

		return this;

	}

	makeScale( x, y ) {

		this.set(

			x, 0, 0,
			0, y, 0,
			0, 0, 1

		);

		return this;

	}

	//

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

	clone() {

		return new this.constructor().fromArray( this.elements );

	}

}

const _m3 = /*@__PURE__*/ new Matrix3();

function arrayNeedsUint32( array ) {

	// assumes larger values usually on last

	for ( let i = array.length - 1; i >= 0; -- i ) {

		if ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565

	}

	return false;

}

function createElementNS( name ) {

	return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );

}

function SRGBToLinear( c ) {

	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

}

function LinearToSRGB( c ) {

	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

}

// JavaScript RGB-to-RGB transforms, defined as
// FN[InputColorSpace][OutputColorSpace] callback functions.
const FN = {
	[ SRGBColorSpace ]: { [ LinearSRGBColorSpace ]: SRGBToLinear },
	[ LinearSRGBColorSpace ]: { [ SRGBColorSpace ]: LinearToSRGB },
};

const ColorManagement = {

	legacyMode: true,

	get workingColorSpace() {

		return LinearSRGBColorSpace;

	},

	set workingColorSpace( colorSpace ) {

		console.warn( 'THREE.ColorManagement: .workingColorSpace is readonly.' );

	},

	convert: function ( color, sourceColorSpace, targetColorSpace ) {

		if ( this.legacyMode || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {

			return color;

		}

		if ( FN[ sourceColorSpace ] && FN[ sourceColorSpace ][ targetColorSpace ] !== undefined ) {

			const fn = FN[ sourceColorSpace ][ targetColorSpace ];

			color.r = fn( color.r );
			color.g = fn( color.g );
			color.b = fn( color.b );

			return color;

		}

		throw new Error( 'Unsupported color space conversion.' );

	},

	fromWorkingColorSpace: function ( color, targetColorSpace ) {

		return this.convert( color, this.workingColorSpace, targetColorSpace );

	},

	toWorkingColorSpace: function ( color, sourceColorSpace ) {

		return this.convert( color, sourceColorSpace, this.workingColorSpace );

	},

};

const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

const _rgb$1 = { r: 0, g: 0, b: 0 };
const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };

function hue2rgb( p, q, t ) {

	if ( t < 0 ) t += 1;
	if ( t > 1 ) t -= 1;
	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
	if ( t < 1 / 2 ) return q;
	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
	return p;

}

function toComponents( source, target ) {

	target.r = source.r;
	target.g = source.g;
	target.b = source.b;

	return target;

}

class Color {

	constructor( r, g, b ) {

		this.isColor = true;

		this.r = 1;
		this.g = 1;
		this.b = 1;

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string
			return this.set( r );

		}

		return this.setRGB( r, g, b );

	}

	set( value ) {

		if ( value && value.isColor ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	}

	setScalar( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	}

	setHex( hex, colorSpace = SRGBColorSpace ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {

		this.r = r;
		this.g = g;
		this.b = b;

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {

		// h,s,l ranges are in 0.0 - 1.0
		h = euclideanModulo( h, 1 );
		s = clamp( s, 0, 1 );
		l = clamp( l, 0, 1 );

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			const q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setStyle( style, colorSpace = SRGBColorSpace ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		let m;

		if ( m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			let color;
			const name = m[ 1 ];
			const components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						ColorManagement.toWorkingColorSpace( this, colorSpace );

						handleAlpha( color[ 4 ] );

						return this;

					}

					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						ColorManagement.toWorkingColorSpace( this, colorSpace );

						handleAlpha( color[ 4 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						const h = parseFloat( color[ 1 ] ) / 360;
						const s = parseFloat( color[ 2 ] ) / 100;
						const l = parseFloat( color[ 3 ] ) / 100;

						handleAlpha( color[ 4 ] );

						return this.setHSL( h, s, l, colorSpace );

					}

					break;

			}

		} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

			// hex color

			const hex = m[ 1 ];
			const size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				ColorManagement.toWorkingColorSpace( this, colorSpace );

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				ColorManagement.toWorkingColorSpace( this, colorSpace );

				return this;

			}

		}

		if ( style && style.length > 0 ) {

			return this.setColorName( style, colorSpace );

		}

		return this;

	}

	setColorName( style, colorSpace = SRGBColorSpace ) {

		// color keywords
		const hex = _colorKeywords[ style.toLowerCase() ];

		if ( hex !== undefined ) {

			// red
			this.setHex( hex, colorSpace );

		} else {

			// unknown color
			console.warn( 'THREE.Color: Unknown color ' + style );

		}

		return this;

	}

	clone() {

		return new this.constructor( this.r, this.g, this.b );

	}

	copy( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	}

	copySRGBToLinear( color ) {

		this.r = SRGBToLinear( color.r );
		this.g = SRGBToLinear( color.g );
		this.b = SRGBToLinear( color.b );

		return this;

	}

	copyLinearToSRGB( color ) {

		this.r = LinearToSRGB( color.r );
		this.g = LinearToSRGB( color.g );
		this.b = LinearToSRGB( color.b );

		return this;

	}

	convertSRGBToLinear() {

		this.copySRGBToLinear( this );

		return this;

	}

	convertLinearToSRGB() {

		this.copyLinearToSRGB( this );

		return this;

	}

	getHex( colorSpace = SRGBColorSpace ) {

		ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb$1 ), colorSpace );

		return clamp( _rgb$1.r * 255, 0, 255 ) << 16 ^ clamp( _rgb$1.g * 255, 0, 255 ) << 8 ^ clamp( _rgb$1.b * 255, 0, 255 ) << 0;

	}

	getHexString( colorSpace = SRGBColorSpace ) {

		return ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( - 6 );

	}

	getHSL( target, colorSpace = ColorManagement.workingColorSpace ) {

		// h,s,l ranges are in 0.0 - 1.0

		ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb$1 ), colorSpace );

		const r = _rgb$1.r, g = _rgb$1.g, b = _rgb$1.b;

		const max = Math.max( r, g, b );
		const min = Math.min( r, g, b );

		let hue, saturation;
		const lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			const delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		target.h = hue;
		target.s = saturation;
		target.l = lightness;

		return target;

	}

	getRGB( target, colorSpace = ColorManagement.workingColorSpace ) {

		ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb$1 ), colorSpace );

		target.r = _rgb$1.r;
		target.g = _rgb$1.g;
		target.b = _rgb$1.b;

		return target;

	}

	getStyle( colorSpace = SRGBColorSpace ) {

		ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb$1 ), colorSpace );

		if ( colorSpace !== SRGBColorSpace ) {

			// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
			return `color(${ colorSpace } ${ _rgb$1.r } ${ _rgb$1.g } ${ _rgb$1.b })`;

		}

		return `rgb(${( _rgb$1.r * 255 ) | 0},${( _rgb$1.g * 255 ) | 0},${( _rgb$1.b * 255 ) | 0})`;

	}

	offsetHSL( h, s, l ) {

		this.getHSL( _hslA );

		_hslA.h += h; _hslA.s += s; _hslA.l += l;

		this.setHSL( _hslA.h, _hslA.s, _hslA.l );

		return this;

	}

	add( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	}

	addColors( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	}

	addScalar( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	}

	sub( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	}

	multiply( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	}

	multiplyScalar( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	}

	lerp( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	}

	lerpColors( color1, color2, alpha ) {

		this.r = color1.r + ( color2.r - color1.r ) * alpha;
		this.g = color1.g + ( color2.g - color1.g ) * alpha;
		this.b = color1.b + ( color2.b - color1.b ) * alpha;

		return this;

	}

	lerpHSL( color, alpha ) {

		this.getHSL( _hslA );
		color.getHSL( _hslB );

		const h = lerp( _hslA.h, _hslB.h, alpha );
		const s = lerp( _hslA.s, _hslB.s, alpha );
		const l = lerp( _hslA.l, _hslB.l, alpha );

		this.setHSL( h, s, l );

		return this;

	}

	equals( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	}

	fromArray( array, offset = 0 ) {

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.r = attribute.getX( index );
		this.g = attribute.getY( index );
		this.b = attribute.getZ( index );

		return this;

	}

	toJSON() {

		return this.getHex();

	}

	*[ Symbol.iterator ]() {

		yield this.r;
		yield this.g;
		yield this.b;

	}

}

Color.NAMES = _colorKeywords;

let _canvas;

class ImageUtils {

	static getDataURL( image ) {

		if ( /^data:/i.test( image.src ) ) {

			return image.src;

		}

		if ( typeof HTMLCanvasElement == 'undefined' ) {

			return image.src;

		}

		let canvas;

		if ( image instanceof HTMLCanvasElement ) {

			canvas = image;

		} else {

			if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );

			_canvas.width = image.width;
			_canvas.height = image.height;

			const context = _canvas.getContext( '2d' );

			if ( image instanceof ImageData ) {

				context.putImageData( image, 0, 0 );

			} else {

				context.drawImage( image, 0, 0, image.width, image.height );

			}

			canvas = _canvas;

		}

		if ( canvas.width > 2048 || canvas.height > 2048 ) {

			console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );

			return canvas.toDataURL( 'image/jpeg', 0.6 );

		} else {

			return canvas.toDataURL( 'image/png' );

		}

	}

	static sRGBToLinear( image ) {

		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

			const canvas = createElementNS( 'canvas' );

			canvas.width = image.width;
			canvas.height = image.height;

			const context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height );

			const imageData = context.getImageData( 0, 0, image.width, image.height );
			const data = imageData.data;

			for ( let i = 0; i < data.length; i ++ ) {

				data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;

			}

			context.putImageData( imageData, 0, 0 );

			return canvas;

		} else if ( image.data ) {

			const data = image.data.slice( 0 );

			for ( let i = 0; i < data.length; i ++ ) {

				if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {

					data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );

				} else {

					// assuming float

					data[ i ] = SRGBToLinear( data[ i ] );

				}

			}

			return {
				data: data,
				width: image.width,
				height: image.height
			};

		} else {

			console.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );
			return image;

		}

	}

}

class Source {

	constructor( data = null ) {

		this.isSource = true;

		this.uuid = generateUUID();

		this.data = data;

		this.version = 0;

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {

			return meta.images[ this.uuid ];

		}

		const output = {
			uuid: this.uuid,
			url: ''
		};

		const data = this.data;

		if ( data !== null ) {

			let url;

			if ( Array.isArray( data ) ) {

				// cube texture

				url = [];

				for ( let i = 0, l = data.length; i < l; i ++ ) {

					if ( data[ i ].isDataTexture ) {

						url.push( serializeImage( data[ i ].image ) );

					} else {

						url.push( serializeImage( data[ i ] ) );

					}

				}

			} else {

				// texture

				url = serializeImage( data );

			}

			output.url = url;

		}

		if ( ! isRootObject ) {

			meta.images[ this.uuid ] = output;

		}

		return output;

	}

}

function serializeImage( image ) {

	if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
		( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
		( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

		// default images

		return ImageUtils.getDataURL( image );

	} else {

		if ( image.data ) {

			// images of DataTexture

			return {
				data: Array.from( image.data ),
				width: image.width,
				height: image.height,
				type: image.data.constructor.name
			};

		} else {

			console.warn( 'THREE.Texture: Unable to serialize Texture.' );
			return {};

		}

	}

}

let textureId = 0;

class Texture extends EventDispatcher {

	constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, encoding = LinearEncoding ) {

		super();

		this.isTexture = true;

		Object.defineProperty( this, 'id', { value: textureId ++ } );

		this.uuid = generateUUID();

		this.name = '';

		this.source = new Source( image );
		this.mipmaps = [];

		this.mapping = mapping;

		this.wrapS = wrapS;
		this.wrapT = wrapT;

		this.magFilter = magFilter;
		this.minFilter = minFilter;

		this.anisotropy = anisotropy;

		this.format = format;
		this.internalFormat = null;
		this.type = type;

		this.offset = new Vector2( 0, 0 );
		this.repeat = new Vector2( 1, 1 );
		this.center = new Vector2( 0, 0 );
		this.rotation = 0;

		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding;

		this.userData = {};

		this.version = 0;
		this.onUpdate = null;

		this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
		this.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)

	}

	get image() {

		return this.source.data;

	}

	set image( value ) {

		this.source.data = value;

	}

	updateMatrix() {

		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.name = source.name;

		this.source = source.source;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.internalFormat = source.internalFormat;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );
		this.center.copy( source.center );
		this.rotation = source.rotation;

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy( source.matrix );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		this.needsUpdate = true;

		return this;

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		const output = {

			metadata: {
				version: 4.5,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			image: this.source.toJSON( meta ).uuid,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			center: [ this.center.x, this.center.y ],
			rotation: this.rotation,

			wrap: [ this.wrapS, this.wrapT ],

			format: this.format,
			type: this.type,
			encoding: this.encoding,

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY,

			generateMipmaps: this.generateMipmaps,
			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment

		};

		if ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;

		if ( ! isRootObject ) {

			meta.textures[ this.uuid ] = output;

		}

		return output;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	transformUv( uv ) {

		if ( this.mapping !== UVMapping ) return uv;

		uv.applyMatrix3( this.matrix );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}

					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}

					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

		return uv;

	}

	set needsUpdate( value ) {

		if ( value === true ) {

			this.version ++;
			this.source.needsUpdate = true;

		}

	}

}

Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;

class Quaternion {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this.isQuaternion = true;

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

	}

	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		let x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( t === 0 ) {

			dst[ dstOffset + 0 ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
			return;

		}

		if ( t === 1 ) {

			dst[ dstOffset + 0 ] = x1;
			dst[ dstOffset + 1 ] = y1;
			dst[ dstOffset + 2 ] = z1;
			dst[ dstOffset + 3 ] = w1;
			return;

		}

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			let s = 1 - t;
			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				const sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			const tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		const x0 = src0[ srcOffset0 ];
		const y0 = src0[ srcOffset0 + 1 ];
		const z0 = src0[ srcOffset0 + 2 ];
		const w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 ];
		const y1 = src1[ srcOffset1 + 1 ];
		const z1 = src1[ srcOffset1 + 2 ];
		const w1 = src1[ srcOffset1 + 3 ];

		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		return dst;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get w() {

		return this._w;

	}

	set w( value ) {

		this._w = value;
		this._onChangeCallback();

	}

	set( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._w );

	}

	copy( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	}

	setFromEuler( euler, update ) {

		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		const cos = Math.cos;
		const sin = Math.sin;

		const c1 = cos( x / 2 );
		const c2 = cos( y / 2 );
		const c3 = cos( z / 2 );

		const s1 = sin( x / 2 );
		const s2 = sin( y / 2 );
		const s3 = sin( z / 2 );

		switch ( order ) {

			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			default:
				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		}

		if ( update !== false ) this._onChangeCallback();

		return this;

	}

	setFromAxisAngle( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		const halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33;

		if ( trace > 0 ) {

			const s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	}

	setFromUnitVectors( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		let r = vFrom.dot( vTo ) + 1;

		if ( r < Number.EPSILON ) {

			// vFrom and vTo point in opposite directions

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	}

	angleTo( q ) {

		return 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) );

	}

	rotateTowards( q, step ) {

		const angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		const t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	}

	identity() {

		return this.set( 0, 0, 0, 1 );

	}

	invert() {

		// quaternion is assumed to have unit length

		return this.conjugate();

	}

	conjugate() {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	}

	dot( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	}

	lengthSq() {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	}

	length() {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	}

	normalize() {

		let l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	}

	multiply( q ) {

		return this.multiplyQuaternions( this, q );

	}

	premultiply( q ) {

		return this.multiplyQuaternions( q, this );

	}

	multiplyQuaternions( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	}

	slerp( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		const x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			const s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize();
			this._onChangeCallback();

			return this;

		}

		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	}

	slerpQuaternions( qa, qb, t ) {

		return this.copy( qa ).slerp( qb, t );

	}

	random() {

		// Derived from http://planning.cs.uiuc.edu/node198.html
		// Note, this source uses w, x, y, z ordering,
		// so we swap the order below.

		const u1 = Math.random();
		const sqrt1u1 = Math.sqrt( 1 - u1 );
		const sqrtu1 = Math.sqrt( u1 );

		const u2 = 2 * Math.PI * Math.random();

		const u3 = 2 * Math.PI * Math.random();

		return this.set(
			sqrt1u1 * Math.cos( u2 ),
			sqrtu1 * Math.sin( u3 ),
			sqrtu1 * Math.cos( u3 ),
			sqrt1u1 * Math.sin( u2 ),
		);

	}

	equals( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	}

	fromArray( array, offset = 0 ) {

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		return this;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

	*[ Symbol.iterator ]() {

		yield this._x;
		yield this._y;
		yield this._z;
		yield this._w;

	}

}

class Vector3 {

	constructor( x = 0, y = 0, z = 0 ) {

		Vector3.prototype.isVector3 = true;

		this.x = x;
		this.y = y;
		this.z = z;

	}

	set( x, y, z ) {

		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	}

	add( v ) {

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	}

	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	}

	multiplyVectors( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	}

	applyEuler( euler ) {

		return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

	}

	applyAxisAngle( axis, angle ) {

		return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	}

	applyNormalMatrix( m ) {

		return this.applyMatrix3( m ).normalize();

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	}

	applyQuaternion( q ) {

		const x = this.x, y = this.y, z = this.z;
		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		const ix = qw * x + qy * z - qz * y;
		const iy = qw * y + qz * x - qx * z;
		const iz = qw * z + qx * y - qy * x;
		const iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	}

	project( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	}

	unproject( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	}

	transformDirection( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	}

	// TODO lengthSquared?

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;

		return this;

	}

	cross( v ) {

		return this.crossVectors( this, v );

	}

	crossVectors( a, b ) {

		const ax = a.x, ay = a.y, az = a.z;
		const bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	}

	projectOnVector( v ) {

		const denominator = v.lengthSq();

		if ( denominator === 0 ) return this.set( 0, 0, 0 );

		const scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	}

	projectOnPlane( planeNormal ) {

		_vector$c.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector$c );

	}

	reflect( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	}

	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( clamp( theta, - 1, 1 ) );

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	}

	setFromSpherical( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	}

	setFromSphericalCoords( radius, phi, theta ) {

		const sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	}

	setFromCylindrical( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	}

	setFromCylindricalCoords( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	}

	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	}

	setFromMatrixScale( m ) {

		const sx = this.setFromMatrixColumn( m, 0 ).length();
		const sy = this.setFromMatrixColumn( m, 1 ).length();
		const sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	}

	setFromMatrixColumn( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	}

	setFromMatrix3Column( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	}

	setFromEuler( e ) {

		this.x = e._x;
		this.y = e._y;
		this.z = e._z;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();

		return this;

	}

	randomDirection() {

		// Derived from https://mathworld.wolfram.com/SpherePointPicking.html

		const u = ( Math.random() - 0.5 ) * 2;
		const t = Math.random() * Math.PI * 2;
		const f = Math.sqrt( 1 - u ** 2 );

		this.x = f * Math.cos( t );
		this.y = f * Math.sin( t );
		this.z = u;

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;

	}

}

const _vector$c = /*@__PURE__*/ new Vector3();
const _quaternion$4 = /*@__PURE__*/ new Quaternion();

class Box3 {

	constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

		this.isBox3 = true;

		this.min = min;
		this.max = max;

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromArray( array ) {

		let minX = + Infinity;
		let minY = + Infinity;
		let minZ = + Infinity;

		let maxX = - Infinity;
		let maxY = - Infinity;
		let maxZ = - Infinity;

		for ( let i = 0, l = array.length; i < l; i += 3 ) {

			const x = array[ i ];
			const y = array[ i + 1 ];
			const z = array[ i + 2 ];

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	}

	setFromBufferAttribute( attribute ) {

		let minX = + Infinity;
		let minY = + Infinity;
		let minZ = + Infinity;

		let maxX = - Infinity;
		let maxY = - Infinity;
		let maxZ = - Infinity;

		for ( let i = 0, l = attribute.count; i < l; i ++ ) {

			const x = attribute.getX( i );
			const y = attribute.getY( i );
			const z = attribute.getZ( i );

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );

		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	setFromObject( object, precise = false ) {

		this.makeEmpty();

		return this.expandByObject( object, precise );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	}

	getCenter( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	expandByObject( object, precise = false ) {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		object.updateWorldMatrix( false, false );

		const geometry = object.geometry;

		if ( geometry !== undefined ) {

			if ( precise && geometry.attributes != undefined && geometry.attributes.position !== undefined ) {

				const position = geometry.attributes.position;
				for ( let i = 0, l = position.count; i < l; i ++ ) {

					_vector$b.fromBufferAttribute( position, i ).applyMatrix4( object.matrixWorld );
					this.expandByPoint( _vector$b );

				}

			} else {

				if ( geometry.boundingBox === null ) {

					geometry.computeBoundingBox();

				}

				_box$3.copy( geometry.boundingBox );
				_box$3.applyMatrix4( object.matrixWorld );

				this.union( _box$3 );

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			this.expandByObject( children[ i ], precise );

		}

		return this;

	}

	containsPoint( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ||
			point.z < this.min.z || point.z > this.max.z ? false : true;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	}

	intersectsBox( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ||
			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

	}

	intersectsSphere( sphere ) {

		// Find the point on the AABB closest to the sphere center.
		this.clampPoint( sphere.center, _vector$b );

		// If that point is inside the sphere, the AABB and sphere intersect.
		return _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	intersectsPlane( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		let min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= - plane.constant && max >= - plane.constant );

	}

	intersectsTriangle( triangle ) {

		if ( this.isEmpty() ) {

			return false;

		}

		// compute box center and extents
		this.getCenter( _center );
		_extents.subVectors( this.max, _center );

		// translate triangle to aabb origin
		_v0$2.subVectors( triangle.a, _center );
		_v1$7.subVectors( triangle.b, _center );
		_v2$4.subVectors( triangle.c, _center );

		// compute edge vectors for triangle
		_f0.subVectors( _v1$7, _v0$2 );
		_f1.subVectors( _v2$4, _v1$7 );
		_f2.subVectors( _v0$2, _v2$4 );

		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		let axes = [
			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
		];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

			return false;

		}

		// test 3 face normals from the aabb
		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {

			return false;

		}

		// finally testing the face normal of the triangle
		// use already existing triangle edge vectors here
		_triangleNormal.crossVectors( _f0, _f1 );
		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

		return satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents );

	}

	clampPoint( point, target ) {

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		const clampedPoint = _vector$b.copy( point ).clamp( this.min, this.max );

		return clampedPoint.sub( point ).length();

	}

	getBoundingSphere( target ) {

		this.getCenter( target.center );

		target.radius = this.getSize( _vector$b ).length() * 0.5;

		return target;

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if ( this.isEmpty() ) this.makeEmpty();

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	applyMatrix4( matrix ) {

		// transform of empty box is an empty box.
		if ( this.isEmpty() ) return this;

		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

		this.setFromPoints( _points );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

const _points = [
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3()
];

const _vector$b = /*@__PURE__*/ new Vector3();

const _box$3 = /*@__PURE__*/ new Box3();

// triangle centered vertices

const _v0$2 = /*@__PURE__*/ new Vector3();
const _v1$7 = /*@__PURE__*/ new Vector3();
const _v2$4 = /*@__PURE__*/ new Vector3();

// triangle edge vectors

const _f0 = /*@__PURE__*/ new Vector3();
const _f1 = /*@__PURE__*/ new Vector3();
const _f2 = /*@__PURE__*/ new Vector3();

const _center = /*@__PURE__*/ new Vector3();
const _extents = /*@__PURE__*/ new Vector3();
const _triangleNormal = /*@__PURE__*/ new Vector3();
const _testAxis = /*@__PURE__*/ new Vector3();

function satForAxes( axes, v0, v1, v2, extents ) {

	for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

		_testAxis.fromArray( axes, i );
		// project the aabb onto the separating axis
		const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
		// project all 3 vertices of the triangle onto the separating axis
		const p0 = v0.dot( _testAxis );
		const p1 = v1.dot( _testAxis );
		const p2 = v2.dot( _testAxis );
		// actual test, basically see if either of the most extreme of the triangle points intersects r
		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

			// points of the projected triangle are outside the projected half-length of the aabb
			// the axis is separating and we can exit
			return false;

		}

	}

	return true;

}

const _box$2 = /*@__PURE__*/ new Box3();
const _v1$6 = /*@__PURE__*/ new Vector3();
const _v2$3 = /*@__PURE__*/ new Vector3();

class Sphere {

	constructor( center = new Vector3(), radius = - 1 ) {

		this.center = center;
		this.radius = radius;

	}

	set( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	}

	setFromPoints( points, optionalCenter ) {

		const center = this.center;

		if ( optionalCenter !== undefined ) {

			center.copy( optionalCenter );

		} else {

			_box$2.setFromPoints( points ).getCenter( center );

		}

		let maxRadiusSq = 0;

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

		}

		this.radius = Math.sqrt( maxRadiusSq );

		return this;

	}

	copy( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	}

	isEmpty() {

		return ( this.radius < 0 );

	}

	makeEmpty() {

		this.center.set( 0, 0, 0 );
		this.radius = - 1;

		return this;

	}

	containsPoint( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	}

	distanceToPoint( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	}

	intersectsSphere( sphere ) {

		const radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	}

	intersectsBox( box ) {

		return box.intersectsSphere( this );

	}

	intersectsPlane( plane ) {

		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

	}

	clampPoint( point, target ) {

		const deltaLengthSq = this.center.distanceToSquared( point );

		target.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			target.sub( this.center ).normalize();
			target.multiplyScalar( this.radius ).add( this.center );

		}

		return target;

	}

	getBoundingBox( target ) {

		if ( this.isEmpty() ) {

			// Empty sphere produces empty bounding box
			target.makeEmpty();
			return target;

		}

		target.set( this.center, this.center );
		target.expandByScalar( this.radius );

		return target;

	}

	applyMatrix4( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	}

	translate( offset ) {

		this.center.add( offset );

		return this;

	}

	expandByPoint( point ) {

		if ( this.isEmpty() ) {

			this.center.copy( point );

			this.radius = 0;

			return this;

		}

		_v1$6.subVectors( point, this.center );

		const lengthSq = _v1$6.lengthSq();

		if ( lengthSq > ( this.radius * this.radius ) ) {

			// calculate the minimal sphere

			const length = Math.sqrt( lengthSq );

			const delta = ( length - this.radius ) * 0.5;

			this.center.addScaledVector( _v1$6, delta / length );

			this.radius += delta;

		}

		return this;

	}

	union( sphere ) {

		if ( sphere.isEmpty() ) {

			return this;

		}

		if ( this.isEmpty() ) {

			this.copy( sphere );

			return this;

		}

		if ( this.center.equals( sphere.center ) === true ) {

			 this.radius = Math.max( this.radius, sphere.radius );

		} else {

			_v2$3.subVectors( sphere.center, this.center ).setLength( sphere.radius );

			this.expandByPoint( _v1$6.copy( sphere.center ).add( _v2$3 ) );

			this.expandByPoint( _v1$6.copy( sphere.center ).sub( _v2$3 ) );

		}

		return this;

	}

	equals( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$a = /*@__PURE__*/ new Vector3();
const _segCenter = /*@__PURE__*/ new Vector3();
const _segDir = /*@__PURE__*/ new Vector3();
const _diff = /*@__PURE__*/ new Vector3();

const _edge1 = /*@__PURE__*/ new Vector3();
const _edge2 = /*@__PURE__*/ new Vector3();
const _normal$1 = /*@__PURE__*/ new Vector3();

class Ray {

	constructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {

		this.origin = origin;
		this.direction = direction;

	}

	set( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	}

	copy( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	}

	at( t, target ) {

		return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	}

	lookAt( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	}

	recast( t ) {

		this.origin.copy( this.at( t, _vector$a ) );

		return this;

	}

	closestPointToPoint( point, target ) {

		target.subVectors( point, this.origin );

		const directionDistance = target.dot( this.direction );

		if ( directionDistance < 0 ) {

			return target.copy( this.origin );

		}

		return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	}

	distanceToPoint( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	}

	distanceSqToPoint( point ) {

		const directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );

		// point behind the ray

		if ( directionDistance < 0 ) {

			return this.origin.distanceToSquared( point );

		}

		_vector$a.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		return _vector$a.distanceToSquared( point );

	}

	distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
		_segDir.copy( v1 ).sub( v0 ).normalize();
		_diff.copy( this.origin ).sub( _segCenter );

		const segExtent = v0.distanceTo( v1 ) * 0.5;
		const a01 = - this.direction.dot( _segDir );
		const b0 = _diff.dot( this.direction );
		const b1 = - _diff.dot( _segDir );
		const c = _diff.lengthSq();
		const det = Math.abs( 1 - a01 * a01 );
		let s0, s1, sqrDist, extDet;

		if ( det > 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						const invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet ) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );

		}

		return sqrDist;

	}

	intersectSphere( sphere, target ) {

		_vector$a.subVectors( sphere.center, this.origin );
		const tca = _vector$a.dot( this.direction );
		const d2 = _vector$a.dot( _vector$a ) - tca * tca;
		const radius2 = sphere.radius * sphere.radius;

		if ( d2 > radius2 ) return null;

		const thc = Math.sqrt( radius2 - d2 );

		// t0 = first intersect point - entrance on front of sphere
		const t0 = tca - thc;

		// t1 = second intersect point - exit point on back of sphere
		const t1 = tca + thc;

		// test to see if both t0 and t1 are behind the ray - if so, return null
		if ( t0 < 0 && t1 < 0 ) return null;

		// test to see if t0 is behind the ray:
		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		// in order to always return an intersect point that is in front of the ray.
		if ( t0 < 0 ) return this.at( t1, target );

		// else t0 is in front of the ray, so return the first collision point scaled by t0
		return this.at( t0, target );

	}

	intersectsSphere( sphere ) {

		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	distanceToPlane( plane ) {

		const denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t : null;

	}

	intersectPlane( plane, target ) {

		const t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, target );

	}

	intersectsPlane( plane ) {

		// check if the ray lies on the plane first

		const distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		const denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	}

	intersectBox( box, target ) {

		let tmin, tmax, tymin, tymax, tzmin, tzmax;

		const invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		const origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		if ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;

		if ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, target );

	}

	intersectsBox( box ) {

		return this.intersectBox( box, _vector$a ) !== null;

	}

	intersectTriangle( a, b, c, backfaceCulling, target ) {

		// Compute the offset origin, edges, and normal.

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		_edge1.subVectors( b, a );
		_edge2.subVectors( c, a );
		_normal$1.crossVectors( _edge1, _edge2 );

		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		let DdN = this.direction.dot( _normal$1 );
		let sign;

		if ( DdN > 0 ) {

			if ( backfaceCulling ) return null;
			sign = 1;

		} else if ( DdN < 0 ) {

			sign = - 1;
			DdN = - DdN;

		} else {

			return null;

		}

		_diff.subVectors( this.origin, a );
		const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

		// b1 < 0, no intersection
		if ( DdQxE2 < 0 ) {

			return null;

		}

		const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

		// b2 < 0, no intersection
		if ( DdE1xQ < 0 ) {

			return null;

		}

		// b1+b2 > 1, no intersection
		if ( DdQxE2 + DdE1xQ > DdN ) {

			return null;

		}

		// Line intersects triangle, check if ray does.
		const QdN = - sign * _diff.dot( _normal$1 );

		// t < 0, no intersection
		if ( QdN < 0 ) {

			return null;

		}

		// Ray intersects triangle.
		return this.at( QdN / DdN, target );

	}

	applyMatrix4( matrix4 ) {

		this.origin.applyMatrix4( matrix4 );
		this.direction.transformDirection( matrix4 );

		return this;

	}

	equals( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

class Matrix4 {

	constructor() {

		Matrix4.prototype.isMatrix4 = true;

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

	}

	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	clone() {

		return new Matrix4().fromArray( this.elements );

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	}

	copyPosition( m ) {

		const te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	}

	setFromMatrix3( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ], 0,
			me[ 1 ], me[ 4 ], me[ 7 ], 0,
			me[ 2 ], me[ 5 ], me[ 8 ], 0,
			0, 0, 0, 1

		);

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	}

	makeBasis( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	}

	extractRotation( m ) {

		// this method does not support reflection matrices

		const te = this.elements;
		const me = m.elements;

		const scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
		const scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
		const scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromEuler( euler ) {

		const te = this.elements;

		const x = euler.x, y = euler.y, z = euler.z;
		const a = Math.cos( x ), b = Math.sin( x );
		const c = Math.cos( y ), d = Math.sin( y );
		const e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromQuaternion( q ) {

		return this.compose( _zero, q, _one );

	}

	lookAt( eye, target, up ) {

		const te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	}

	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	}

	transpose() {

		const te = this.elements;
		let tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	}

	setPosition( x, y, z ) {

		const te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	}

	invert() {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	}

	scale( v ) {

		const te = this.elements;
		const x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	}

	getMaxScaleOnAxis() {

		const te = this.elements;

		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	}

	makeTranslation( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationX( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationY( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	}

	makeRotationZ( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationAxis( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		const c = Math.cos( angle );
		const s = Math.sin( angle );
		const t = 1 - c;
		const x = axis.x, y = axis.y, z = axis.z;
		const tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeScale( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeShear( xy, xz, yx, yz, zx, zy ) {

		this.set(

			1, yx, zx, 0,
			xy, 1, zy, 0,
			xz, yz, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	compose( position, quaternion, scale ) {

		const te = this.elements;

		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		const x2 = x + x,	y2 = y + y, z2 = z + z;
		const xx = x * x2, xy = x * y2, xz = x * z2;
		const yy = y * y2, yz = y * z2, zz = z * z2;
		const wx = w * x2, wy = w * y2, wz = w * z2;

		const sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	}

	decompose( position, quaternion, scale ) {

		const te = this.elements;

		let sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		const sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		const sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		const det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1$2.copy( this );

		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;

		_m1$2.elements[ 0 ] *= invSX;
		_m1$2.elements[ 1 ] *= invSX;
		_m1$2.elements[ 2 ] *= invSX;

		_m1$2.elements[ 4 ] *= invSY;
		_m1$2.elements[ 5 ] *= invSY;
		_m1$2.elements[ 6 ] *= invSY;

		_m1$2.elements[ 8 ] *= invSZ;
		_m1$2.elements[ 9 ] *= invSZ;
		_m1$2.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1$2 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	}

	makePerspective( left, right, top, bottom, near, far ) {

		const te = this.elements;
		const x = 2 * near / ( right - left );
		const y = 2 * near / ( top - bottom );

		const a = ( right + left ) / ( right - left );
		const b = ( top + bottom ) / ( top - bottom );
		const c = - ( far + near ) / ( far - near );
		const d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	}

	makeOrthographic( left, right, top, bottom, near, far ) {

		const te = this.elements;
		const w = 1.0 / ( right - left );
		const h = 1.0 / ( top - bottom );
		const p = 1.0 / ( far - near );

		const x = ( right + left ) * w;
		const y = ( top + bottom ) * h;
		const z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

}

const _v1$5 = /*@__PURE__*/ new Vector3();
const _m1$2 = /*@__PURE__*/ new Matrix4();
const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
const _x = /*@__PURE__*/ new Vector3();
const _y = /*@__PURE__*/ new Vector3();
const _z = /*@__PURE__*/ new Vector3();

const _matrix$1 = /*@__PURE__*/ new Matrix4();
const _quaternion$3 = /*@__PURE__*/ new Quaternion();

class Euler {

	constructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {

		this.isEuler = true;

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get order() {

		return this._order;

	}

	set order( value ) {

		this._order = value;
		this._onChangeCallback();

	}

	set( x, y, z, order = this._order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._order );

	}

	copy( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m, order = this._order, update = true ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements;
		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		switch ( order ) {

			case 'XYZ':

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

				break;

			case 'YXZ':

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

				break;

			case 'ZXY':

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

				break;

			case 'ZYX':

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

				break;

			case 'YZX':

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

				break;

			case 'XZY':

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

				break;

			default:

				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		}

		this._order = order;

		if ( update === true ) this._onChangeCallback();

		return this;

	}

	setFromQuaternion( q, order, update ) {

		_matrix$1.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix$1, order, update );

	}

	setFromVector3( v, order = this._order ) {

		return this.set( v.x, v.y, v.z, order );

	}

	reorder( newOrder ) {

		// WARNING: this discards revolution information -bhouston

		_quaternion$3.setFromEuler( this );

		return this.setFromQuaternion( _quaternion$3, newOrder );

	}

	equals( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	}

	fromArray( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

	*[ Symbol.iterator ]() {

		yield this._x;
		yield this._y;
		yield this._z;
		yield this._order;

	}

}

Euler.DEFAULT_ORDER = 'XYZ';

class Layers {

	constructor() {

		this.mask = 1 | 0;

	}

	set( channel ) {

		this.mask = ( 1 << channel | 0 ) >>> 0;

	}

	enable( channel ) {

		this.mask |= 1 << channel | 0;

	}

	enableAll() {

		this.mask = 0xffffffff | 0;

	}

	toggle( channel ) {

		this.mask ^= 1 << channel | 0;

	}

	disable( channel ) {

		this.mask &= ~ ( 1 << channel | 0 );

	}

	disableAll() {

		this.mask = 0;

	}

	test( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

	isEnabled( channel ) {

		return ( this.mask & ( 1 << channel | 0 ) ) !== 0;

	}

}

let _object3DId = 0;

const _v1$4 = /*@__PURE__*/ new Vector3();
const _q1 = /*@__PURE__*/ new Quaternion();
const _m1$1 = /*@__PURE__*/ new Matrix4();
const _target = /*@__PURE__*/ new Vector3();

const _position$3 = /*@__PURE__*/ new Vector3();
const _scale$2 = /*@__PURE__*/ new Vector3();
const _quaternion$2 = /*@__PURE__*/ new Quaternion();

const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

const _addedEvent = { type: 'added' };
const _removedEvent = { type: 'removed' };

class Object3D extends EventDispatcher {

	constructor() {

		super();

		this.isObject3D = true;

		Object.defineProperty( this, 'id', { value: _object3DId ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = Object3D.DEFAULT_UP.clone();

		const position = new Vector3();
		const rotation = new Euler();
		const quaternion = new Quaternion();
		const scale = new Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation._onChange( onRotationChange );
		quaternion._onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			scale: {
				configurable: true,
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		} );

		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();

		this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
		this.matrixWorldNeedsUpdate = false;

		this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer

		this.layers = new Layers();
		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.animations = [];

		this.userData = {};

	}

	onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	applyMatrix4( matrix ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		this.matrix.premultiply( matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	}

	applyQuaternion( q ) {

		this.quaternion.premultiply( q );

		return this;

	}

	setRotationFromAxisAngle( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	}

	setRotationFromEuler( euler ) {

		this.quaternion.setFromEuler( euler, true );

	}

	setRotationFromMatrix( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	}

	setRotationFromQuaternion( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	}

	rotateOnAxis( axis, angle ) {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.multiply( _q1 );

		return this;

	}

	rotateOnWorldAxis( axis, angle ) {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.premultiply( _q1 );

		return this;

	}

	rotateX( angle ) {

		return this.rotateOnAxis( _xAxis, angle );

	}

	rotateY( angle ) {

		return this.rotateOnAxis( _yAxis, angle );

	}

	rotateZ( angle ) {

		return this.rotateOnAxis( _zAxis, angle );

	}

	translateOnAxis( axis, distance ) {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1$4.copy( axis ).applyQuaternion( this.quaternion );

		this.position.add( _v1$4.multiplyScalar( distance ) );

		return this;

	}

	translateX( distance ) {

		return this.translateOnAxis( _xAxis, distance );

	}

	translateY( distance ) {

		return this.translateOnAxis( _yAxis, distance );

	}

	translateZ( distance ) {

		return this.translateOnAxis( _zAxis, distance );

	}

	localToWorld( vector ) {

		this.updateWorldMatrix( true, false );

		return vector.applyMatrix4( this.matrixWorld );

	}

	worldToLocal( vector ) {

		this.updateWorldMatrix( true, false );

		return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

	}

	lookAt( x, y, z ) {

		// This method does not support objects having non-uniformly-scaled parent(s)

		if ( x.isVector3 ) {

			_target.copy( x );

		} else {

			_target.set( x, y, z );

		}

		const parent = this.parent;

		this.updateWorldMatrix( true, false );

		_position$3.setFromMatrixPosition( this.matrixWorld );

		if ( this.isCamera || this.isLight ) {

			_m1$1.lookAt( _position$3, _target, this.up );

		} else {

			_m1$1.lookAt( _target, _position$3, this.up );

		}

		this.quaternion.setFromRotationMatrix( _m1$1 );

		if ( parent ) {

			_m1$1.extractRotation( parent.matrixWorld );
			_q1.setFromRotationMatrix( _m1$1 );
			this.quaternion.premultiply( _q1.invert() );

		}

	}

	add( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
			return this;

		}

		if ( object && object.isObject3D ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			this.children.push( object );

			object.dispatchEvent( _addedEvent );

		} else {

			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

		}

		return this;

	}

	remove( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		const index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;
			this.children.splice( index, 1 );

			object.dispatchEvent( _removedEvent );

		}

		return this;

	}

	removeFromParent() {

		const parent = this.parent;

		if ( parent !== null ) {

			parent.remove( this );

		}

		return this;

	}

	clear() {

		for ( let i = 0; i < this.children.length; i ++ ) {

			const object = this.children[ i ];

			object.parent = null;

			object.dispatchEvent( _removedEvent );

		}

		this.children.length = 0;

		return this;


	}

	attach( object ) {

		// adds object as a child of this, while maintaining the object's world transform

		// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

		this.updateWorldMatrix( true, false );

		_m1$1.copy( this.matrixWorld ).invert();

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1$1.multiply( object.parent.matrixWorld );

		}

		object.applyMatrix4( _m1$1 );

		this.add( object );

		object.updateWorldMatrix( false, true );

		return this;

	}

	getObjectById( id ) {

		return this.getObjectByProperty( 'id', id );

	}

	getObjectByName( name ) {

		return this.getObjectByProperty( 'name', name );

	}

	getObjectByProperty( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

			const child = this.children[ i ];
			const object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	}

	getObjectsByProperty( name, value ) {

		let result = [];

		if ( this[ name ] === value ) result.push( this );

		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

			const childResult = this.children[ i ].getObjectsByProperty( name, value );

			if ( childResult.length > 0 ) {

				result = result.concat( childResult );

			}

		}

		return result;

	}

	getWorldPosition( target ) {

		this.updateWorldMatrix( true, false );

		return target.setFromMatrixPosition( this.matrixWorld );

	}

	getWorldQuaternion( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, target, _scale$2 );

		return target;

	}

	getWorldScale( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, _quaternion$2, target );

		return target;

	}

	getWorldDirection( target ) {

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	}

	raycast( /* raycaster, intersects */ ) {}

	traverse( callback ) {

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	}

	traverseVisible( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	}

	traverseAncestors( callback ) {

		const parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	}

	updateMatrix() {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	}

	updateMatrixWorld( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			const child = children[ i ];

			if ( child.matrixWorldAutoUpdate === true || force === true ) {

				child.updateMatrixWorld( force );

			}

		}

	}

	updateWorldMatrix( updateParents, updateChildren ) {

		const parent = this.parent;

		if ( updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			this.matrixWorld.copy( this.matrix );

		} else {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		}

		// update children

		if ( updateChildren === true ) {

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				const child = children[ i ];

				if ( child.matrixWorldAutoUpdate === true ) {

					child.updateWorldMatrix( false, true );

				}

			}

		}

	}

	toJSON( meta ) {

		// meta is a string when called from JSON.stringify
		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		const output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {},
				skeletons: {},
				animations: {},
				nodes: {}
			};

			output.metadata = {
				version: 4.5,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		const object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;
		if ( this.frustumCulled === false ) object.frustumCulled = false;
		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
		if ( Object.keys( this.userData ).length > 0 ) object.userData = this.userData;

		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();

		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

		// object specific properties

		if ( this.isInstancedMesh ) {

			object.type = 'InstancedMesh';
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();
			if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

		}

		//

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}

		if ( this.isScene ) {

			if ( this.background ) {

				if ( this.background.isColor ) {

					object.background = this.background.toJSON();

				} else if ( this.background.isTexture ) {

					object.background = this.background.toJSON( meta ).uuid;

				}

			}

			if ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {

				object.environment = this.environment.toJSON( meta ).uuid;

			}

		} else if ( this.isMesh || this.isLine || this.isPoints ) {

			object.geometry = serialize( meta.geometries, this.geometry );

			const parameters = this.geometry.parameters;

			if ( parameters !== undefined && parameters.shapes !== undefined ) {

				const shapes = parameters.shapes;

				if ( Array.isArray( shapes ) ) {

					for ( let i = 0, l = shapes.length; i < l; i ++ ) {

						const shape = shapes[ i ];

						serialize( meta.shapes, shape );

					}

				} else {

					serialize( meta.shapes, shapes );

				}

			}

		}

		if ( this.isSkinnedMesh ) {

			object.bindMode = this.bindMode;
			object.bindMatrix = this.bindMatrix.toArray();

			if ( this.skeleton !== undefined ) {

				serialize( meta.skeletons, this.skeleton );

				object.skeleton = this.skeleton.uuid;

			}

		}

		if ( this.material !== undefined ) {

			if ( Array.isArray( this.material ) ) {

				const uuids = [];

				for ( let i = 0, l = this.material.length; i < l; i ++ ) {

					uuids.push( serialize( meta.materials, this.material[ i ] ) );

				}

				object.material = uuids;

			} else {

				object.material = serialize( meta.materials, this.material );

			}

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( let i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		//

		if ( this.animations.length > 0 ) {

			object.animations = [];

			for ( let i = 0; i < this.animations.length; i ++ ) {

				const animation = this.animations[ i ];

				object.animations.push( serialize( meta.animations, animation ) );

			}

		}

		if ( isRootObject ) {

			const geometries = extractFromCache( meta.geometries );
			const materials = extractFromCache( meta.materials );
			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );
			const shapes = extractFromCache( meta.shapes );
			const skeletons = extractFromCache( meta.skeletons );
			const animations = extractFromCache( meta.animations );
			const nodes = extractFromCache( meta.nodes );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;
			if ( shapes.length > 0 ) output.shapes = shapes;
			if ( skeletons.length > 0 ) output.skeletons = skeletons;
			if ( animations.length > 0 ) output.animations = animations;
			if ( nodes.length > 0 ) output.nodes = nodes;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			const values = [];
			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

	}

	clone( recursive ) {

		return new this.constructor().copy( this, recursive );

	}

	copy( source, recursive = true ) {

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.rotation.order = source.rotation.order;
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( let i = 0; i < source.children.length; i ++ ) {

				const child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

}

Object3D.DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;

const _v0$1 = /*@__PURE__*/ new Vector3();
const _v1$3 = /*@__PURE__*/ new Vector3();
const _v2$2 = /*@__PURE__*/ new Vector3();
const _v3$1 = /*@__PURE__*/ new Vector3();

const _vab = /*@__PURE__*/ new Vector3();
const _vac = /*@__PURE__*/ new Vector3();
const _vbc = /*@__PURE__*/ new Vector3();
const _vap = /*@__PURE__*/ new Vector3();
const _vbp = /*@__PURE__*/ new Vector3();
const _vcp = /*@__PURE__*/ new Vector3();

class Triangle {

	constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

		this.a = a;
		this.b = b;
		this.c = c;

	}

	static getNormal( a, b, c, target ) {

		target.subVectors( c, b );
		_v0$1.subVectors( a, b );
		target.cross( _v0$1 );

		const targetLengthSq = target.lengthSq();
		if ( targetLengthSq > 0 ) {

			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

		}

		return target.set( 0, 0, 0 );

	}

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	static getBarycoord( point, a, b, c, target ) {

		_v0$1.subVectors( c, a );
		_v1$3.subVectors( b, a );
		_v2$2.subVectors( point, a );

		const dot00 = _v0$1.dot( _v0$1 );
		const dot01 = _v0$1.dot( _v1$3 );
		const dot02 = _v0$1.dot( _v2$2 );
		const dot11 = _v1$3.dot( _v1$3 );
		const dot12 = _v1$3.dot( _v2$2 );

		const denom = ( dot00 * dot11 - dot01 * dot01 );

		// collinear or singular triangle
		if ( denom === 0 ) {

			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return target.set( - 2, - 1, - 1 );

		}

		const invDenom = 1 / denom;
		const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return target.set( 1 - u - v, v, u );

	}

	static containsPoint( point, a, b, c ) {

		this.getBarycoord( point, a, b, c, _v3$1 );

		return ( _v3$1.x >= 0 ) && ( _v3$1.y >= 0 ) && ( ( _v3$1.x + _v3$1.y ) <= 1 );

	}

	static getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

		this.getBarycoord( point, p1, p2, p3, _v3$1 );

		target.set( 0, 0 );
		target.addScaledVector( uv1, _v3$1.x );
		target.addScaledVector( uv2, _v3$1.y );
		target.addScaledVector( uv3, _v3$1.z );

		return target;

	}

	static isFrontFacing( a, b, c, direction ) {

		_v0$1.subVectors( c, b );
		_v1$3.subVectors( a, b );

		// strictly front facing
		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

	}

	set( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	}

	setFromPointsAndIndices( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	}

	setFromAttributeAndIndices( attribute, i0, i1, i2 ) {

		this.a.fromBufferAttribute( attribute, i0 );
		this.b.fromBufferAttribute( attribute, i1 );
		this.c.fromBufferAttribute( attribute, i2 );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	}

	getArea() {

		_v0$1.subVectors( this.c, this.b );
		_v1$3.subVectors( this.a, this.b );

		return _v0$1.cross( _v1$3 ).length() * 0.5;

	}

	getMidpoint( target ) {

		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	}

	getNormal( target ) {

		return Triangle.getNormal( this.a, this.b, this.c, target );

	}

	getPlane( target ) {

		return target.setFromCoplanarPoints( this.a, this.b, this.c );

	}

	getBarycoord( point, target ) {

		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

	}

	getUV( point, uv1, uv2, uv3, target ) {

		return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

	}

	containsPoint( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	}

	isFrontFacing( direction ) {

		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

	}

	intersectsBox( box ) {

		return box.intersectsTriangle( this );

	}

	closestPointToPoint( p, target ) {

		const a = this.a, b = this.b, c = this.c;
		let v, w;

		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
		// basically, we're distinguishing which of the voronoi regions of the triangle
		// the point lies in with the minimum amount of redundant computation.

		_vab.subVectors( b, a );
		_vac.subVectors( c, a );
		_vap.subVectors( p, a );
		const d1 = _vab.dot( _vap );
		const d2 = _vac.dot( _vap );
		if ( d1 <= 0 && d2 <= 0 ) {

			// vertex region of A; barycentric coords (1, 0, 0)
			return target.copy( a );

		}

		_vbp.subVectors( p, b );
		const d3 = _vab.dot( _vbp );
		const d4 = _vac.dot( _vbp );
		if ( d3 >= 0 && d4 <= d3 ) {

			// vertex region of B; barycentric coords (0, 1, 0)
			return target.copy( b );

		}

		const vc = d1 * d4 - d3 * d2;
		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

			v = d1 / ( d1 - d3 );
			// edge region of AB; barycentric coords (1-v, v, 0)
			return target.copy( a ).addScaledVector( _vab, v );

		}

		_vcp.subVectors( p, c );
		const d5 = _vab.dot( _vcp );
		const d6 = _vac.dot( _vcp );
		if ( d6 >= 0 && d5 <= d6 ) {

			// vertex region of C; barycentric coords (0, 0, 1)
			return target.copy( c );

		}

		const vb = d5 * d2 - d1 * d6;
		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

			w = d2 / ( d2 - d6 );
			// edge region of AC; barycentric coords (1-w, 0, w)
			return target.copy( a ).addScaledVector( _vac, w );

		}

		const va = d3 * d6 - d5 * d4;
		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

			_vbc.subVectors( c, b );
			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
			// edge region of BC; barycentric coords (0, 1-w, w)
			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

		}

		// face region
		const denom = 1 / ( va + vb + vc );
		// u = va * denom
		v = vb * denom;
		w = vc * denom;

		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

	}

	equals( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

}

let materialId = 0;

class Material extends EventDispatcher {

	constructor() {

		super();

		this.isMaterial = true;

		Object.defineProperty( this, 'id', { value: materialId ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'Material';

		this.blending = NormalBlending;
		this.side = FrontSide;
		this.vertexColors = false;

		this.opacity = 1;
		this.transparent = false;

		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.stencilWriteMask = 0xff;
		this.stencilFunc = AlwaysStencilFunc;
		this.stencilRef = 0;
		this.stencilFuncMask = 0xff;
		this.stencilFail = KeepStencilOp;
		this.stencilZFail = KeepStencilOp;
		this.stencilZPass = KeepStencilOp;
		this.stencilWrite = false;

		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;

		this.shadowSide = null;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.dithering = false;

		this.alphaToCoverage = false;
		this.premultipliedAlpha = false;
		this.forceSinglePass = false;

		this.visible = true;

		this.toneMapped = true;

		this.userData = {};

		this.version = 0;

		this._alphaTest = 0;

	}

	get alphaTest() {

		return this._alphaTest;

	}

	set alphaTest( value ) {

		if ( this._alphaTest > 0 !== value > 0 ) {

			this.version ++;

		}

		this._alphaTest = value;

	}

	onBuild( /* shaderobject, renderer */ ) {}

	onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}

	onBeforeCompile( /* shaderobject, renderer */ ) {}

	customProgramCacheKey() {

		return this.onBeforeCompile.toString();

	}

	setValues( values ) {

		if ( values === undefined ) return;

		for ( const key in values ) {

			const newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
				continue;

			}

			const currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( 'THREE.' + this.type + ': \'' + key + '\' is not a property of this material.' );
				continue;

			}

			if ( currentValue && currentValue.isColor ) {

				currentValue.set( newValue );

			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				currentValue.copy( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( isRootObject ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		const data = {
			metadata: {
				version: 4.5,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) data.name = this.name;

		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;

		if ( this.sheen !== undefined ) data.sheen = this.sheen;
		if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();
		if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
		if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;
		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

		}

		if ( this.iridescence !== undefined ) data.iridescence = this.iridescence;
		if ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;
		if ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;

		if ( this.iridescenceMap && this.iridescenceMap.isTexture ) {

			data.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;

		}

		if ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {

			data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;

		}

		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

		if ( this.lightMap && this.lightMap.isTexture ) {

			data.lightMap = this.lightMap.toJSON( meta ).uuid;
			data.lightMapIntensity = this.lightMapIntensity;

		}

		if ( this.aoMap && this.aoMap.isTexture ) {

			data.aoMap = this.aoMap.toJSON( meta ).uuid;
			data.aoMapIntensity = this.aoMapIntensity;

		}

		if ( this.bumpMap && this.bumpMap.isTexture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}

		if ( this.normalMap && this.normalMap.isTexture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();

		}

		if ( this.displacementMap && this.displacementMap.isTexture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}

		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
		if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
		if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;

		if ( this.envMap && this.envMap.isTexture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;

			if ( this.combine !== undefined ) data.combine = this.combine;

		}

		if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
		if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
		if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

		if ( this.gradientMap && this.gradientMap.isTexture ) {

			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		}

		if ( this.transmission !== undefined ) data.transmission = this.transmission;
		if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
		if ( this.thickness !== undefined ) data.thickness = this.thickness;
		if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
		if ( this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity ) data.attenuationDistance = this.attenuationDistance;
		if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.blending !== NormalBlending ) data.blending = this.blending;
		if ( this.side !== FrontSide ) data.side = this.side;
		if ( this.vertexColors ) data.vertexColors = true;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = this.transparent;

		data.depthFunc = this.depthFunc;
		data.depthTest = this.depthTest;
		data.depthWrite = this.depthWrite;
		data.colorWrite = this.colorWrite;

		data.stencilWrite = this.stencilWrite;
		data.stencilWriteMask = this.stencilWriteMask;
		data.stencilFunc = this.stencilFunc;
		data.stencilRef = this.stencilRef;
		data.stencilFuncMask = this.stencilFuncMask;
		data.stencilFail = this.stencilFail;
		data.stencilZFail = this.stencilZFail;
		data.stencilZPass = this.stencilZPass;

		// rotation (SpriteMaterial)
		if ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;

		if ( this.polygonOffset === true ) data.polygonOffset = true;
		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

		if ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;
		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
		if ( this.scale !== undefined ) data.scale = this.scale;

		if ( this.dithering === true ) data.dithering = true;

		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.alphaToCoverage === true ) data.alphaToCoverage = this.alphaToCoverage;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
		if ( this.forceSinglePass === true ) data.forceSinglePass = this.forceSinglePass;

		if ( this.wireframe === true ) data.wireframe = this.wireframe;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		if ( this.flatShading === true ) data.flatShading = this.flatShading;

		if ( this.visible === false ) data.visible = false;

		if ( this.toneMapped === false ) data.toneMapped = false;

		if ( this.fog === false ) data.fog = false;

		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			const values = [];

			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRootObject ) {

			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.name = source.name;

		this.blending = source.blending;
		this.side = source.side;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.stencilWriteMask = source.stencilWriteMask;
		this.stencilFunc = source.stencilFunc;
		this.stencilRef = source.stencilRef;
		this.stencilFuncMask = source.stencilFuncMask;
		this.stencilFail = source.stencilFail;
		this.stencilZFail = source.stencilZFail;
		this.stencilZPass = source.stencilZPass;
		this.stencilWrite = source.stencilWrite;

		const srcPlanes = source.clippingPlanes;
		let dstPlanes = null;

		if ( srcPlanes !== null ) {

			const n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( let i = 0; i !== n; ++ i ) {

				dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

		}

		this.clippingPlanes = dstPlanes;
		this.clipIntersection = source.clipIntersection;
		this.clipShadows = source.clipShadows;

		this.shadowSide = source.shadowSide;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.dithering = source.dithering;

		this.alphaTest = source.alphaTest;
		this.alphaToCoverage = source.alphaToCoverage;
		this.premultipliedAlpha = source.premultipliedAlpha;
		this.forceSinglePass = source.forceSinglePass;

		this.visible = source.visible;

		this.toneMapped = source.toneMapped;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

}

class MeshBasicMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshBasicMaterial = true;

		this.type = 'MeshBasicMaterial';

		this.color = new Color( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.fog = source.fog;

		return this;

	}

}

const _vector$9 = /*@__PURE__*/ new Vector3();
const _vector2$1 = /*@__PURE__*/ new Vector2();

class BufferAttribute {

	constructor( array, itemSize, normalized = false ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.isBufferAttribute = true;

		this.name = '';

		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized;

		this.usage = StaticDrawUsage;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	}

	onUploadCallback() {}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	setUsage( value ) {

		this.usage = value;

		return this;

	}

	copy( source ) {

		this.name = source.name;
		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.usage = source.usage;

		return this;

	}

	copyAt( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	}

	copyArray( array ) {

		this.array.set( array );

		return this;

	}

	applyMatrix3( m ) {

		if ( this.itemSize === 2 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector2$1.fromBufferAttribute( this, i );
				_vector2$1.applyMatrix3( m );

				this.setXY( i, _vector2$1.x, _vector2$1.y );

			}

		} else if ( this.itemSize === 3 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$9.fromBufferAttribute( this, i );
				_vector$9.applyMatrix3( m );

				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

			}

		}

		return this;

	}

	applyMatrix4( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.applyMatrix4( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	applyNormalMatrix( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.applyNormalMatrix( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	transformDirection( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.transformDirection( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	set( value, offset = 0 ) {

		// Matching BufferAttribute constructor, do not normalize the array.
		this.array.set( value, offset );

		return this;

	}

	getX( index ) {

		let x = this.array[ index * this.itemSize ];

		if ( this.normalized ) x = denormalize( x, this.array );

		return x;

	}

	setX( index, x ) {

		if ( this.normalized ) x = normalize( x, this.array );

		this.array[ index * this.itemSize ] = x;

		return this;

	}

	getY( index ) {

		let y = this.array[ index * this.itemSize + 1 ];

		if ( this.normalized ) y = denormalize( y, this.array );

		return y;

	}

	setY( index, y ) {

		if ( this.normalized ) y = normalize( y, this.array );

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	}

	getZ( index ) {

		let z = this.array[ index * this.itemSize + 2 ];

		if ( this.normalized ) z = denormalize( z, this.array );

		return z;

	}

	setZ( index, z ) {

		if ( this.normalized ) z = normalize( z, this.array );

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	}

	getW( index ) {

		let w = this.array[ index * this.itemSize + 3 ];

		if ( this.normalized ) w = denormalize( w, this.array );

		return w;

	}

	setW( index, w ) {

		if ( this.normalized ) w = normalize( w, this.array );

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	}

	setXY( index, x, y ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );

		}

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	}

	setXYZ( index, x, y, z ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );

		}

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	}

	setXYZW( index, x, y, z, w ) {

		index *= this.itemSize;

		if ( this.normalized ) {

			x = normalize( x, this.array );
			y = normalize( y, this.array );
			z = normalize( z, this.array );
			w = normalize( w, this.array );

		}

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	}

	onUpload( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

	clone() {

		return new this.constructor( this.array, this.itemSize ).copy( this );

	}

	toJSON() {

		const data = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.from( this.array ),
			normalized: this.normalized
		};

		if ( this.name !== '' ) data.name = this.name;
		if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;
		if ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) data.updateRange = this.updateRange;

		return data;

	}

	// @deprecated

	copyColorsArray() {

		console.error( 'THREE.BufferAttribute: copyColorsArray() was removed in r144.' );

	}

	copyVector2sArray() {

		console.error( 'THREE.BufferAttribute: copyVector2sArray() was removed in r144.' );

	}

	copyVector3sArray() {

		console.error( 'THREE.BufferAttribute: copyVector3sArray() was removed in r144.' );

	}

	copyVector4sArray() {

		console.error( 'THREE.BufferAttribute: copyVector4sArray() was removed in r144.' );

	}

}

class Uint16BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint16Array( array ), itemSize, normalized );

	}

}

class Uint32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint32Array( array ), itemSize, normalized );

	}

}


class Float32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Float32Array( array ), itemSize, normalized );

	}

}

let _id$1 = 0;

const _m1 = /*@__PURE__*/ new Matrix4();
const _obj = /*@__PURE__*/ new Object3D();
const _offset = /*@__PURE__*/ new Vector3();
const _box$1 = /*@__PURE__*/ new Box3();
const _boxMorphTargets = /*@__PURE__*/ new Box3();
const _vector$8 = /*@__PURE__*/ new Vector3();

class BufferGeometry extends EventDispatcher {

	constructor() {

		super();

		this.isBufferGeometry = true;

		Object.defineProperty( this, 'id', { value: _id$1 ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};
		this.morphTargetsRelative = false;

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

		this.userData = {};

	}

	getIndex() {

		return this.index;

	}

	setIndex( index ) {

		if ( Array.isArray( index ) ) {

			this.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

		} else {

			this.index = index;

		}

		return this;

	}

	getAttribute( name ) {

		return this.attributes[ name ];

	}

	setAttribute( name, attribute ) {

		this.attributes[ name ] = attribute;

		return this;

	}

	deleteAttribute( name ) {

		delete this.attributes[ name ];

		return this;

	}

	hasAttribute( name ) {

		return this.attributes[ name ] !== undefined;

	}

	addGroup( start, count, materialIndex = 0 ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex

		} );

	}

	clearGroups() {

		this.groups = [];

	}

	setDrawRange( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	}

	applyMatrix4( matrix ) {

		const position = this.attributes.position;

		if ( position !== undefined ) {

			position.applyMatrix4( matrix );

			position.needsUpdate = true;

		}

		const normal = this.attributes.normal;

		if ( normal !== undefined ) {

			const normalMatrix = new Matrix3().getNormalMatrix( matrix );

			normal.applyNormalMatrix( normalMatrix );

			normal.needsUpdate = true;

		}

		const tangent = this.attributes.tangent;

		if ( tangent !== undefined ) {

			tangent.transformDirection( matrix );

			tangent.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	}

	applyQuaternion( q ) {

		_m1.makeRotationFromQuaternion( q );

		this.applyMatrix4( _m1 );

		return this;

	}

	rotateX( angle ) {

		// rotate geometry around world x-axis

		_m1.makeRotationX( angle );

		this.applyMatrix4( _m1 );

		return this;

	}

	rotateY( angle ) {

		// rotate geometry around world y-axis

		_m1.makeRotationY( angle );

		this.applyMatrix4( _m1 );

		return this;

	}

	rotateZ( angle ) {

		// rotate geometry around world z-axis

		_m1.makeRotationZ( angle );

		this.applyMatrix4( _m1 );

		return this;

	}

	translate( x, y, z ) {

		// translate geometry

		_m1.makeTranslation( x, y, z );

		this.applyMatrix4( _m1 );

		return this;

	}

	scale( x, y, z ) {

		// scale geometry

		_m1.makeScale( x, y, z );

		this.applyMatrix4( _m1 );

		return this;

	}

	lookAt( vector ) {

		_obj.lookAt( vector );

		_obj.updateMatrix();

		this.applyMatrix4( _obj.matrix );

		return this;

	}

	center() {

		this.computeBoundingBox();

		this.boundingBox.getCenter( _offset ).negate();

		this.translate( _offset.x, _offset.y, _offset.z );

		return this;

	}

	setFromPoints( points ) {

		const position = [];

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			const point = points[ i ];
			position.push( point.x, point.y, point.z || 0 );

		}

		this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

		return this;

	}

	computeBoundingBox() {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );

			this.boundingBox.set(
				new Vector3( - Infinity, - Infinity, - Infinity ),
				new Vector3( + Infinity, + Infinity, + Infinity )
			);

			return;

		}

		if ( position !== undefined ) {

			this.boundingBox.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_box$1.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( this.boundingBox.min, _box$1.min );
						this.boundingBox.expandByPoint( _vector$8 );

						_vector$8.addVectors( this.boundingBox.max, _box$1.max );
						this.boundingBox.expandByPoint( _vector$8 );

					} else {

						this.boundingBox.expandByPoint( _box$1.min );
						this.boundingBox.expandByPoint( _box$1.max );

					}

				}

			}

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	}

	computeBoundingSphere() {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );

			this.boundingSphere.set( new Vector3(), Infinity );

			return;

		}

		if ( position ) {

			// first, find the center of the bounding sphere

			const center = this.boundingSphere.center;

			_box$1.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( _box$1.min, _boxMorphTargets.min );
						_box$1.expandByPoint( _vector$8 );

						_vector$8.addVectors( _box$1.max, _boxMorphTargets.max );
						_box$1.expandByPoint( _vector$8 );

					} else {

						_box$1.expandByPoint( _boxMorphTargets.min );
						_box$1.expandByPoint( _boxMorphTargets.max );

					}

				}

			}

			_box$1.getCenter( center );

			// second, try to find a boundingSphere with a radius smaller than the
			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

			let maxRadiusSq = 0;

			for ( let i = 0, il = position.count; i < il; i ++ ) {

				_vector$8.fromBufferAttribute( position, i );

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

			}

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					const morphTargetsRelative = this.morphTargetsRelative;

					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

						_vector$8.fromBufferAttribute( morphAttribute, j );

						if ( morphTargetsRelative ) {

							_offset.fromBufferAttribute( position, j );
							_vector$8.add( _offset );

						}

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

					}

				}

			}

			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			if ( isNaN( this.boundingSphere.radius ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

			}

		}

	}

	computeTangents() {

		const index = this.index;
		const attributes = this.attributes;

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( index === null ||
			 attributes.position === undefined ||
			 attributes.normal === undefined ||
			 attributes.uv === undefined ) {

			console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
			return;

		}

		const indices = index.array;
		const positions = attributes.position.array;
		const normals = attributes.normal.array;
		const uvs = attributes.uv.array;

		const nVertices = positions.length / 3;

		if ( this.hasAttribute( 'tangent' ) === false ) {

			this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

		}

		const tangents = this.getAttribute( 'tangent' ).array;

		const tan1 = [], tan2 = [];

		for ( let i = 0; i < nVertices; i ++ ) {

			tan1[ i ] = new Vector3();
			tan2[ i ] = new Vector3();

		}

		const vA = new Vector3(),
			vB = new Vector3(),
			vC = new Vector3(),

			uvA = new Vector2(),
			uvB = new Vector2(),
			uvC = new Vector2(),

			sdir = new Vector3(),
			tdir = new Vector3();

		function handleTriangle( a, b, c ) {

			vA.fromArray( positions, a * 3 );
			vB.fromArray( positions, b * 3 );
			vC.fromArray( positions, c * 3 );

			uvA.fromArray( uvs, a * 2 );
			uvB.fromArray( uvs, b * 2 );
			uvC.fromArray( uvs, c * 2 );

			vB.sub( vA );
			vC.sub( vA );

			uvB.sub( uvA );
			uvC.sub( uvA );

			const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

			// silently ignore degenerate uv triangles having coincident or colinear vertices

			if ( ! isFinite( r ) ) return;

			sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
			tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		let groups = this.groups;

		if ( groups.length === 0 ) {

			groups = [ {
				start: 0,
				count: indices.length
			} ];

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleTriangle(
					indices[ j + 0 ],
					indices[ j + 1 ],
					indices[ j + 2 ]
				);

			}

		}

		const tmp = new Vector3(), tmp2 = new Vector3();
		const n = new Vector3(), n2 = new Vector3();

		function handleVertex( v ) {

			n.fromArray( normals, v * 3 );
			n2.copy( n );

			const t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			const test = tmp2.dot( tan2[ v ] );
			const w = ( test < 0.0 ) ? - 1.0 : 1.0;

			tangents[ v * 4 ] = tmp.x;
			tangents[ v * 4 + 1 ] = tmp.y;
			tangents[ v * 4 + 2 ] = tmp.z;
			tangents[ v * 4 + 3 ] = w;

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleVertex( indices[ j + 0 ] );
				handleVertex( indices[ j + 1 ] );
				handleVertex( indices[ j + 2 ] );

			}

		}

	}

	computeVertexNormals() {

		const index = this.index;
		const positionAttribute = this.getAttribute( 'position' );

		if ( positionAttribute !== undefined ) {

			let normalAttribute = this.getAttribute( 'normal' );

			if ( normalAttribute === undefined ) {

				normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
				this.setAttribute( 'normal', normalAttribute );

			} else {

				// reset existing normals to zero

				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

					normalAttribute.setXYZ( i, 0, 0, 0 );

				}

			}

			const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
			const cb = new Vector3(), ab = new Vector3();

			// indexed elements

			if ( index ) {

				for ( let i = 0, il = index.count; i < il; i += 3 ) {

					const vA = index.getX( i + 0 );
					const vB = index.getX( i + 1 );
					const vC = index.getX( i + 2 );

					pA.fromBufferAttribute( positionAttribute, vA );
					pB.fromBufferAttribute( positionAttribute, vB );
					pC.fromBufferAttribute( positionAttribute, vC );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					nA.fromBufferAttribute( normalAttribute, vA );
					nB.fromBufferAttribute( normalAttribute, vB );
					nC.fromBufferAttribute( normalAttribute, vC );

					nA.add( cb );
					nB.add( cb );
					nC.add( cb );

					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

					pA.fromBufferAttribute( positionAttribute, i + 0 );
					pB.fromBufferAttribute( positionAttribute, i + 1 );
					pC.fromBufferAttribute( positionAttribute, i + 2 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

				}

			}

			this.normalizeNormals();

			normalAttribute.needsUpdate = true;

		}

	}

	// @deprecated since r144

	merge() {

		console.error( 'THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead.' );
		return this;

	}

	normalizeNormals() {

		const normals = this.attributes.normal;

		for ( let i = 0, il = normals.count; i < il; i ++ ) {

			_vector$8.fromBufferAttribute( normals, i );

			_vector$8.normalize();

			normals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

		}

	}

	toNonIndexed() {

		function convertBufferAttribute( attribute, indices ) {

			const array = attribute.array;
			const itemSize = attribute.itemSize;
			const normalized = attribute.normalized;

			const array2 = new array.constructor( indices.length * itemSize );

			let index = 0, index2 = 0;

			for ( let i = 0, l = indices.length; i < l; i ++ ) {

				if ( attribute.isInterleavedBufferAttribute ) {

					index = indices[ i ] * attribute.data.stride + attribute.offset;

				} else {

					index = indices[ i ] * itemSize;

				}

				for ( let j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			return new BufferAttribute( array2, itemSize, normalized );

		}

		//

		if ( this.index === null ) {

			console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
			return this;

		}

		const geometry2 = new BufferGeometry();

		const indices = this.index.array;
		const attributes = this.attributes;

		// attributes

		for ( const name in attributes ) {

			const attribute = attributes[ name ];

			const newAttribute = convertBufferAttribute( attribute, indices );

			geometry2.setAttribute( name, newAttribute );

		}

		// morph attributes

		const morphAttributes = this.morphAttributes;

		for ( const name in morphAttributes ) {

			const morphArray = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

				const attribute = morphAttribute[ i ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				morphArray.push( newAttribute );

			}

			geometry2.morphAttributes[ name ] = morphArray;

		}

		geometry2.morphTargetsRelative = this.morphTargetsRelative;

		// groups

		const groups = this.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			geometry2.addGroup( group.start, group.count, group.materialIndex );

		}

		return geometry2;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.5,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;
		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		if ( this.parameters !== undefined ) {

			const parameters = this.parameters;

			for ( const key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		// for simplicity the code assumes attributes are not shared across geometries, see #15811

		data.data = { attributes: {} };

		const index = this.index;

		if ( index !== null ) {

			data.data.index = {
				type: index.array.constructor.name,
				array: Array.prototype.slice.call( index.array )
			};

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];

			data.data.attributes[ key ] = attribute.toJSON( data.data );

		}

		const morphAttributes = {};
		let hasMorphAttributes = false;

		for ( const key in this.morphAttributes ) {

			const attributeArray = this.morphAttributes[ key ];

			const array = [];

			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

				const attribute = attributeArray[ i ];

				array.push( attribute.toJSON( data.data ) );

			}

			if ( array.length > 0 ) {

				morphAttributes[ key ] = array;

				hasMorphAttributes = true;

			}

		}

		if ( hasMorphAttributes ) {

			data.data.morphAttributes = morphAttributes;
			data.data.morphTargetsRelative = this.morphTargetsRelative;

		}

		const groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		const boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// used for storing cloned, shared data

		const data = {};

		// name

		this.name = source.name;

		// index

		const index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone( data ) );

		}

		// attributes

		const attributes = source.attributes;

		for ( const name in attributes ) {

			const attribute = attributes[ name ];
			this.setAttribute( name, attribute.clone( data ) );

		}

		// morph attributes

		const morphAttributes = source.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

				array.push( morphAttribute[ i ].clone( data ) );

			}

			this.morphAttributes[ name ] = array;

		}

		this.morphTargetsRelative = source.morphTargetsRelative;

		// groups

		const groups = source.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		// bounding box

		const boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		const boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		// user data

		this.userData = source.userData;

		// geometry generator parameters

		if ( source.parameters !== undefined ) this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

const _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();
const _ray$2 = /*@__PURE__*/ new Ray();
const _sphere$3 = /*@__PURE__*/ new Sphere();

const _vA$1 = /*@__PURE__*/ new Vector3();
const _vB$1 = /*@__PURE__*/ new Vector3();
const _vC$1 = /*@__PURE__*/ new Vector3();

const _tempA = /*@__PURE__*/ new Vector3();
const _morphA = /*@__PURE__*/ new Vector3();

const _uvA$1 = /*@__PURE__*/ new Vector2();
const _uvB$1 = /*@__PURE__*/ new Vector2();
const _uvC$1 = /*@__PURE__*/ new Vector2();

const _intersectionPoint = /*@__PURE__*/ new Vector3();
const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

class Mesh extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

		super();

		this.isMesh = true;

		this.type = 'Mesh';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.morphTargetInfluences !== undefined ) {

			this.morphTargetInfluences = source.morphTargetInfluences.slice();

		}

		if ( source.morphTargetDictionary !== undefined ) {

			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

		}

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

	getVertexPosition( index, target ) {

		const geometry = this.geometry;
		const position = geometry.attributes.position;
		const morphPosition = geometry.morphAttributes.position;
		const morphTargetsRelative = geometry.morphTargetsRelative;

		target.fromBufferAttribute( position, index );

		const morphInfluences = this.morphTargetInfluences;

		if ( morphPosition && morphInfluences ) {

			_morphA.set( 0, 0, 0 );

			for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

				const influence = morphInfluences[ i ];
				const morphAttribute = morphPosition[ i ];

				if ( influence === 0 ) continue;

				_tempA.fromBufferAttribute( morphAttribute, index );

				if ( morphTargetsRelative ) {

					_morphA.addScaledVector( _tempA, influence );

				} else {

					_morphA.addScaledVector( _tempA.sub( target ), influence );

				}

			}

			target.add( _morphA );

		}

		if ( this.isSkinnedMesh ) {

			this.boneTransform( index, target );

		}

		return target;

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const material = this.material;
		const matrixWorld = this.matrixWorld;

		if ( material === undefined ) return;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$3.copy( geometry.boundingSphere );
		_sphere$3.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;

		//

		_inverseMatrix$2.copy( matrixWorld ).invert();
		_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

		// Check boundingBox before continuing

		if ( geometry.boundingBox !== null ) {

			if ( _ray$2.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		let intersection;

		const index = geometry.index;
		const position = geometry.attributes.position;
		const uv = geometry.attributes.uv;
		const uv2 = geometry.attributes.uv2;
		const groups = geometry.groups;
		const drawRange = geometry.drawRange;

		if ( index !== null ) {

			// indexed buffer geometry

			if ( Array.isArray( material ) ) {

				for ( let i = 0, il = groups.length; i < il; i ++ ) {

					const group = groups[ i ];
					const groupMaterial = material[ group.materialIndex ];

					const start = Math.max( group.start, drawRange.start );
					const end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

					for ( let j = start, jl = end; j < jl; j += 3 ) {

						const a = index.getX( j );
						const b = index.getX( j + 1 );
						const c = index.getX( j + 2 );

						intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push( intersection );

						}

					}

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i += 3 ) {

					const a = index.getX( i );
					const b = index.getX( i + 1 );
					const c = index.getX( i + 2 );

					intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, uv, uv2, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
						intersects.push( intersection );

					}

				}

			}

		} else if ( position !== undefined ) {

			// non-indexed buffer geometry

			if ( Array.isArray( material ) ) {

				for ( let i = 0, il = groups.length; i < il; i ++ ) {

					const group = groups[ i ];
					const groupMaterial = material[ group.materialIndex ];

					const start = Math.max( group.start, drawRange.start );
					const end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

					for ( let j = start, jl = end; j < jl; j += 3 ) {

						const a = j;
						const b = j + 1;
						const c = j + 2;

						intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push( intersection );

						}

					}

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i += 3 ) {

					const a = i;
					const b = i + 1;
					const c = i + 2;

					intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, uv, uv2, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
						intersects.push( intersection );

					}

				}

			}

		}

	}

}

function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

	let intersect;

	if ( material.side === BackSide ) {

		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

	} else {

		intersect = ray.intersectTriangle( pA, pB, pC, ( material.side === FrontSide ), point );

	}

	if ( intersect === null ) return null;

	_intersectionPointWorld.copy( point );
	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

	const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

	if ( distance < raycaster.near || distance > raycaster.far ) return null;

	return {
		distance: distance,
		point: _intersectionPointWorld.clone(),
		object: object
	};

}

function checkBufferGeometryIntersection( object, material, raycaster, ray, uv, uv2, a, b, c ) {

	object.getVertexPosition( a, _vA$1 );
	object.getVertexPosition( b, _vB$1 );
	object.getVertexPosition( c, _vC$1 );

	const intersection = checkIntersection( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

	if ( intersection ) {

		if ( uv ) {

			_uvA$1.fromBufferAttribute( uv, a );
			_uvB$1.fromBufferAttribute( uv, b );
			_uvC$1.fromBufferAttribute( uv, c );

			intersection.uv = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

		}

		if ( uv2 ) {

			_uvA$1.fromBufferAttribute( uv2, a );
			_uvB$1.fromBufferAttribute( uv2, b );
			_uvC$1.fromBufferAttribute( uv2, c );

			intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

		}

		const face = {
			a: a,
			b: b,
			c: c,
			normal: new Vector3(),
			materialIndex: 0
		};

		Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

		intersection.face = face;

	}

	return intersection;

}

class MeshLambertMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshLambertMaterial = true;

		this.type = 'MeshLambertMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.flatShading = false;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
		revision: REVISION,
	} } ) );

}

if ( typeof window !== 'undefined' ) {

	if ( window.__THREE__ ) {

		console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

	} else {

		window.__THREE__ = REVISION;

	}

}

const nullIfcManagerErrorMessage = 'IfcManager is null!';
class IFCModel extends Mesh {
    constructor() {
        super(...arguments);
        this.modelID = IFCModel.modelIdCounter++;
        this.ifcManager = null;
        this.mesh = this;
    }
    static dispose() {
        IFCModel.modelIdCounter = 0;
    }
    setIFCManager(manager) {
        this.ifcManager = manager;
    }
    setWasmPath(path) {
        if (this.ifcManager === null)
            throw new Error(nullIfcManagerErrorMessage);
        this.ifcManager.setWasmPath(path);
    }
    close(scene) {
        if (this.ifcManager === null)
            throw new Error(nullIfcManagerErrorMessage);
        this.ifcManager.close(this.modelID, scene);
    }
    getExpressId(geometry, faceIndex) {
        if (this.ifcManager === null)
            throw new Error(nullIfcManagerErrorMessage);
        return this.ifcManager.getExpressId(geometry, faceIndex);
    }
    getAllItemsOfType(type, verbose) {
        if (this.ifcManager === null)
            throw new Error(nullIfcManagerErrorMessage);
        return this.ifcManager.getAllItemsOfType(this.modelID, type, verbose);
    }
    getItemProperties(id, recursive = false) {
        if (this.ifcManager === null)
            throw new Error(nullIfcManagerErrorMessage);
        return this.ifcManager.getItemProperties(this.modelID, id, recursive);
    }
    getPropertySets(id, recursive = false) {
        if (this.ifcManager === null)
            throw new Error(nullIfcManagerErrorMessage);
        return this.ifcManager.getPropertySets(this.modelID, id, recursive);
    }
    getTypeProperties(id, recursive = false) {
        if (this.ifcManager === null)
            throw new Error(nullIfcManagerErrorMessage);
        return this.ifcManager.getTypeProperties(this.modelID, id, recursive);
    }
    getIfcType(id) {
        if (this.ifcManager === null)
            throw new Error(nullIfcManagerErrorMessage);
        return this.ifcManager.getIfcType(this.modelID, id);
    }
    getSpatialStructure() {
        if (this.ifcManager === null)
            throw new Error(nullIfcManagerErrorMessage);
        return this.ifcManager.getSpatialStructure(this.modelID);
    }
    getSubset(material) {
        if (this.ifcManager === null)
            throw new Error(nullIfcManagerErrorMessage);
        return this.ifcManager.getSubset(this.modelID, material);
    }
    removeSubset(material, customID) {
        if (this.ifcManager === null)
            throw new Error(nullIfcManagerErrorMessage);
        this.ifcManager.removeSubset(this.modelID, material, customID);
    }
    createSubset(config) {
        if (this.ifcManager === null)
            throw new Error(nullIfcManagerErrorMessage);
        const modelConfig = { ...config, modelID: this.modelID };
        return this.ifcManager.createSubset(modelConfig);
    }
}
IFCModel.modelIdCounter = 0;

class SerializedMaterial {
    constructor(material) {
        this.color = [material.color.r, material.color.g, material.color.b];
        this.opacity = material.opacity;
        this.transparent = material.transparent;
    }
}
class MaterialReconstructor {
    static new(material) {
        return new MeshLambertMaterial({
            color: new Color(material.color[0], material.color[1], material.color[2]),
            opacity: material.opacity,
            transparent: material.transparent,
            side: DoubleSide
        });
    }
}

class SerializedGeometry {
    constructor(geometry) {
        var _a, _b, _c, _d;
        this.position = ((_a = geometry.attributes.position) === null || _a === void 0 ? void 0 : _a.array) || [];
        this.normal = ((_b = geometry.attributes.normal) === null || _b === void 0 ? void 0 : _b.array) || [];
        this.expressID = ((_c = geometry.attributes.expressID) === null || _c === void 0 ? void 0 : _c.array) || [];
        this.index = ((_d = geometry.index) === null || _d === void 0 ? void 0 : _d.array) || [];
        this.groups = geometry.groups;
    }
}
class GeometryReconstructor {
    static new(serialized) {
        const geom = new BufferGeometry();
        GeometryReconstructor.set(geom, 'expressID', new Uint32Array(serialized.expressID), 1);
        GeometryReconstructor.set(geom, 'position', new Float32Array(serialized.position), 3);
        GeometryReconstructor.set(geom, 'normal', new Float32Array(serialized.normal), 3);
        geom.setIndex(Array.from(serialized.index));
        geom.groups = serialized.groups;
        return geom;
    }
    static set(geom, name, data, size) {
        if (data.length > 0) {
            geom.setAttribute(name, new BufferAttribute(data, size));
        }
    }
}

class SerializedMesh {
    constructor(model) {
        this.materials = [];
        this.modelID = model.modelID;
        this.geometry = new SerializedGeometry(model.geometry);
        if (Array.isArray(model.material)) {
            model.material.forEach(mat => {
                this.materials.push(new SerializedMaterial(mat));
            });
        }
        else {
            this.materials.push(new SerializedMaterial(model.material));
        }
    }
}
class MeshReconstructor {
    static new(serialized) {
        const model = new IFCModel();
        model.modelID = serialized.modelID;
        model.geometry = GeometryReconstructor.new(serialized.geometry);
        MeshReconstructor.getMaterials(serialized, model);
        return model;
    }
    static getMaterials(serialized, model) {
        model.material = [];
        const mats = model.material;
        serialized.materials.forEach(mat => {
            mats.push(MaterialReconstructor.new(mat));
        });
    }
}

class Serializer {
    serializeVector(vector) {
        const size = vector.size();
        const serialized = { size };
        for (let i = 0; i < size; i++) {
            serialized[i] = vector.get(i);
        }
        return serialized;
    }
    reconstructVector(vector) {
        return new Vector(vector);
    }
    serializeIfcGeometry(geometry) {
        const GetVertexData = geometry.GetVertexData();
        const GetVertexDataSize = geometry.GetVertexDataSize();
        const GetIndexData = geometry.GetIndexData();
        const GetIndexDataSize = geometry.GetIndexDataSize();
        return {
            GetVertexData,
            GetVertexDataSize,
            GetIndexData,
            GetIndexDataSize
        };
    }
    reconstructIfcGeometry(geometry) {
        return new IfcGeometry(geometry);
    }
    serializeFlatMesh(flatMesh) {
        return {
            expressID: flatMesh.expressID,
            geometries: this.serializeVector(flatMesh.geometries)
        };
    }
    reconstructFlatMesh(flatMesh) {
        return new FlatMesh(this, flatMesh);
    }
    serializeFlatMeshVector(vector) {
        const size = vector.size();
        const serialized = { size };
        for (let i = 0; i < size; i++) {
            const flatMesh = vector.get(i);
            serialized[i] = this.serializeFlatMesh(flatMesh);
        }
        return serialized;
    }
    reconstructFlatMeshVector(vector) {
        return new FlatMeshVector(this, vector);
    }
    serializeIfcModel(model) {
        return new SerializedMesh(model);
    }
    reconstructIfcModel(model) {
        return MeshReconstructor.new(model);
    }
}

var WorkerActions;
(function (WorkerActions) {
    WorkerActions["updateStateUseJson"] = "updateStateUseJson";
    WorkerActions["updateStateWebIfcSettings"] = "updateStateWebIfcSettings";
    WorkerActions["updateModelStateTypes"] = "updateModelStateTypes";
    WorkerActions["updateModelStateJsonData"] = "updateModelStateJsonData";
    WorkerActions["loadJsonDataFromWorker"] = "loadJsonDataFromWorker";
    WorkerActions["dispose"] = "dispose";
    WorkerActions["Close"] = "Close";
    WorkerActions["DisposeWebIfc"] = "DisposeWebIfc";
    WorkerActions["Init"] = "Init";
    WorkerActions["OpenModel"] = "OpenModel";
    WorkerActions["CreateModel"] = "CreateModel";
    WorkerActions["ExportFileAsIFC"] = "ExportFileAsIFC";
    WorkerActions["GetGeometry"] = "GetGeometry";
    WorkerActions["GetLine"] = "GetLine";
    WorkerActions["GetAndClearErrors"] = "GetAndClearErrors";
    WorkerActions["WriteLine"] = "WriteLine";
    WorkerActions["FlattenLine"] = "FlattenLine";
    WorkerActions["GetRawLineData"] = "GetRawLineData";
    WorkerActions["WriteRawLineData"] = "WriteRawLineData";
    WorkerActions["GetLineIDsWithType"] = "GetLineIDsWithType";
    WorkerActions["GetAllLines"] = "GetAllLines";
    WorkerActions["SetGeometryTransformation"] = "SetGeometryTransformation";
    WorkerActions["GetCoordinationMatrix"] = "GetCoordinationMatrix";
    WorkerActions["GetVertexArray"] = "GetVertexArray";
    WorkerActions["GetIndexArray"] = "GetIndexArray";
    WorkerActions["getSubArray"] = "getSubArray";
    WorkerActions["CloseModel"] = "CloseModel";
    WorkerActions["StreamAllMeshes"] = "StreamAllMeshes";
    WorkerActions["StreamAllMeshesWithTypes"] = "StreamAllMeshesWithTypes";
    WorkerActions["IsModelOpen"] = "IsModelOpen";
    WorkerActions["LoadAllGeometry"] = "LoadAllGeometry";
    WorkerActions["GetFlatMesh"] = "GetFlatMesh";
    WorkerActions["SetWasmPath"] = "SetWasmPath";
    WorkerActions["parse"] = "parse";
    WorkerActions["setupOptionalCategories"] = "setupOptionalCategories";
    WorkerActions["getExpressId"] = "getExpressId";
    WorkerActions["initializeProperties"] = "initializeProperties";
    WorkerActions["getAllItemsOfType"] = "getAllItemsOfType";
    WorkerActions["getItemProperties"] = "getItemProperties";
    WorkerActions["getMaterialsProperties"] = "getMaterialsProperties";
    WorkerActions["getPropertySets"] = "getPropertySets";
    WorkerActions["getSpatialStructure"] = "getSpatialStructure";
    WorkerActions["getTypeProperties"] = "getTypeProperties";
})(WorkerActions || (WorkerActions = {}));
var WorkerAPIs;
(function (WorkerAPIs) {
    WorkerAPIs["workerState"] = "workerState";
    WorkerAPIs["webIfc"] = "webIfc";
    WorkerAPIs["properties"] = "properties";
    WorkerAPIs["parser"] = "parser";
})(WorkerAPIs || (WorkerAPIs = {}));
const ErrorRootStateNotAvailable = 'The root worker does not have any state';
const ErrorPropertiesNotAvailable = 'Error: Properties not available from web worker';
const ErrorParserNotAvailable = 'Error: Parser not available from web worker';
const ErrorBadJsonPath = 'Error: Model not available from web worker';
const ErrorBadJson = 'Error: The given Json could not be read as a JS object';

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __require = (x) => {
  if (typeof require !== "undefined")
    return require(x);
  throw new Error('Dynamic require of "' + x + '" is not supported');
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// (disabled):crypto
var require_crypto = __commonJS({
  "(disabled):crypto"() {
  }
});

// dist/web-ifc-mt.js
var require_web_ifc_mt = __commonJS({
  "dist/web-ifc-mt.js"(exports, module) {
    var WebIFCWasm2 = function() {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined")
        _scriptDir = _scriptDir || __filename;
      return function(WebIFCWasm3) {
        WebIFCWasm3 = WebIFCWasm3 || {};
        function GROWABLE_HEAP_I8() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAP8;
        }
        function GROWABLE_HEAP_U8() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAPU8;
        }
        function GROWABLE_HEAP_I16() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAP16;
        }
        function GROWABLE_HEAP_U16() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAPU16;
        }
        function GROWABLE_HEAP_I32() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAP32;
        }
        function GROWABLE_HEAP_U32() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAPU32;
        }
        function GROWABLE_HEAP_F32() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAPF32;
        }
        function GROWABLE_HEAP_F64() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAPF64;
        }
        var Module = typeof WebIFCWasm3 !== "undefined" ? WebIFCWasm3 : {};
        var readyPromiseResolve, readyPromiseReject;
        Module["ready"] = new Promise(function(resolve, reject) {
          readyPromiseResolve = resolve;
          readyPromiseReject = reject;
        });
        var moduleOverrides = {};
        var key;
        for (key in Module) {
          if (Module.hasOwnProperty(key)) {
            moduleOverrides[key] = Module[key];
          }
        }
        var thisProgram = "./this.program";
        var quit_ = function(status, toThrow) {
          throw toThrow;
        };
        var ENVIRONMENT_IS_WEB = typeof window === "object";
        var ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
        var ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
        var ENVIRONMENT_IS_PTHREAD = Module["ENVIRONMENT_IS_PTHREAD"] || false;
        var scriptDirectory = "";
        function locateFile(path) {
          if (Module["locateFile"]) {
            return Module["locateFile"](path, scriptDirectory);
          }
          return scriptDirectory + path;
        }
        var read_, readAsync, readBinary;
        var nodeFS;
        var nodePath;
        if (ENVIRONMENT_IS_NODE) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = __require("path").dirname(scriptDirectory) + "/";
          } else {
            scriptDirectory = __dirname + "/";
          }
          read_ = function shell_read(filename, binary) {
            if (!nodeFS)
              nodeFS = __require("fs");
            if (!nodePath)
              nodePath = __require("path");
            filename = nodePath["normalize"](filename);
            return nodeFS["readFileSync"](filename, binary ? null : "utf8");
          };
          readBinary = function readBinary2(filename) {
            var ret = read_(filename, true);
            if (!ret.buffer) {
              ret = new Uint8Array(ret);
            }
            assert(ret.buffer);
            return ret;
          };
          readAsync = function readAsync2(filename, onload, onerror) {
            if (!nodeFS)
              nodeFS = __require("fs");
            if (!nodePath)
              nodePath = __require("path");
            filename = nodePath["normalize"](filename);
            nodeFS["readFile"](filename, function(err2, data) {
              if (err2)
                onerror(err2);
              else
                onload(data.buffer);
            });
          };
          if (process["argv"].length > 1) {
            thisProgram = process["argv"][1].replace(/\\/g, "/");
          }
          process["argv"].slice(2);
          process["on"]("uncaughtException", function(ex) {
            if (!(ex instanceof ExitStatus)) {
              throw ex;
            }
          });
          process["on"]("unhandledRejection", abort);
          quit_ = function(status, toThrow) {
            if (keepRuntimeAlive()) {
              process["exitCode"] = status;
              throw toThrow;
            }
            process["exit"](status);
          };
          Module["inspect"] = function() {
            return "[Emscripten Module object]";
          };
          var nodeWorkerThreads;
          try {
            nodeWorkerThreads = __require("worker_threads");
          } catch (e) {
            console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?');
            throw e;
          }
          global.Worker = nodeWorkerThreads.Worker;
        } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = self.location.href;
          } else if (typeof document !== "undefined" && document.currentScript) {
            scriptDirectory = document.currentScript.src;
          }
          if (_scriptDir) {
            scriptDirectory = _scriptDir;
          }
          if (scriptDirectory.indexOf("blob:") !== 0) {
            scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
          } else {
            scriptDirectory = "";
          }
          if (ENVIRONMENT_IS_NODE) {
            read_ = function shell_read(filename, binary) {
              if (!nodeFS)
                nodeFS = __require("fs");
              if (!nodePath)
                nodePath = __require("path");
              filename = nodePath["normalize"](filename);
              return nodeFS["readFileSync"](filename, binary ? null : "utf8");
            };
            readBinary = function readBinary2(filename) {
              var ret = read_(filename, true);
              if (!ret.buffer) {
                ret = new Uint8Array(ret);
              }
              assert(ret.buffer);
              return ret;
            };
            readAsync = function readAsync2(filename, onload, onerror) {
              if (!nodeFS)
                nodeFS = __require("fs");
              if (!nodePath)
                nodePath = __require("path");
              filename = nodePath["normalize"](filename);
              nodeFS["readFile"](filename, function(err2, data) {
                if (err2)
                  onerror(err2);
                else
                  onload(data.buffer);
              });
            };
          } else {
            read_ = function(url) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.send(null);
              return xhr.responseText;
            };
            if (ENVIRONMENT_IS_WORKER) {
              readBinary = function(url) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                return new Uint8Array(xhr.response);
              };
            }
            readAsync = function(url, onload, onerror) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, true);
              xhr.responseType = "arraybuffer";
              xhr.onload = function() {
                if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                  onload(xhr.response);
                  return;
                }
                onerror();
              };
              xhr.onerror = onerror;
              xhr.send(null);
            };
          }
        } else ;
        if (ENVIRONMENT_IS_NODE) {
          if (typeof performance === "undefined") {
            global.performance = __require("perf_hooks").performance;
          }
        }
        var out = Module["print"] || console.log.bind(console);
        var err = Module["printErr"] || console.warn.bind(console);
        for (key in moduleOverrides) {
          if (moduleOverrides.hasOwnProperty(key)) {
            Module[key] = moduleOverrides[key];
          }
        }
        moduleOverrides = null;
        if (Module["arguments"])
          Module["arguments"];
        if (Module["thisProgram"])
          thisProgram = Module["thisProgram"];
        if (Module["quit"])
          quit_ = Module["quit"];
        var STACK_ALIGN = 16;
        function alignMemory(size, factor) {
          if (!factor)
            factor = STACK_ALIGN;
          return Math.ceil(size / factor) * factor;
        }
        function warnOnce(text) {
          if (!warnOnce.shown)
            warnOnce.shown = {};
          if (!warnOnce.shown[text]) {
            warnOnce.shown[text] = 1;
            err(text);
          }
        }
        var tempRet0 = 0;
        var setTempRet0 = function(value) {
          tempRet0 = value;
        };
        var getTempRet0 = function() {
          return tempRet0;
        };
        var wasmBinary;
        if (Module["wasmBinary"])
          wasmBinary = Module["wasmBinary"];
        var noExitRuntime = Module["noExitRuntime"] || true;
        if (typeof WebAssembly !== "object") {
          abort("no native wasm support detected");
        }
        var wasmMemory;
        var wasmModule;
        var ABORT = false;
        function assert(condition, text) {
          if (!condition) {
            abort("Assertion failed: " + text);
          }
        }
        function TextDecoderWrapper(encoding) {
          var textDecoder = new TextDecoder(encoding);
          this.decode = function(data) {
            if (data.buffer instanceof SharedArrayBuffer) {
              data = new Uint8Array(data);
            }
            return textDecoder.decode.call(textDecoder, data);
          };
        }
        var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoderWrapper("utf8") : void 0;
        function UTF8ArrayToString(heap, idx, maxBytesToRead) {
          idx >>>= 0;
          var endIdx = idx + maxBytesToRead;
          var endPtr = idx;
          while (heap[endPtr >>> 0] && !(endPtr >= endIdx))
            ++endPtr;
          if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
            return UTF8Decoder.decode(heap.subarray(idx >>> 0, endPtr >>> 0));
          } else {
            var str = "";
            while (idx < endPtr) {
              var u0 = heap[idx++ >>> 0];
              if (!(u0 & 128)) {
                str += String.fromCharCode(u0);
                continue;
              }
              var u1 = heap[idx++ >>> 0] & 63;
              if ((u0 & 224) == 192) {
                str += String.fromCharCode((u0 & 31) << 6 | u1);
                continue;
              }
              var u2 = heap[idx++ >>> 0] & 63;
              if ((u0 & 240) == 224) {
                u0 = (u0 & 15) << 12 | u1 << 6 | u2;
              } else {
                u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++ >>> 0] & 63;
              }
              if (u0 < 65536) {
                str += String.fromCharCode(u0);
              } else {
                var ch = u0 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
              }
            }
          }
          return str;
        }
        function UTF8ToString(ptr, maxBytesToRead) {
          ptr >>>= 0;
          return ptr ? UTF8ArrayToString(GROWABLE_HEAP_U8(), ptr, maxBytesToRead) : "";
        }
        function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
          outIdx >>>= 0;
          if (!(maxBytesToWrite > 0))
            return 0;
          var startIdx = outIdx;
          var endIdx = outIdx + maxBytesToWrite - 1;
          for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343) {
              var u1 = str.charCodeAt(++i);
              u = 65536 + ((u & 1023) << 10) | u1 & 1023;
            }
            if (u <= 127) {
              if (outIdx >= endIdx)
                break;
              heap[outIdx++ >>> 0] = u;
            } else if (u <= 2047) {
              if (outIdx + 1 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 192 | u >> 6;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            } else if (u <= 65535) {
              if (outIdx + 2 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 224 | u >> 12;
              heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            } else {
              if (outIdx + 3 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 240 | u >> 18;
              heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;
              heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            }
          }
          heap[outIdx >>> 0] = 0;
          return outIdx - startIdx;
        }
        function stringToUTF8(str, outPtr, maxBytesToWrite) {
          return stringToUTF8Array(str, GROWABLE_HEAP_U8(), outPtr, maxBytesToWrite);
        }
        function lengthBytesUTF8(str) {
          var len = 0;
          for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343)
              u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
            if (u <= 127)
              ++len;
            else if (u <= 2047)
              len += 2;
            else if (u <= 65535)
              len += 3;
            else
              len += 4;
          }
          return len;
        }
        var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoderWrapper("utf-16le") : void 0;
        function UTF16ToString(ptr, maxBytesToRead) {
          var endPtr = ptr;
          var idx = endPtr >> 1;
          var maxIdx = idx + maxBytesToRead / 2;
          while (!(idx >= maxIdx) && GROWABLE_HEAP_U16()[idx >>> 0])
            ++idx;
          endPtr = idx << 1;
          if (endPtr - ptr > 32 && UTF16Decoder) {
            return UTF16Decoder.decode(GROWABLE_HEAP_U8().subarray(ptr >>> 0, endPtr >>> 0));
          } else {
            var str = "";
            for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
              var codeUnit = GROWABLE_HEAP_I16()[ptr + i * 2 >>> 1];
              if (codeUnit == 0)
                break;
              str += String.fromCharCode(codeUnit);
            }
            return str;
          }
        }
        function stringToUTF16(str, outPtr, maxBytesToWrite) {
          if (maxBytesToWrite === void 0) {
            maxBytesToWrite = 2147483647;
          }
          if (maxBytesToWrite < 2)
            return 0;
          maxBytesToWrite -= 2;
          var startPtr = outPtr;
          var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
          for (var i = 0; i < numCharsToWrite; ++i) {
            var codeUnit = str.charCodeAt(i);
            GROWABLE_HEAP_I16()[outPtr >>> 1] = codeUnit;
            outPtr += 2;
          }
          GROWABLE_HEAP_I16()[outPtr >>> 1] = 0;
          return outPtr - startPtr;
        }
        function lengthBytesUTF16(str) {
          return str.length * 2;
        }
        function UTF32ToString(ptr, maxBytesToRead) {
          var i = 0;
          var str = "";
          while (!(i >= maxBytesToRead / 4)) {
            var utf32 = GROWABLE_HEAP_I32()[ptr + i * 4 >>> 2];
            if (utf32 == 0)
              break;
            ++i;
            if (utf32 >= 65536) {
              var ch = utf32 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            } else {
              str += String.fromCharCode(utf32);
            }
          }
          return str;
        }
        function stringToUTF32(str, outPtr, maxBytesToWrite) {
          outPtr >>>= 0;
          if (maxBytesToWrite === void 0) {
            maxBytesToWrite = 2147483647;
          }
          if (maxBytesToWrite < 4)
            return 0;
          var startPtr = outPtr;
          var endPtr = startPtr + maxBytesToWrite - 4;
          for (var i = 0; i < str.length; ++i) {
            var codeUnit = str.charCodeAt(i);
            if (codeUnit >= 55296 && codeUnit <= 57343) {
              var trailSurrogate = str.charCodeAt(++i);
              codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
            }
            GROWABLE_HEAP_I32()[outPtr >>> 2] = codeUnit;
            outPtr += 4;
            if (outPtr + 4 > endPtr)
              break;
          }
          GROWABLE_HEAP_I32()[outPtr >>> 2] = 0;
          return outPtr - startPtr;
        }
        function lengthBytesUTF32(str) {
          var len = 0;
          for (var i = 0; i < str.length; ++i) {
            var codeUnit = str.charCodeAt(i);
            if (codeUnit >= 55296 && codeUnit <= 57343)
              ++i;
            len += 4;
          }
          return len;
        }
        function writeArrayToMemory(array, buffer2) {
          GROWABLE_HEAP_I8().set(array, buffer2 >>> 0);
        }
        function writeAsciiToMemory(str, buffer2, dontAddNull) {
          for (var i = 0; i < str.length; ++i) {
            GROWABLE_HEAP_I8()[buffer2++ >>> 0] = str.charCodeAt(i);
          }
          if (!dontAddNull)
            GROWABLE_HEAP_I8()[buffer2 >>> 0] = 0;
        }
        function alignUp(x, multiple) {
          if (x % multiple > 0) {
            x += multiple - x % multiple;
          }
          return x;
        }
        var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
        if (ENVIRONMENT_IS_PTHREAD) {
          buffer = Module["buffer"];
        }
        function updateGlobalBufferAndViews(buf) {
          buffer = buf;
          Module["HEAP8"] = HEAP8 = new Int8Array(buf);
          Module["HEAP16"] = HEAP16 = new Int16Array(buf);
          Module["HEAP32"] = HEAP32 = new Int32Array(buf);
          Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
          Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
          Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
          Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
          Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
        }
        var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
        if (ENVIRONMENT_IS_PTHREAD) {
          wasmMemory = Module["wasmMemory"];
          buffer = Module["buffer"];
        } else {
          if (Module["wasmMemory"]) {
            wasmMemory = Module["wasmMemory"];
          } else {
            wasmMemory = new WebAssembly.Memory({ "initial": INITIAL_MEMORY / 65536, "maximum": 4294967296 / 65536, "shared": true });
            if (!(wasmMemory.buffer instanceof SharedArrayBuffer)) {
              err("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag");
              if (ENVIRONMENT_IS_NODE) {
                console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)");
              }
              throw Error("bad memory");
            }
          }
        }
        if (wasmMemory) {
          buffer = wasmMemory.buffer;
        }
        INITIAL_MEMORY = buffer.byteLength;
        updateGlobalBufferAndViews(buffer);
        var wasmTable;
        var __ATPRERUN__ = [];
        var __ATINIT__ = [];
        var __ATMAIN__ = [];
        var __ATPOSTRUN__ = [];
        var runtimeKeepaliveCounter = 0;
        function keepRuntimeAlive() {
          return noExitRuntime || runtimeKeepaliveCounter > 0;
        }
        function preRun() {
          if (ENVIRONMENT_IS_PTHREAD)
            return;
          if (Module["preRun"]) {
            if (typeof Module["preRun"] == "function")
              Module["preRun"] = [Module["preRun"]];
            while (Module["preRun"].length) {
              addOnPreRun(Module["preRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPRERUN__);
        }
        function initRuntime() {
          if (ENVIRONMENT_IS_PTHREAD)
            return;
          if (!Module["noFSInit"] && !FS.init.initialized)
            FS.init();
          FS.ignorePermissions = false;
          callRuntimeCallbacks(__ATINIT__);
        }
        function preMain() {
          if (ENVIRONMENT_IS_PTHREAD)
            return;
          callRuntimeCallbacks(__ATMAIN__);
        }
        function postRun() {
          if (ENVIRONMENT_IS_PTHREAD)
            return;
          if (Module["postRun"]) {
            if (typeof Module["postRun"] == "function")
              Module["postRun"] = [Module["postRun"]];
            while (Module["postRun"].length) {
              addOnPostRun(Module["postRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPOSTRUN__);
        }
        function addOnPreRun(cb) {
          __ATPRERUN__.unshift(cb);
        }
        function addOnInit(cb) {
          __ATINIT__.unshift(cb);
        }
        function addOnPostRun(cb) {
          __ATPOSTRUN__.unshift(cb);
        }
        var runDependencies = 0;
        var dependenciesFulfilled = null;
        function getUniqueRunDependency(id) {
          return id;
        }
        function addRunDependency(id) {
          runDependencies++;
          if (Module["monitorRunDependencies"]) {
            Module["monitorRunDependencies"](runDependencies);
          }
        }
        function removeRunDependency(id) {
          runDependencies--;
          if (Module["monitorRunDependencies"]) {
            Module["monitorRunDependencies"](runDependencies);
          }
          if (runDependencies == 0) {
            if (dependenciesFulfilled) {
              var callback = dependenciesFulfilled;
              dependenciesFulfilled = null;
              callback();
            }
          }
        }
        Module["preloadedImages"] = {};
        Module["preloadedAudios"] = {};
        function abort(what) {
          if (Module["onAbort"]) {
            Module["onAbort"](what);
          }
          if (ENVIRONMENT_IS_PTHREAD)
            console.error("Pthread aborting at " + new Error().stack);
          what += "";
          err(what);
          ABORT = true;
          what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
          var e = new WebAssembly.RuntimeError(what);
          readyPromiseReject(e);
          throw e;
        }
        var dataURIPrefix = "data:application/octet-stream;base64,";
        function isDataURI(filename) {
          return filename.startsWith(dataURIPrefix);
        }
        function isFileURI(filename) {
          return filename.startsWith("file://");
        }
        var wasmBinaryFile;
        wasmBinaryFile = "web-ifc-mt.wasm";
        if (!isDataURI(wasmBinaryFile)) {
          wasmBinaryFile = locateFile(wasmBinaryFile);
        }
        function getBinary(file) {
          try {
            if (file == wasmBinaryFile && wasmBinary) {
              return new Uint8Array(wasmBinary);
            }
            if (readBinary) {
              return readBinary(file);
            } else {
              throw "both async and sync fetching of the wasm failed";
            }
          } catch (err2) {
            abort(err2);
          }
        }
        function getBinaryPromise() {
          if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
            if (typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
              return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                if (!response["ok"]) {
                  throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                }
                return response["arrayBuffer"]();
              }).catch(function() {
                return getBinary(wasmBinaryFile);
              });
            } else {
              if (readAsync) {
                return new Promise(function(resolve, reject) {
                  readAsync(wasmBinaryFile, function(response) {
                    resolve(new Uint8Array(response));
                  }, reject);
                });
              }
            }
          }
          return Promise.resolve().then(function() {
            return getBinary(wasmBinaryFile);
          });
        }
        function createWasm() {
          var info = { "a": asmLibraryArg };
          function receiveInstance(instance, module2) {
            var exports3 = instance.exports;
            Module["asm"] = exports3;
            wasmTable = Module["asm"]["db"];
            addOnInit(Module["asm"]["ab"]);
            PThread.tlsInitFunctions.push(Module["asm"]["fb"]);
            wasmModule = module2;
            if (!ENVIRONMENT_IS_PTHREAD) {
              var numWorkersToLoad = PThread.unusedWorkers.length;
              PThread.unusedWorkers.forEach(function(w) {
                PThread.loadWasmModuleToWorker(w, function() {
                  if (!--numWorkersToLoad)
                    removeRunDependency();
                });
              });
            }
          }
          if (!ENVIRONMENT_IS_PTHREAD) {
            addRunDependency();
          }
          function receiveInstantiationResult(result) {
            receiveInstance(result["instance"], result["module"]);
          }
          function instantiateArrayBuffer(receiver) {
            return getBinaryPromise().then(function(binary) {
              var result = WebAssembly.instantiate(binary, info);
              return result;
            }).then(receiver, function(reason) {
              err("failed to asynchronously prepare wasm: " + reason);
              abort(reason);
            });
          }
          function instantiateAsync() {
            if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
              return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                var result = WebAssembly.instantiateStreaming(response, info);
                return result.then(receiveInstantiationResult, function(reason) {
                  err("wasm streaming compile failed: " + reason);
                  err("falling back to ArrayBuffer instantiation");
                  return instantiateArrayBuffer(receiveInstantiationResult);
                });
              });
            } else {
              return instantiateArrayBuffer(receiveInstantiationResult);
            }
          }
          if (Module["instantiateWasm"]) {
            try {
              var exports2 = Module["instantiateWasm"](info, receiveInstance);
              return exports2;
            } catch (e) {
              err("Module.instantiateWasm callback failed with error: " + e);
              return false;
            }
          }
          instantiateAsync().catch(readyPromiseReject);
          return {};
        }
        var tempDouble;
        var tempI64;
        var ASM_CONSTS = { 56684: function() {
          throw "Canceled!";
        }, 56702: function($0, $1) {
          setTimeout(function() {
            __emscripten_do_dispatch_to_thread($0, $1);
          }, 0);
        } };
        function initPthreadsJS() {
          PThread.initRuntime();
        }
        function callRuntimeCallbacks(callbacks) {
          while (callbacks.length > 0) {
            var callback = callbacks.shift();
            if (typeof callback == "function") {
              callback(Module);
              continue;
            }
            var func = callback.func;
            if (typeof func === "number") {
              if (callback.arg === void 0) {
                wasmTable.get(func)();
              } else {
                wasmTable.get(func)(callback.arg);
              }
            } else {
              func(callback.arg === void 0 ? null : callback.arg);
            }
          }
        }
        function _emscripten_futex_wake(addr, count) {
          if (addr <= 0 || addr > GROWABLE_HEAP_I8().length || addr & true || count < 0)
            return -28;
          if (count == 0)
            return 0;
          if (count >= 2147483647)
            count = Infinity;
          var mainThreadWaitAddress = Atomics.load(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2);
          var mainThreadWoken = 0;
          if (mainThreadWaitAddress == addr) {
            var loadedAddr = Atomics.compareExchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, mainThreadWaitAddress, 0);
            if (loadedAddr == mainThreadWaitAddress) {
              --count;
              mainThreadWoken = 1;
              if (count <= 0)
                return 1;
            }
          }
          var ret = Atomics.notify(GROWABLE_HEAP_I32(), addr >> 2, count);
          if (ret >= 0)
            return ret + mainThreadWoken;
          throw "Atomics.notify returned an unexpected value " + ret;
        }
        Module["_emscripten_futex_wake"] = _emscripten_futex_wake;
        function killThread(pthread_ptr) {
          if (ENVIRONMENT_IS_PTHREAD)
            throw "Internal Error! killThread() can only ever be called from main application thread!";
          if (!pthread_ptr)
            throw "Internal Error! Null pthread_ptr in killThread!";
          GROWABLE_HEAP_I32()[pthread_ptr + 12 >>> 2] = 0;
          var pthread = PThread.pthreads[pthread_ptr];
          pthread.worker.terminate();
          PThread.freeThreadData(pthread);
          PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(pthread.worker), 1);
          pthread.worker.pthread = void 0;
        }
        function cancelThread(pthread_ptr) {
          if (ENVIRONMENT_IS_PTHREAD)
            throw "Internal Error! cancelThread() can only ever be called from main application thread!";
          if (!pthread_ptr)
            throw "Internal Error! Null pthread_ptr in cancelThread!";
          var pthread = PThread.pthreads[pthread_ptr];
          pthread.worker.postMessage({ "cmd": "cancel" });
        }
        function cleanupThread(pthread_ptr) {
          if (ENVIRONMENT_IS_PTHREAD)
            throw "Internal Error! cleanupThread() can only ever be called from main application thread!";
          if (!pthread_ptr)
            throw "Internal Error! Null pthread_ptr in cleanupThread!";
          var pthread = PThread.pthreads[pthread_ptr];
          if (pthread) {
            GROWABLE_HEAP_I32()[pthread_ptr + 12 >>> 2] = 0;
            var worker = pthread.worker;
            PThread.returnWorkerToPool(worker);
          }
        }
        var PThread = { unusedWorkers: [], runningWorkers: [], tlsInitFunctions: [], initMainThreadBlock: function() {
          var pthreadPoolSize = navigator.hardwareConcurrency;
          for (var i = 0; i < pthreadPoolSize; ++i) {
            PThread.allocateUnusedWorker();
          }
        }, initRuntime: function() {
          var tb = _malloc(228);
          for (var i = 0; i < 228 / 4; ++i)
            GROWABLE_HEAP_U32()[tb / 4 + i >>> 0] = 0;
          GROWABLE_HEAP_I32()[tb + 12 >>> 2] = tb;
          var headPtr = tb + 152;
          GROWABLE_HEAP_I32()[headPtr >>> 2] = headPtr;
          var tlsMemory = _malloc(512);
          for (var i = 0; i < 128; ++i)
            GROWABLE_HEAP_U32()[tlsMemory / 4 + i >>> 0] = 0;
          Atomics.store(GROWABLE_HEAP_U32(), tb + 100 >> 2, tlsMemory);
          Atomics.store(GROWABLE_HEAP_U32(), tb + 40 >> 2, tb);
          __emscripten_thread_init(tb, !ENVIRONMENT_IS_WORKER, 1);
          _emscripten_register_main_browser_thread_id(tb);
        }, initWorker: function() {
        }, pthreads: {}, threadExitHandlers: [], runExitHandlers: function() {
          while (PThread.threadExitHandlers.length > 0) {
            PThread.threadExitHandlers.pop()();
          }
          ___pthread_tsd_run_dtors();
        }, runExitHandlersAndDeinitThread: function(tb, exitCode) {
          Atomics.store(GROWABLE_HEAP_U32(), tb + 56 >> 2, 1);
          Atomics.store(GROWABLE_HEAP_U32(), tb + 60 >> 2, 0);
          PThread.runExitHandlers();
          Atomics.store(GROWABLE_HEAP_U32(), tb + 4 >> 2, exitCode);
          Atomics.store(GROWABLE_HEAP_U32(), tb + 0 >> 2, 1);
          _emscripten_futex_wake(tb + 0, 2147483647);
          __emscripten_thread_init(0, 0, 0);
        }, setExitStatus: function(status) {
        }, threadExit: function(exitCode) {
          var tb = _pthread_self();
          if (tb) {
            PThread.runExitHandlersAndDeinitThread(tb, exitCode);
            if (ENVIRONMENT_IS_PTHREAD) {
              postMessage({ "cmd": "exit" });
            }
          }
        }, threadCancel: function() {
          PThread.runExitHandlersAndDeinitThread(_pthread_self(), -1);
          postMessage({ "cmd": "cancelDone" });
        }, terminateAllThreads: function() {
          for (var t in PThread.pthreads) {
            var pthread = PThread.pthreads[t];
            if (pthread && pthread.worker) {
              PThread.returnWorkerToPool(pthread.worker);
            }
          }
          PThread.pthreads = {};
          for (var i = 0; i < PThread.unusedWorkers.length; ++i) {
            var worker = PThread.unusedWorkers[i];
            worker.terminate();
          }
          PThread.unusedWorkers = [];
          for (var i = 0; i < PThread.runningWorkers.length; ++i) {
            var worker = PThread.runningWorkers[i];
            var pthread = worker.pthread;
            PThread.freeThreadData(pthread);
            worker.terminate();
          }
          PThread.runningWorkers = [];
        }, freeThreadData: function(pthread) {
          if (!pthread)
            return;
          if (pthread.threadInfoStruct) {
            var tlsMemory = GROWABLE_HEAP_I32()[pthread.threadInfoStruct + 100 >>> 2];
            GROWABLE_HEAP_I32()[pthread.threadInfoStruct + 100 >>> 2] = 0;
            _free(tlsMemory);
            _free(pthread.threadInfoStruct);
          }
          pthread.threadInfoStruct = 0;
          if (pthread.allocatedOwnStack && pthread.stackBase)
            _free(pthread.stackBase);
          pthread.stackBase = 0;
          if (pthread.worker)
            pthread.worker.pthread = null;
        }, returnWorkerToPool: function(worker) {
          PThread.runWithoutMainThreadQueuedCalls(function() {
            delete PThread.pthreads[worker.pthread.threadInfoStruct];
            PThread.unusedWorkers.push(worker);
            PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker), 1);
            PThread.freeThreadData(worker.pthread);
            worker.pthread = void 0;
          });
        }, runWithoutMainThreadQueuedCalls: function(func) {
          GROWABLE_HEAP_I32()[__emscripten_allow_main_runtime_queued_calls >>> 2] = 0;
          try {
            func();
          } finally {
            GROWABLE_HEAP_I32()[__emscripten_allow_main_runtime_queued_calls >>> 2] = 1;
          }
        }, receiveObjectTransfer: function(data) {
        }, threadInit: function() {
          for (var i in PThread.tlsInitFunctions) {
            PThread.tlsInitFunctions[i]();
          }
        }, loadWasmModuleToWorker: function(worker, onFinishedLoading) {
          worker.onmessage = function(e) {
            var d = e["data"];
            var cmd = d["cmd"];
            if (worker.pthread)
              PThread.currentProxiedOperationCallerThread = worker.pthread.threadInfoStruct;
            if (d["targetThread"] && d["targetThread"] != _pthread_self()) {
              var thread = PThread.pthreads[d.targetThread];
              if (thread) {
                thread.worker.postMessage(e.data, d["transferList"]);
              } else {
                console.error('Internal error! Worker sent a message "' + cmd + '" to target pthread ' + d["targetThread"] + ", but that thread no longer exists!");
              }
              PThread.currentProxiedOperationCallerThread = void 0;
              return;
            }
            if (cmd === "processQueuedMainThreadWork") {
              _emscripten_main_thread_process_queued_calls();
            } else if (cmd === "spawnThread") {
              spawnThread(e.data);
            } else if (cmd === "cleanupThread") {
              cleanupThread(d["thread"]);
            } else if (cmd === "killThread") {
              killThread(d["thread"]);
            } else if (cmd === "cancelThread") {
              cancelThread(d["thread"]);
            } else if (cmd === "loaded") {
              worker.loaded = true;
              if (onFinishedLoading)
                onFinishedLoading(worker);
              if (worker.runPthread) {
                worker.runPthread();
                delete worker.runPthread;
              }
            } else if (cmd === "print") {
              out("Thread " + d["threadId"] + ": " + d["text"]);
            } else if (cmd === "printErr") {
              err("Thread " + d["threadId"] + ": " + d["text"]);
            } else if (cmd === "alert") {
              alert("Thread " + d["threadId"] + ": " + d["text"]);
            } else if (cmd === "exit") {
              var detached = worker.pthread && Atomics.load(GROWABLE_HEAP_U32(), worker.pthread.threadInfoStruct + 64 >> 2);
              if (detached) {
                PThread.returnWorkerToPool(worker);
              }
            } else if (cmd === "exitProcess") {
              try {
                exit(d["returnCode"]);
              } catch (e2) {
                if (e2 instanceof ExitStatus)
                  return;
                throw e2;
              }
            } else if (cmd === "cancelDone") {
              PThread.returnWorkerToPool(worker);
            } else if (cmd === "objectTransfer") {
              PThread.receiveObjectTransfer(e.data);
            } else if (e.data.target === "setimmediate") {
              worker.postMessage(e.data);
            } else {
              err("worker sent an unknown command " + cmd);
            }
            PThread.currentProxiedOperationCallerThread = void 0;
          };
          worker.onerror = function(e) {
            err("pthread sent an error! " + e.filename + ":" + e.lineno + ": " + e.message);
          };
          if (ENVIRONMENT_IS_NODE) {
            worker.on("message", function(data) {
              worker.onmessage({ data });
            });
            worker.on("error", function(data) {
              worker.onerror(data);
            });
            worker.on("exit", function(data) {
            });
          }
          worker.postMessage({ "cmd": "load", "urlOrBlob": Module["mainScriptUrlOrBlob"] || _scriptDir, "wasmMemory": wasmMemory, "wasmModule": wasmModule });
        }, allocateUnusedWorker: function() {
          var pthreadMainJs = locateFile("web-ifc-mt.worker.js");
          PThread.unusedWorkers.push(new Worker(pthreadMainJs));
        }, getNewWorker: function() {
          if (PThread.unusedWorkers.length == 0) {
            PThread.allocateUnusedWorker();
            PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0]);
          }
          return PThread.unusedWorkers.pop();
        }, busySpinWait: function(msecs) {
          var t = performance.now() + msecs;
          while (performance.now() < t) {
          }
        } };
        function establishStackSpace(stackTop, stackMax) {
          _emscripten_stack_set_limits(stackTop, stackMax);
          stackRestore(stackTop);
        }
        Module["establishStackSpace"] = establishStackSpace;
        function invokeEntryPoint(ptr, arg) {
          return wasmTable.get(ptr)(arg);
        }
        Module["invokeEntryPoint"] = invokeEntryPoint;
        function ___assert_fail(condition, filename, line, func) {
          abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
        }
        var _emscripten_get_now;
        if (ENVIRONMENT_IS_NODE) {
          _emscripten_get_now = function() {
            var t = process["hrtime"]();
            return t[0] * 1e3 + t[1] / 1e6;
          };
        } else if (ENVIRONMENT_IS_PTHREAD) {
          _emscripten_get_now = function() {
            return performance.now() - Module["__performance_now_clock_drift"];
          };
        } else
          _emscripten_get_now = function() {
            return performance.now();
          };
        var _emscripten_get_now_is_monotonic = true;
        function setErrNo(value) {
          GROWABLE_HEAP_I32()[___errno_location() >>> 2] = value;
          return value;
        }
        function _clock_gettime(clk_id, tp) {
          var now;
          if (clk_id === 0) {
            now = Date.now();
          } else if ((clk_id === 1 || clk_id === 4) && _emscripten_get_now_is_monotonic) {
            now = _emscripten_get_now();
          } else {
            setErrNo(28);
            return -1;
          }
          GROWABLE_HEAP_I32()[tp >>> 2] = now / 1e3 | 0;
          GROWABLE_HEAP_I32()[tp + 4 >>> 2] = now % 1e3 * 1e3 * 1e3 | 0;
          return 0;
        }
        function ___cxa_allocate_exception(size) {
          return _malloc(size + 16) + 16;
        }
        function _atexit(func, arg) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(1, 1, func, arg);
        }
        function ExceptionInfo(excPtr) {
          this.excPtr = excPtr;
          this.ptr = excPtr - 16;
          this.set_type = function(type) {
            GROWABLE_HEAP_I32()[this.ptr + 4 >>> 2] = type;
          };
          this.get_type = function() {
            return GROWABLE_HEAP_I32()[this.ptr + 4 >>> 2];
          };
          this.set_destructor = function(destructor) {
            GROWABLE_HEAP_I32()[this.ptr + 8 >>> 2] = destructor;
          };
          this.get_destructor = function() {
            return GROWABLE_HEAP_I32()[this.ptr + 8 >>> 2];
          };
          this.set_refcount = function(refcount) {
            GROWABLE_HEAP_I32()[this.ptr >>> 2] = refcount;
          };
          this.set_caught = function(caught) {
            caught = caught ? 1 : 0;
            GROWABLE_HEAP_I8()[this.ptr + 12 >>> 0] = caught;
          };
          this.get_caught = function() {
            return GROWABLE_HEAP_I8()[this.ptr + 12 >>> 0] != 0;
          };
          this.set_rethrown = function(rethrown) {
            rethrown = rethrown ? 1 : 0;
            GROWABLE_HEAP_I8()[this.ptr + 13 >>> 0] = rethrown;
          };
          this.get_rethrown = function() {
            return GROWABLE_HEAP_I8()[this.ptr + 13 >>> 0] != 0;
          };
          this.init = function(type, destructor) {
            this.set_type(type);
            this.set_destructor(destructor);
            this.set_refcount(0);
            this.set_caught(false);
            this.set_rethrown(false);
          };
          this.add_ref = function() {
            Atomics.add(GROWABLE_HEAP_I32(), this.ptr + 0 >> 2, 1);
          };
          this.release_ref = function() {
            var prev = Atomics.sub(GROWABLE_HEAP_I32(), this.ptr + 0 >> 2, 1);
            return prev === 1;
          };
        }
        function CatchInfo(ptr) {
          this.free = function() {
            _free(this.ptr);
            this.ptr = 0;
          };
          this.set_base_ptr = function(basePtr) {
            GROWABLE_HEAP_I32()[this.ptr >>> 2] = basePtr;
          };
          this.get_base_ptr = function() {
            return GROWABLE_HEAP_I32()[this.ptr >>> 2];
          };
          this.set_adjusted_ptr = function(adjustedPtr) {
            GROWABLE_HEAP_I32()[this.ptr + 4 >>> 2] = adjustedPtr;
          };
          this.get_adjusted_ptr_addr = function() {
            return this.ptr + 4;
          };
          this.get_adjusted_ptr = function() {
            return GROWABLE_HEAP_I32()[this.ptr + 4 >>> 2];
          };
          this.get_exception_ptr = function() {
            var isPointer = ___cxa_is_pointer_type(this.get_exception_info().get_type());
            if (isPointer) {
              return GROWABLE_HEAP_I32()[this.get_base_ptr() >>> 2];
            }
            var adjusted = this.get_adjusted_ptr();
            if (adjusted !== 0)
              return adjusted;
            return this.get_base_ptr();
          };
          this.get_exception_info = function() {
            return new ExceptionInfo(this.get_base_ptr());
          };
          if (ptr === void 0) {
            this.ptr = _malloc(8);
            this.set_adjusted_ptr(0);
          } else {
            this.ptr = ptr;
          }
        }
        var exceptionCaught = [];
        function exception_addRef(info) {
          info.add_ref();
        }
        var uncaughtExceptionCount = 0;
        function ___cxa_begin_catch(ptr) {
          var catchInfo = new CatchInfo(ptr);
          var info = catchInfo.get_exception_info();
          if (!info.get_caught()) {
            info.set_caught(true);
            uncaughtExceptionCount--;
          }
          info.set_rethrown(false);
          exceptionCaught.push(catchInfo);
          exception_addRef(info);
          return catchInfo.get_exception_ptr();
        }
        var exceptionLast = 0;
        function ___cxa_free_exception(ptr) {
          return _free(new ExceptionInfo(ptr).ptr);
        }
        function exception_decRef(info) {
          if (info.release_ref() && !info.get_rethrown()) {
            var destructor = info.get_destructor();
            if (destructor) {
              wasmTable.get(destructor)(info.excPtr);
            }
            ___cxa_free_exception(info.excPtr);
          }
        }
        function ___cxa_end_catch() {
          _setThrew(0);
          var catchInfo = exceptionCaught.pop();
          exception_decRef(catchInfo.get_exception_info());
          catchInfo.free();
          exceptionLast = 0;
        }
        function ___resumeException(catchInfoPtr) {
          var catchInfo = new CatchInfo(catchInfoPtr);
          var ptr = catchInfo.get_base_ptr();
          if (!exceptionLast) {
            exceptionLast = ptr;
          }
          catchInfo.free();
          throw ptr;
        }
        function ___cxa_find_matching_catch_2() {
          var thrown = exceptionLast;
          if (!thrown) {
            setTempRet0(0);
            return 0 | 0;
          }
          var info = new ExceptionInfo(thrown);
          var thrownType = info.get_type();
          var catchInfo = new CatchInfo();
          catchInfo.set_base_ptr(thrown);
          catchInfo.set_adjusted_ptr(thrown);
          if (!thrownType) {
            setTempRet0(0);
            return catchInfo.ptr | 0;
          }
          var typeArray = Array.prototype.slice.call(arguments);
          for (var i = 0; i < typeArray.length; i++) {
            var caughtType = typeArray[i];
            if (caughtType === 0 || caughtType === thrownType) {
              break;
            }
            if (___cxa_can_catch(caughtType, thrownType, catchInfo.get_adjusted_ptr_addr())) {
              setTempRet0(caughtType);
              return catchInfo.ptr | 0;
            }
          }
          setTempRet0(thrownType);
          return catchInfo.ptr | 0;
        }
        function ___cxa_find_matching_catch_3() {
          var thrown = exceptionLast;
          if (!thrown) {
            setTempRet0(0);
            return 0 | 0;
          }
          var info = new ExceptionInfo(thrown);
          var thrownType = info.get_type();
          var catchInfo = new CatchInfo();
          catchInfo.set_base_ptr(thrown);
          catchInfo.set_adjusted_ptr(thrown);
          if (!thrownType) {
            setTempRet0(0);
            return catchInfo.ptr | 0;
          }
          var typeArray = Array.prototype.slice.call(arguments);
          for (var i = 0; i < typeArray.length; i++) {
            var caughtType = typeArray[i];
            if (caughtType === 0 || caughtType === thrownType) {
              break;
            }
            if (___cxa_can_catch(caughtType, thrownType, catchInfo.get_adjusted_ptr_addr())) {
              setTempRet0(caughtType);
              return catchInfo.ptr | 0;
            }
          }
          setTempRet0(thrownType);
          return catchInfo.ptr | 0;
        }
        function ___cxa_rethrow() {
          var catchInfo = exceptionCaught.pop();
          if (!catchInfo) {
            abort("no exception to throw");
          }
          var info = catchInfo.get_exception_info();
          var ptr = catchInfo.get_base_ptr();
          if (!info.get_rethrown()) {
            exceptionCaught.push(catchInfo);
            info.set_rethrown(true);
            info.set_caught(false);
            uncaughtExceptionCount++;
          } else {
            catchInfo.free();
          }
          exceptionLast = ptr;
          throw ptr;
        }
        function ___cxa_thread_atexit(routine, arg) {
          PThread.threadExitHandlers.push(function() {
            wasmTable.get(routine)(arg);
          });
        }
        function ___cxa_throw(ptr, type, destructor) {
          var info = new ExceptionInfo(ptr);
          info.init(type, destructor);
          exceptionLast = ptr;
          uncaughtExceptionCount++;
          throw ptr;
        }
        function ___cxa_uncaught_exceptions() {
          return uncaughtExceptionCount;
        }
        var PATH = { splitPath: function(filename) {
          var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
          return splitPathRe.exec(filename).slice(1);
        }, normalizeArray: function(parts, allowAboveRoot) {
          var up = 0;
          for (var i = parts.length - 1; i >= 0; i--) {
            var last = parts[i];
            if (last === ".") {
              parts.splice(i, 1);
            } else if (last === "..") {
              parts.splice(i, 1);
              up++;
            } else if (up) {
              parts.splice(i, 1);
              up--;
            }
          }
          if (allowAboveRoot) {
            for (; up; up--) {
              parts.unshift("..");
            }
          }
          return parts;
        }, normalize: function(path) {
          var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/";
          path = PATH.normalizeArray(path.split("/").filter(function(p) {
            return !!p;
          }), !isAbsolute).join("/");
          if (!path && !isAbsolute) {
            path = ".";
          }
          if (path && trailingSlash) {
            path += "/";
          }
          return (isAbsolute ? "/" : "") + path;
        }, dirname: function(path) {
          var result = PATH.splitPath(path), root = result[0], dir = result[1];
          if (!root && !dir) {
            return ".";
          }
          if (dir) {
            dir = dir.substr(0, dir.length - 1);
          }
          return root + dir;
        }, basename: function(path) {
          if (path === "/")
            return "/";
          path = PATH.normalize(path);
          path = path.replace(/\/$/, "");
          var lastSlash = path.lastIndexOf("/");
          if (lastSlash === -1)
            return path;
          return path.substr(lastSlash + 1);
        }, extname: function(path) {
          return PATH.splitPath(path)[3];
        }, join: function() {
          var paths = Array.prototype.slice.call(arguments, 0);
          return PATH.normalize(paths.join("/"));
        }, join2: function(l, r) {
          return PATH.normalize(l + "/" + r);
        } };
        function getRandomDevice() {
          if (typeof crypto === "object" && typeof crypto["getRandomValues"] === "function") {
            var randomBuffer = new Uint8Array(1);
            return function() {
              crypto.getRandomValues(randomBuffer);
              return randomBuffer[0];
            };
          } else if (ENVIRONMENT_IS_NODE) {
            try {
              var crypto_module = require_crypto();
              return function() {
                return crypto_module["randomBytes"](1)[0];
              };
            } catch (e) {
            }
          }
          return function() {
            abort("randomDevice");
          };
        }
        var PATH_FS = { resolve: function() {
          var resolvedPath = "", resolvedAbsolute = false;
          for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path = i >= 0 ? arguments[i] : FS.cwd();
            if (typeof path !== "string") {
              throw new TypeError("Arguments to path.resolve must be strings");
            } else if (!path) {
              return "";
            }
            resolvedPath = path + "/" + resolvedPath;
            resolvedAbsolute = path.charAt(0) === "/";
          }
          resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(function(p) {
            return !!p;
          }), !resolvedAbsolute).join("/");
          return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
        }, relative: function(from, to) {
          from = PATH_FS.resolve(from).substr(1);
          to = PATH_FS.resolve(to).substr(1);
          function trim(arr) {
            var start = 0;
            for (; start < arr.length; start++) {
              if (arr[start] !== "")
                break;
            }
            var end = arr.length - 1;
            for (; end >= 0; end--) {
              if (arr[end] !== "")
                break;
            }
            if (start > end)
              return [];
            return arr.slice(start, end - start + 1);
          }
          var fromParts = trim(from.split("/"));
          var toParts = trim(to.split("/"));
          var length = Math.min(fromParts.length, toParts.length);
          var samePartsLength = length;
          for (var i = 0; i < length; i++) {
            if (fromParts[i] !== toParts[i]) {
              samePartsLength = i;
              break;
            }
          }
          var outputParts = [];
          for (var i = samePartsLength; i < fromParts.length; i++) {
            outputParts.push("..");
          }
          outputParts = outputParts.concat(toParts.slice(samePartsLength));
          return outputParts.join("/");
        } };
        var TTY = { ttys: [], init: function() {
        }, shutdown: function() {
        }, register: function(dev, ops) {
          TTY.ttys[dev] = { input: [], output: [], ops };
          FS.registerDevice(dev, TTY.stream_ops);
        }, stream_ops: { open: function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        }, close: function(stream) {
          stream.tty.ops.flush(stream.tty);
        }, flush: function(stream) {
          stream.tty.ops.flush(stream.tty);
        }, read: function(stream, buffer2, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer2[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        }, write: function(stream, buffer2, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer2[offset + i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        } }, default_tty_ops: { get_char: function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              var BUFSIZE = 256;
              var buf = Buffer.alloc(BUFSIZE);
              var bytesRead = 0;
              try {
                bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);
              } catch (e) {
                if (e.toString().includes("EOF"))
                  bytesRead = 0;
                else
                  throw e;
              }
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString("utf-8");
              } else {
                result = null;
              }
            } else if (typeof window != "undefined" && typeof window.prompt == "function") {
              result = window.prompt("Input: ");
              if (result !== null) {
                result += "\n";
              }
            } else if (typeof readline == "function") {
              result = readline();
              if (result !== null) {
                result += "\n";
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        }, put_char: function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0)
              tty.output.push(val);
          }
        }, flush: function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        } }, default_tty1_ops: { put_char: function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0)
              tty.output.push(val);
          }
        }, flush: function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        } } };
        function zeroMemory(address, size) {
          GROWABLE_HEAP_U8().fill(0, address, address + size);
        }
        function mmapAlloc(size) {
          size = alignMemory(size, 65536);
          var ptr = _memalign(65536, size);
          if (!ptr)
            return 0;
          zeroMemory(ptr, size);
          return ptr;
        }
        var MEMFS = { ops_table: null, mount: function(mount) {
          return MEMFS.createNode(null, "/", 16384 | 511, 0);
        }, createNode: function(parent, name2, mode, dev) {
          if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
            throw new FS.ErrnoError(63);
          }
          if (!MEMFS.ops_table) {
            MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } };
          }
          var node = FS.createNode(parent, name2, mode, dev);
          if (FS.isDir(node.mode)) {
            node.node_ops = MEMFS.ops_table.dir.node;
            node.stream_ops = MEMFS.ops_table.dir.stream;
            node.contents = {};
          } else if (FS.isFile(node.mode)) {
            node.node_ops = MEMFS.ops_table.file.node;
            node.stream_ops = MEMFS.ops_table.file.stream;
            node.usedBytes = 0;
            node.contents = null;
          } else if (FS.isLink(node.mode)) {
            node.node_ops = MEMFS.ops_table.link.node;
            node.stream_ops = MEMFS.ops_table.link.stream;
          } else if (FS.isChrdev(node.mode)) {
            node.node_ops = MEMFS.ops_table.chrdev.node;
            node.stream_ops = MEMFS.ops_table.chrdev.stream;
          }
          node.timestamp = Date.now();
          if (parent) {
            parent.contents[name2] = node;
            parent.timestamp = node.timestamp;
          }
          return node;
        }, getFileDataAsTypedArray: function(node) {
          if (!node.contents)
            return new Uint8Array(0);
          if (node.contents.subarray)
            return node.contents.subarray(0, node.usedBytes);
          return new Uint8Array(node.contents);
        }, expandFileStorage: function(node, newCapacity) {
          newCapacity >>>= 0;
          var prevCapacity = node.contents ? node.contents.length : 0;
          if (prevCapacity >= newCapacity)
            return;
          var CAPACITY_DOUBLING_MAX = 1024 * 1024;
          newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
          if (prevCapacity != 0)
            newCapacity = Math.max(newCapacity, 256);
          var oldContents = node.contents;
          node.contents = new Uint8Array(newCapacity);
          if (node.usedBytes > 0)
            node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
        }, resizeFileStorage: function(node, newSize) {
          newSize >>>= 0;
          if (node.usedBytes == newSize)
            return;
          if (newSize == 0) {
            node.contents = null;
            node.usedBytes = 0;
          } else {
            var oldContents = node.contents;
            node.contents = new Uint8Array(newSize);
            if (oldContents) {
              node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
            }
            node.usedBytes = newSize;
          }
        }, node_ops: { getattr: function(node) {
          var attr = {};
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        }, setattr: function(node, attr) {
          if (attr.mode !== void 0) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== void 0) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        }, lookup: function(parent, name2) {
          throw FS.genericErrors[44];
        }, mknod: function(parent, name2, mode, dev) {
          return MEMFS.createNode(parent, name2, mode, dev);
        }, rename: function(old_node, new_dir, new_name) {
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now();
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        }, unlink: function(parent, name2) {
          delete parent.contents[name2];
          parent.timestamp = Date.now();
        }, rmdir: function(parent, name2) {
          var node = FS.lookupNode(parent, name2);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name2];
          parent.timestamp = Date.now();
        }, readdir: function(node) {
          var entries = [".", ".."];
          for (var key2 in node.contents) {
            if (!node.contents.hasOwnProperty(key2)) {
              continue;
            }
            entries.push(key2);
          }
          return entries;
        }, symlink: function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
          node.link = oldpath;
          return node;
        }, readlink: function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        } }, stream_ops: { read: function(stream, buffer2, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes)
            return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) {
            buffer2.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++)
              buffer2[offset + i] = contents[position + i];
          }
          return size;
        }, write: function(stream, buffer2, offset, length, position, canOwn) {
          if (buffer2.buffer === GROWABLE_HEAP_I8().buffer) {
            canOwn = false;
          }
          if (!length)
            return 0;
          var node = stream.node;
          node.timestamp = Date.now();
          if (buffer2.subarray && (!node.contents || node.contents.subarray)) {
            if (canOwn) {
              node.contents = buffer2.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) {
              node.contents = buffer2.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) {
              node.contents.set(buffer2.subarray(offset, offset + length), position);
              return length;
            }
          }
          MEMFS.expandFileStorage(node, position + length);
          if (node.contents.subarray && buffer2.subarray) {
            node.contents.set(buffer2.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
              node.contents[position + i] = buffer2[offset + i];
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        }, llseek: function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        }, allocate: function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        }, mmap: function(stream, address, length, position, prot, flags) {
          if (address !== 0) {
            throw new FS.ErrnoError(28);
          }
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          if (!(flags & 2) && contents.buffer === buffer) {
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            ptr >>>= 0;
            GROWABLE_HEAP_I8().set(contents, ptr >>> 0);
          }
          return { ptr, allocated };
        }, msync: function(stream, buffer2, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            return 0;
          }
          MEMFS.stream_ops.write(stream, buffer2, 0, length, offset, false);
          return 0;
        } } };
        function asyncLoad(url, onload, onerror, noRunDep) {
          var dep = !noRunDep ? getUniqueRunDependency("al " + url) : "";
          readAsync(url, function(arrayBuffer) {
            assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
            onload(new Uint8Array(arrayBuffer));
            if (dep)
              removeRunDependency();
          }, function(event) {
            if (onerror) {
              onerror();
            } else {
              throw 'Loading data file "' + url + '" failed.';
            }
          });
          if (dep)
            addRunDependency();
        }
        var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, trackingDelegate: {}, tracking: { openFlags: { READ: 1, WRITE: 2 } }, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, lookupPath: function(path, opts) {
          path = PATH_FS.resolve(FS.cwd(), path);
          opts = opts || {};
          if (!path)
            return { path: "", node: null };
          var defaults = { follow_mount: true, recurse_count: 0 };
          for (var key2 in defaults) {
            if (opts[key2] === void 0) {
              opts[key2] = defaults[key2];
            }
          }
          if (opts.recurse_count > 8) {
            throw new FS.ErrnoError(32);
          }
          var parts = PATH.normalizeArray(path.split("/").filter(function(p) {
            return !!p;
          }), false);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            current = FS.lookupNode(current, parts[i]);
            current_path = PATH.join2(current_path, parts[i]);
            if (FS.isMountpoint(current)) {
              if (!islast || islast && opts.follow_mount) {
                current = current.mounted.root;
              }
            }
            if (!islast || opts.follow) {
              var count = 0;
              while (FS.isLink(current.mode)) {
                var link = FS.readlink(current_path);
                current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
                current = lookup.node;
                if (count++ > 40) {
                  throw new FS.ErrnoError(32);
                }
              }
            }
          }
          return { path: current_path, node: current };
        }, getPath: function(node) {
          var path;
          while (true) {
            if (FS.isRoot(node)) {
              var mount = node.mount.mountpoint;
              if (!path)
                return mount;
              return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
            }
            path = path ? node.name + "/" + path : node.name;
            node = node.parent;
          }
        }, hashName: function(parentid, name2) {
          var hash = 0;
          for (var i = 0; i < name2.length; i++) {
            hash = (hash << 5) - hash + name2.charCodeAt(i) | 0;
          }
          return (parentid + hash >>> 0) % FS.nameTable.length;
        }, hashAddNode: function(node) {
          var hash = FS.hashName(node.parent.id, node.name);
          node.name_next = FS.nameTable[hash];
          FS.nameTable[hash] = node;
        }, hashRemoveNode: function(node) {
          var hash = FS.hashName(node.parent.id, node.name);
          if (FS.nameTable[hash] === node) {
            FS.nameTable[hash] = node.name_next;
          } else {
            var current = FS.nameTable[hash];
            while (current) {
              if (current.name_next === node) {
                current.name_next = node.name_next;
                break;
              }
              current = current.name_next;
            }
          }
        }, lookupNode: function(parent, name2) {
          var errCode = FS.mayLookup(parent);
          if (errCode) {
            throw new FS.ErrnoError(errCode, parent);
          }
          var hash = FS.hashName(parent.id, name2);
          for (var node = FS.nameTable[hash]; node; node = node.name_next) {
            var nodeName = node.name;
            if (node.parent.id === parent.id && nodeName === name2) {
              return node;
            }
          }
          return FS.lookup(parent, name2);
        }, createNode: function(parent, name2, mode, rdev) {
          var node = new FS.FSNode(parent, name2, mode, rdev);
          FS.hashAddNode(node);
          return node;
        }, destroyNode: function(node) {
          FS.hashRemoveNode(node);
        }, isRoot: function(node) {
          return node === node.parent;
        }, isMountpoint: function(node) {
          return !!node.mounted;
        }, isFile: function(mode) {
          return (mode & 61440) === 32768;
        }, isDir: function(mode) {
          return (mode & 61440) === 16384;
        }, isLink: function(mode) {
          return (mode & 61440) === 40960;
        }, isChrdev: function(mode) {
          return (mode & 61440) === 8192;
        }, isBlkdev: function(mode) {
          return (mode & 61440) === 24576;
        }, isFIFO: function(mode) {
          return (mode & 61440) === 4096;
        }, isSocket: function(mode) {
          return (mode & 49152) === 49152;
        }, flagModes: { "r": 0, "r+": 2, "w": 577, "w+": 578, "a": 1089, "a+": 1090 }, modeStringToFlags: function(str) {
          var flags = FS.flagModes[str];
          if (typeof flags === "undefined") {
            throw new Error("Unknown file open mode: " + str);
          }
          return flags;
        }, flagsToPermissionString: function(flag) {
          var perms = ["r", "w", "rw"][flag & 3];
          if (flag & 512) {
            perms += "w";
          }
          return perms;
        }, nodePermissions: function(node, perms) {
          if (FS.ignorePermissions) {
            return 0;
          }
          if (perms.includes("r") && !(node.mode & 292)) {
            return 2;
          } else if (perms.includes("w") && !(node.mode & 146)) {
            return 2;
          } else if (perms.includes("x") && !(node.mode & 73)) {
            return 2;
          }
          return 0;
        }, mayLookup: function(dir) {
          var errCode = FS.nodePermissions(dir, "x");
          if (errCode)
            return errCode;
          if (!dir.node_ops.lookup)
            return 2;
          return 0;
        }, mayCreate: function(dir, name2) {
          try {
            var node = FS.lookupNode(dir, name2);
            return 20;
          } catch (e) {
          }
          return FS.nodePermissions(dir, "wx");
        }, mayDelete: function(dir, name2, isdir) {
          var node;
          try {
            node = FS.lookupNode(dir, name2);
          } catch (e) {
            return e.errno;
          }
          var errCode = FS.nodePermissions(dir, "wx");
          if (errCode) {
            return errCode;
          }
          if (isdir) {
            if (!FS.isDir(node.mode)) {
              return 54;
            }
            if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
              return 10;
            }
          } else {
            if (FS.isDir(node.mode)) {
              return 31;
            }
          }
          return 0;
        }, mayOpen: function(node, flags) {
          if (!node) {
            return 44;
          }
          if (FS.isLink(node.mode)) {
            return 32;
          } else if (FS.isDir(node.mode)) {
            if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
              return 31;
            }
          }
          return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
        }, MAX_OPEN_FDS: 4096, nextfd: function(fd_start, fd_end) {
          fd_start = fd_start || 0;
          fd_end = fd_end || FS.MAX_OPEN_FDS;
          for (var fd = fd_start; fd <= fd_end; fd++) {
            if (!FS.streams[fd]) {
              return fd;
            }
          }
          throw new FS.ErrnoError(33);
        }, getStream: function(fd) {
          return FS.streams[fd];
        }, createStream: function(stream, fd_start, fd_end) {
          if (!FS.FSStream) {
            FS.FSStream = function() {
            };
            FS.FSStream.prototype = { object: { get: function() {
              return this.node;
            }, set: function(val) {
              this.node = val;
            } }, isRead: { get: function() {
              return (this.flags & 2097155) !== 1;
            } }, isWrite: { get: function() {
              return (this.flags & 2097155) !== 0;
            } }, isAppend: { get: function() {
              return this.flags & 1024;
            } } };
          }
          var newStream = new FS.FSStream();
          for (var p in stream) {
            newStream[p] = stream[p];
          }
          stream = newStream;
          var fd = FS.nextfd(fd_start, fd_end);
          stream.fd = fd;
          FS.streams[fd] = stream;
          return stream;
        }, closeStream: function(fd) {
          FS.streams[fd] = null;
        }, chrdev_stream_ops: { open: function(stream) {
          var device = FS.getDevice(stream.node.rdev);
          stream.stream_ops = device.stream_ops;
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        }, llseek: function() {
          throw new FS.ErrnoError(70);
        } }, major: function(dev) {
          return dev >> 8;
        }, minor: function(dev) {
          return dev & 255;
        }, makedev: function(ma, mi) {
          return ma << 8 | mi;
        }, registerDevice: function(dev, ops) {
          FS.devices[dev] = { stream_ops: ops };
        }, getDevice: function(dev) {
          return FS.devices[dev];
        }, getMounts: function(mount) {
          var mounts = [];
          var check = [mount];
          while (check.length) {
            var m = check.pop();
            mounts.push(m);
            check.push.apply(check, m.mounts);
          }
          return mounts;
        }, syncfs: function(populate, callback) {
          if (typeof populate === "function") {
            callback = populate;
            populate = false;
          }
          FS.syncFSRequests++;
          if (FS.syncFSRequests > 1) {
            err("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
          }
          var mounts = FS.getMounts(FS.root.mount);
          var completed = 0;
          function doCallback(errCode) {
            FS.syncFSRequests--;
            return callback(errCode);
          }
          function done(errCode) {
            if (errCode) {
              if (!done.errored) {
                done.errored = true;
                return doCallback(errCode);
              }
              return;
            }
            if (++completed >= mounts.length) {
              doCallback(null);
            }
          }
          mounts.forEach(function(mount) {
            if (!mount.type.syncfs) {
              return done(null);
            }
            mount.type.syncfs(mount, populate, done);
          });
        }, mount: function(type, opts, mountpoint) {
          var root = mountpoint === "/";
          var pseudo = !mountpoint;
          var node;
          if (root && FS.root) {
            throw new FS.ErrnoError(10);
          } else if (!root && !pseudo) {
            var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
            mountpoint = lookup.path;
            node = lookup.node;
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            if (!FS.isDir(node.mode)) {
              throw new FS.ErrnoError(54);
            }
          }
          var mount = { type, opts, mountpoint, mounts: [] };
          var mountRoot = type.mount(mount);
          mountRoot.mount = mount;
          mount.root = mountRoot;
          if (root) {
            FS.root = mountRoot;
          } else if (node) {
            node.mounted = mount;
            if (node.mount) {
              node.mount.mounts.push(mount);
            }
          }
          return mountRoot;
        }, unmount: function(mountpoint) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
          if (!FS.isMountpoint(lookup.node)) {
            throw new FS.ErrnoError(28);
          }
          var node = lookup.node;
          var mount = node.mounted;
          var mounts = FS.getMounts(mount);
          Object.keys(FS.nameTable).forEach(function(hash) {
            var current = FS.nameTable[hash];
            while (current) {
              var next = current.name_next;
              if (mounts.includes(current.mount)) {
                FS.destroyNode(current);
              }
              current = next;
            }
          });
          node.mounted = null;
          var idx = node.mount.mounts.indexOf(mount);
          node.mount.mounts.splice(idx, 1);
        }, lookup: function(parent, name2) {
          return parent.node_ops.lookup(parent, name2);
        }, mknod: function(path, mode, dev) {
          var lookup = FS.lookupPath(path, { parent: true });
          var parent = lookup.node;
          var name2 = PATH.basename(path);
          if (!name2 || name2 === "." || name2 === "..") {
            throw new FS.ErrnoError(28);
          }
          var errCode = FS.mayCreate(parent, name2);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.mknod) {
            throw new FS.ErrnoError(63);
          }
          return parent.node_ops.mknod(parent, name2, mode, dev);
        }, create: function(path, mode) {
          mode = mode !== void 0 ? mode : 438;
          mode &= 4095;
          mode |= 32768;
          return FS.mknod(path, mode, 0);
        }, mkdir: function(path, mode) {
          mode = mode !== void 0 ? mode : 511;
          mode &= 511 | 512;
          mode |= 16384;
          return FS.mknod(path, mode, 0);
        }, mkdirTree: function(path, mode) {
          var dirs = path.split("/");
          var d = "";
          for (var i = 0; i < dirs.length; ++i) {
            if (!dirs[i])
              continue;
            d += "/" + dirs[i];
            try {
              FS.mkdir(d, mode);
            } catch (e) {
              if (e.errno != 20)
                throw e;
            }
          }
        }, mkdev: function(path, mode, dev) {
          if (typeof dev === "undefined") {
            dev = mode;
            mode = 438;
          }
          mode |= 8192;
          return FS.mknod(path, mode, dev);
        }, symlink: function(oldpath, newpath) {
          if (!PATH_FS.resolve(oldpath)) {
            throw new FS.ErrnoError(44);
          }
          var lookup = FS.lookupPath(newpath, { parent: true });
          var parent = lookup.node;
          if (!parent) {
            throw new FS.ErrnoError(44);
          }
          var newname = PATH.basename(newpath);
          var errCode = FS.mayCreate(parent, newname);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.symlink) {
            throw new FS.ErrnoError(63);
          }
          return parent.node_ops.symlink(parent, newname, oldpath);
        }, rename: function(old_path, new_path) {
          var old_dirname = PATH.dirname(old_path);
          var new_dirname = PATH.dirname(new_path);
          var old_name = PATH.basename(old_path);
          var new_name = PATH.basename(new_path);
          var lookup, old_dir, new_dir;
          lookup = FS.lookupPath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = FS.lookupPath(new_path, { parent: true });
          new_dir = lookup.node;
          if (!old_dir || !new_dir)
            throw new FS.ErrnoError(44);
          if (old_dir.mount !== new_dir.mount) {
            throw new FS.ErrnoError(75);
          }
          var old_node = FS.lookupNode(old_dir, old_name);
          var relative = PATH_FS.relative(old_path, new_dirname);
          if (relative.charAt(0) !== ".") {
            throw new FS.ErrnoError(28);
          }
          relative = PATH_FS.relative(new_path, old_dirname);
          if (relative.charAt(0) !== ".") {
            throw new FS.ErrnoError(55);
          }
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (old_node === new_node) {
            return;
          }
          var isdir = FS.isDir(old_node.mode);
          var errCode = FS.mayDelete(old_dir, old_name, isdir);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!old_dir.node_ops.rename) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
            throw new FS.ErrnoError(10);
          }
          if (new_dir !== old_dir) {
            errCode = FS.nodePermissions(old_dir, "w");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
          }
          try {
            if (FS.trackingDelegate["willMovePath"]) {
              FS.trackingDelegate["willMovePath"](old_path, new_path);
            }
          } catch (e) {
            err("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
          }
          FS.hashRemoveNode(old_node);
          try {
            old_dir.node_ops.rename(old_node, new_dir, new_name);
          } catch (e) {
            throw e;
          } finally {
            FS.hashAddNode(old_node);
          }
          try {
            if (FS.trackingDelegate["onMovePath"])
              FS.trackingDelegate["onMovePath"](old_path, new_path);
          } catch (e) {
            err("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
          }
        }, rmdir: function(path) {
          var lookup = FS.lookupPath(path, { parent: true });
          var parent = lookup.node;
          var name2 = PATH.basename(path);
          var node = FS.lookupNode(parent, name2);
          var errCode = FS.mayDelete(parent, name2, true);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.rmdir) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          try {
            if (FS.trackingDelegate["willDeletePath"]) {
              FS.trackingDelegate["willDeletePath"](path);
            }
          } catch (e) {
            err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
          }
          parent.node_ops.rmdir(parent, name2);
          FS.destroyNode(node);
          try {
            if (FS.trackingDelegate["onDeletePath"])
              FS.trackingDelegate["onDeletePath"](path);
          } catch (e) {
            err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
          }
        }, readdir: function(path) {
          var lookup = FS.lookupPath(path, { follow: true });
          var node = lookup.node;
          if (!node.node_ops.readdir) {
            throw new FS.ErrnoError(54);
          }
          return node.node_ops.readdir(node);
        }, unlink: function(path) {
          var lookup = FS.lookupPath(path, { parent: true });
          var parent = lookup.node;
          var name2 = PATH.basename(path);
          var node = FS.lookupNode(parent, name2);
          var errCode = FS.mayDelete(parent, name2, false);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.unlink) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          try {
            if (FS.trackingDelegate["willDeletePath"]) {
              FS.trackingDelegate["willDeletePath"](path);
            }
          } catch (e) {
            err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
          }
          parent.node_ops.unlink(parent, name2);
          FS.destroyNode(node);
          try {
            if (FS.trackingDelegate["onDeletePath"])
              FS.trackingDelegate["onDeletePath"](path);
          } catch (e) {
            err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
          }
        }, readlink: function(path) {
          var lookup = FS.lookupPath(path);
          var link = lookup.node;
          if (!link) {
            throw new FS.ErrnoError(44);
          }
          if (!link.node_ops.readlink) {
            throw new FS.ErrnoError(28);
          }
          return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
        }, stat: function(path, dontFollow) {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          var node = lookup.node;
          if (!node) {
            throw new FS.ErrnoError(44);
          }
          if (!node.node_ops.getattr) {
            throw new FS.ErrnoError(63);
          }
          return node.node_ops.getattr(node);
        }, lstat: function(path) {
          return FS.stat(path, true);
        }, chmod: function(path, mode, dontFollow) {
          var node;
          if (typeof path === "string") {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            node = lookup.node;
          } else {
            node = path;
          }
          if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(63);
          }
          node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now() });
        }, lchmod: function(path, mode) {
          FS.chmod(path, mode, true);
        }, fchmod: function(fd, mode) {
          var stream = FS.getStream(fd);
          if (!stream) {
            throw new FS.ErrnoError(8);
          }
          FS.chmod(stream.node, mode);
        }, chown: function(path, uid, gid, dontFollow) {
          var node;
          if (typeof path === "string") {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            node = lookup.node;
          } else {
            node = path;
          }
          if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(63);
          }
          node.node_ops.setattr(node, { timestamp: Date.now() });
        }, lchown: function(path, uid, gid) {
          FS.chown(path, uid, gid, true);
        }, fchown: function(fd, uid, gid) {
          var stream = FS.getStream(fd);
          if (!stream) {
            throw new FS.ErrnoError(8);
          }
          FS.chown(stream.node, uid, gid);
        }, truncate: function(path, len) {
          if (len < 0) {
            throw new FS.ErrnoError(28);
          }
          var node;
          if (typeof path === "string") {
            var lookup = FS.lookupPath(path, { follow: true });
            node = lookup.node;
          } else {
            node = path;
          }
          if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isDir(node.mode)) {
            throw new FS.ErrnoError(31);
          }
          if (!FS.isFile(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          var errCode = FS.nodePermissions(node, "w");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
        }, ftruncate: function(fd, len) {
          var stream = FS.getStream(fd);
          if (!stream) {
            throw new FS.ErrnoError(8);
          }
          if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(28);
          }
          FS.truncate(stream.node, len);
        }, utime: function(path, atime, mtime) {
          var lookup = FS.lookupPath(path, { follow: true });
          var node = lookup.node;
          node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
        }, open: function(path, flags, mode, fd_start, fd_end) {
          if (path === "") {
            throw new FS.ErrnoError(44);
          }
          flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
          mode = typeof mode === "undefined" ? 438 : mode;
          if (flags & 64) {
            mode = mode & 4095 | 32768;
          } else {
            mode = 0;
          }
          var node;
          if (typeof path === "object") {
            node = path;
          } else {
            path = PATH.normalize(path);
            try {
              var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
              node = lookup.node;
            } catch (e) {
            }
          }
          var created = false;
          if (flags & 64) {
            if (node) {
              if (flags & 128) {
                throw new FS.ErrnoError(20);
              }
            } else {
              node = FS.mknod(path, mode, 0);
              created = true;
            }
          }
          if (!node) {
            throw new FS.ErrnoError(44);
          }
          if (FS.isChrdev(node.mode)) {
            flags &= ~512;
          }
          if (flags & 65536 && !FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
          if (!created) {
            var errCode = FS.mayOpen(node, flags);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
          }
          if (flags & 512) {
            FS.truncate(node, 0);
          }
          flags &= ~(128 | 512 | 131072);
          var stream = FS.createStream({ node, path: FS.getPath(node), flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false }, fd_start, fd_end);
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
          if (Module["logReadFiles"] && !(flags & 1)) {
            if (!FS.readFiles)
              FS.readFiles = {};
            if (!(path in FS.readFiles)) {
              FS.readFiles[path] = 1;
              err("FS.trackingDelegate error on read file: " + path);
            }
          }
          try {
            if (FS.trackingDelegate["onOpenFile"]) {
              var trackingFlags = 0;
              if ((flags & 2097155) !== 1) {
                trackingFlags |= FS.tracking.openFlags.READ;
              }
              if ((flags & 2097155) !== 0) {
                trackingFlags |= FS.tracking.openFlags.WRITE;
              }
              FS.trackingDelegate["onOpenFile"](path, trackingFlags);
            }
          } catch (e) {
            err("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message);
          }
          return stream;
        }, close: function(stream) {
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if (stream.getdents)
            stream.getdents = null;
          try {
            if (stream.stream_ops.close) {
              stream.stream_ops.close(stream);
            }
          } catch (e) {
            throw e;
          } finally {
            FS.closeStream(stream.fd);
          }
          stream.fd = null;
        }, isClosed: function(stream) {
          return stream.fd === null;
        }, llseek: function(stream, offset, whence) {
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if (!stream.seekable || !stream.stream_ops.llseek) {
            throw new FS.ErrnoError(70);
          }
          if (whence != 0 && whence != 1 && whence != 2) {
            throw new FS.ErrnoError(28);
          }
          stream.position = stream.stream_ops.llseek(stream, offset, whence);
          stream.ungotten = [];
          return stream.position;
        }, read: function(stream, buffer2, offset, length, position) {
          offset >>>= 0;
          if (length < 0 || position < 0) {
            throw new FS.ErrnoError(28);
          }
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if ((stream.flags & 2097155) === 1) {
            throw new FS.ErrnoError(8);
          }
          if (FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(31);
          }
          if (!stream.stream_ops.read) {
            throw new FS.ErrnoError(28);
          }
          var seeking = typeof position !== "undefined";
          if (!seeking) {
            position = stream.position;
          } else if (!stream.seekable) {
            throw new FS.ErrnoError(70);
          }
          var bytesRead = stream.stream_ops.read(stream, buffer2, offset, length, position);
          if (!seeking)
            stream.position += bytesRead;
          return bytesRead;
        }, write: function(stream, buffer2, offset, length, position, canOwn) {
          offset >>>= 0;
          if (length < 0 || position < 0) {
            throw new FS.ErrnoError(28);
          }
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(8);
          }
          if (FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(31);
          }
          if (!stream.stream_ops.write) {
            throw new FS.ErrnoError(28);
          }
          if (stream.seekable && stream.flags & 1024) {
            FS.llseek(stream, 0, 2);
          }
          var seeking = typeof position !== "undefined";
          if (!seeking) {
            position = stream.position;
          } else if (!stream.seekable) {
            throw new FS.ErrnoError(70);
          }
          var bytesWritten = stream.stream_ops.write(stream, buffer2, offset, length, position, canOwn);
          if (!seeking)
            stream.position += bytesWritten;
          try {
            if (stream.path && FS.trackingDelegate["onWriteToFile"])
              FS.trackingDelegate["onWriteToFile"](stream.path);
          } catch (e) {
            err("FS.trackingDelegate['onWriteToFile']('" + stream.path + "') threw an exception: " + e.message);
          }
          return bytesWritten;
        }, allocate: function(stream, offset, length) {
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if (offset < 0 || length <= 0) {
            throw new FS.ErrnoError(28);
          }
          if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(8);
          }
          if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (!stream.stream_ops.allocate) {
            throw new FS.ErrnoError(138);
          }
          stream.stream_ops.allocate(stream, offset, length);
        }, mmap: function(stream, address, length, position, prot, flags) {
          address >>>= 0;
          if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
            throw new FS.ErrnoError(2);
          }
          if ((stream.flags & 2097155) === 1) {
            throw new FS.ErrnoError(2);
          }
          if (!stream.stream_ops.mmap) {
            throw new FS.ErrnoError(43);
          }
          return stream.stream_ops.mmap(stream, address, length, position, prot, flags);
        }, msync: function(stream, buffer2, offset, length, mmapFlags) {
          offset >>>= 0;
          if (!stream || !stream.stream_ops.msync) {
            return 0;
          }
          return stream.stream_ops.msync(stream, buffer2, offset, length, mmapFlags);
        }, munmap: function(stream) {
          return 0;
        }, ioctl: function(stream, cmd, arg) {
          if (!stream.stream_ops.ioctl) {
            throw new FS.ErrnoError(59);
          }
          return stream.stream_ops.ioctl(stream, cmd, arg);
        }, readFile: function(path, opts) {
          opts = opts || {};
          opts.flags = opts.flags || 0;
          opts.encoding = opts.encoding || "binary";
          if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
            throw new Error('Invalid encoding type "' + opts.encoding + '"');
          }
          var ret;
          var stream = FS.open(path, opts.flags);
          var stat = FS.stat(path);
          var length = stat.size;
          var buf = new Uint8Array(length);
          FS.read(stream, buf, 0, length, 0);
          if (opts.encoding === "utf8") {
            ret = UTF8ArrayToString(buf, 0);
          } else if (opts.encoding === "binary") {
            ret = buf;
          }
          FS.close(stream);
          return ret;
        }, writeFile: function(path, data, opts) {
          opts = opts || {};
          opts.flags = opts.flags || 577;
          var stream = FS.open(path, opts.flags, opts.mode);
          if (typeof data === "string") {
            var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
            var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
            FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
          } else if (ArrayBuffer.isView(data)) {
            FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
          } else {
            throw new Error("Unsupported data type");
          }
          FS.close(stream);
        }, cwd: function() {
          return FS.currentPath;
        }, chdir: function(path) {
          var lookup = FS.lookupPath(path, { follow: true });
          if (lookup.node === null) {
            throw new FS.ErrnoError(44);
          }
          if (!FS.isDir(lookup.node.mode)) {
            throw new FS.ErrnoError(54);
          }
          var errCode = FS.nodePermissions(lookup.node, "x");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          FS.currentPath = lookup.path;
        }, createDefaultDirectories: function() {
          FS.mkdir("/tmp");
          FS.mkdir("/home");
          FS.mkdir("/home/web_user");
        }, createDefaultDevices: function() {
          FS.mkdir("/dev");
          FS.registerDevice(FS.makedev(1, 3), { read: function() {
            return 0;
          }, write: function(stream, buffer2, offset, length, pos) {
            return length;
          } });
          FS.mkdev("/dev/null", FS.makedev(1, 3));
          TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
          TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
          FS.mkdev("/dev/tty", FS.makedev(5, 0));
          FS.mkdev("/dev/tty1", FS.makedev(6, 0));
          var random_device = getRandomDevice();
          FS.createDevice("/dev", "random", random_device);
          FS.createDevice("/dev", "urandom", random_device);
          FS.mkdir("/dev/shm");
          FS.mkdir("/dev/shm/tmp");
        }, createSpecialDirectories: function() {
          FS.mkdir("/proc");
          var proc_self = FS.mkdir("/proc/self");
          FS.mkdir("/proc/self/fd");
          FS.mount({ mount: function() {
            var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
            node.node_ops = { lookup: function(parent, name2) {
              var fd = +name2;
              var stream = FS.getStream(fd);
              if (!stream)
                throw new FS.ErrnoError(8);
              var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: function() {
                return stream.path;
              } } };
              ret.parent = ret;
              return ret;
            } };
            return node;
          } }, {}, "/proc/self/fd");
        }, createStandardStreams: function() {
          if (Module["stdin"]) {
            FS.createDevice("/dev", "stdin", Module["stdin"]);
          } else {
            FS.symlink("/dev/tty", "/dev/stdin");
          }
          if (Module["stdout"]) {
            FS.createDevice("/dev", "stdout", null, Module["stdout"]);
          } else {
            FS.symlink("/dev/tty", "/dev/stdout");
          }
          if (Module["stderr"]) {
            FS.createDevice("/dev", "stderr", null, Module["stderr"]);
          } else {
            FS.symlink("/dev/tty1", "/dev/stderr");
          }
          FS.open("/dev/stdin", 0);
          FS.open("/dev/stdout", 1);
          FS.open("/dev/stderr", 1);
        }, ensureErrnoError: function() {
          if (FS.ErrnoError)
            return;
          FS.ErrnoError = function ErrnoError(errno, node) {
            this.node = node;
            this.setErrno = function(errno2) {
              this.errno = errno2;
            };
            this.setErrno(errno);
            this.message = "FS error";
          };
          FS.ErrnoError.prototype = new Error();
          FS.ErrnoError.prototype.constructor = FS.ErrnoError;
          [44].forEach(function(code) {
            FS.genericErrors[code] = new FS.ErrnoError(code);
            FS.genericErrors[code].stack = "<generic error, no stack>";
          });
        }, staticInit: function() {
          FS.ensureErrnoError();
          FS.nameTable = new Array(4096);
          FS.mount(MEMFS, {}, "/");
          FS.createDefaultDirectories();
          FS.createDefaultDevices();
          FS.createSpecialDirectories();
          FS.filesystems = { "MEMFS": MEMFS };
        }, init: function(input, output, error) {
          FS.init.initialized = true;
          FS.ensureErrnoError();
          Module["stdin"] = input || Module["stdin"];
          Module["stdout"] = output || Module["stdout"];
          Module["stderr"] = error || Module["stderr"];
          FS.createStandardStreams();
        }, quit: function() {
          FS.init.initialized = false;
          var fflush = Module["_fflush"];
          if (fflush)
            fflush(0);
          for (var i = 0; i < FS.streams.length; i++) {
            var stream = FS.streams[i];
            if (!stream) {
              continue;
            }
            FS.close(stream);
          }
        }, getMode: function(canRead, canWrite) {
          var mode = 0;
          if (canRead)
            mode |= 292 | 73;
          if (canWrite)
            mode |= 146;
          return mode;
        }, findObject: function(path, dontResolveLastLink) {
          var ret = FS.analyzePath(path, dontResolveLastLink);
          if (ret.exists) {
            return ret.object;
          } else {
            return null;
          }
        }, analyzePath: function(path, dontResolveLastLink) {
          try {
            var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
            path = lookup.path;
          } catch (e) {
          }
          var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
          try {
            var lookup = FS.lookupPath(path, { parent: true });
            ret.parentExists = true;
            ret.parentPath = lookup.path;
            ret.parentObject = lookup.node;
            ret.name = PATH.basename(path);
            lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
            ret.exists = true;
            ret.path = lookup.path;
            ret.object = lookup.node;
            ret.name = lookup.node.name;
            ret.isRoot = lookup.path === "/";
          } catch (e) {
            ret.error = e.errno;
          }
          return ret;
        }, createPath: function(parent, path, canRead, canWrite) {
          parent = typeof parent === "string" ? parent : FS.getPath(parent);
          var parts = path.split("/").reverse();
          while (parts.length) {
            var part = parts.pop();
            if (!part)
              continue;
            var current = PATH.join2(parent, part);
            try {
              FS.mkdir(current);
            } catch (e) {
            }
            parent = current;
          }
          return current;
        }, createFile: function(parent, name2, properties, canRead, canWrite) {
          var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
          var mode = FS.getMode(canRead, canWrite);
          return FS.create(path, mode);
        }, createDataFile: function(parent, name2, data, canRead, canWrite, canOwn) {
          var path = name2 ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2) : parent;
          var mode = FS.getMode(canRead, canWrite);
          var node = FS.create(path, mode);
          if (data) {
            if (typeof data === "string") {
              var arr = new Array(data.length);
              for (var i = 0, len = data.length; i < len; ++i)
                arr[i] = data.charCodeAt(i);
              data = arr;
            }
            FS.chmod(node, mode | 146);
            var stream = FS.open(node, 577);
            FS.write(stream, data, 0, data.length, 0, canOwn);
            FS.close(stream);
            FS.chmod(node, mode);
          }
          return node;
        }, createDevice: function(parent, name2, input, output) {
          var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
          var mode = FS.getMode(!!input, !!output);
          if (!FS.createDevice.major)
            FS.createDevice.major = 64;
          var dev = FS.makedev(FS.createDevice.major++, 0);
          FS.registerDevice(dev, { open: function(stream) {
            stream.seekable = false;
          }, close: function(stream) {
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          }, read: function(stream, buffer2, offset, length, pos) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === void 0 && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === void 0)
                break;
              bytesRead++;
              buffer2[offset + i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          }, write: function(stream, buffer2, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer2[offset + i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          } });
          return FS.mkdev(path, mode, dev);
        }, forceLoadFile: function(obj) {
          if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
            return true;
          if (typeof XMLHttpRequest !== "undefined") {
            throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
          } else if (read_) {
            try {
              obj.contents = intArrayFromString(read_(obj.url), true);
              obj.usedBytes = obj.contents.length;
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          } else {
            throw new Error("Cannot load without read() or XMLHttpRequest.");
          }
        }, createLazyFile: function(parent, name2, url, canRead, canWrite) {
          function LazyUint8Array() {
            this.lengthKnown = false;
            this.chunks = [];
          }
          LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
            if (idx > this.length - 1 || idx < 0) {
              return void 0;
            }
            var chunkOffset = idx % this.chunkSize;
            var chunkNum = idx / this.chunkSize | 0;
            return this.getter(chunkNum)[chunkOffset];
          };
          LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
            this.getter = getter;
          };
          LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
            var xhr = new XMLHttpRequest();
            xhr.open("HEAD", url, false);
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
              throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            var datalength = Number(xhr.getResponseHeader("Content-length"));
            var header;
            var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
            var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
            var chunkSize = 1024 * 1024;
            if (!hasByteServing)
              chunkSize = datalength;
            var doXHR = function(from, to) {
              if (from > to)
                throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
              if (to > datalength - 1)
                throw new Error("only " + datalength + " bytes available! programmer error!");
              var xhr2 = new XMLHttpRequest();
              xhr2.open("GET", url, false);
              if (datalength !== chunkSize)
                xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
              if (typeof Uint8Array != "undefined")
                xhr2.responseType = "arraybuffer";
              if (xhr2.overrideMimeType) {
                xhr2.overrideMimeType("text/plain; charset=x-user-defined");
              }
              xhr2.send(null);
              if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
                throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
              if (xhr2.response !== void 0) {
                return new Uint8Array(xhr2.response || []);
              } else {
                return intArrayFromString(xhr2.responseText || "", true);
              }
            };
            var lazyArray2 = this;
            lazyArray2.setDataGetter(function(chunkNum) {
              var start = chunkNum * chunkSize;
              var end = (chunkNum + 1) * chunkSize - 1;
              end = Math.min(end, datalength - 1);
              if (typeof lazyArray2.chunks[chunkNum] === "undefined") {
                lazyArray2.chunks[chunkNum] = doXHR(start, end);
              }
              if (typeof lazyArray2.chunks[chunkNum] === "undefined")
                throw new Error("doXHR failed!");
              return lazyArray2.chunks[chunkNum];
            });
            if (usesGzip || !datalength) {
              chunkSize = datalength = 1;
              datalength = this.getter(0).length;
              chunkSize = datalength;
              out("LazyFiles on gzip forces download of the whole file when length is accessed");
            }
            this._length = datalength;
            this._chunkSize = chunkSize;
            this.lengthKnown = true;
          };
          if (typeof XMLHttpRequest !== "undefined") {
            if (!ENVIRONMENT_IS_WORKER)
              throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
            var lazyArray = new LazyUint8Array();
            Object.defineProperties(lazyArray, { length: { get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._length;
            } }, chunkSize: { get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._chunkSize;
            } } });
            var properties = { isDevice: false, contents: lazyArray };
          } else {
            var properties = { isDevice: false, url };
          }
          var node = FS.createFile(parent, name2, properties, canRead, canWrite);
          if (properties.contents) {
            node.contents = properties.contents;
          } else if (properties.url) {
            node.contents = null;
            node.url = properties.url;
          }
          Object.defineProperties(node, { usedBytes: { get: function() {
            return this.contents.length;
          } } });
          var stream_ops = {};
          var keys = Object.keys(node.stream_ops);
          keys.forEach(function(key2) {
            var fn = node.stream_ops[key2];
            stream_ops[key2] = function forceLoadLazyFile() {
              FS.forceLoadFile(node);
              return fn.apply(null, arguments);
            };
          });
          stream_ops.read = function stream_ops_read(stream, buffer2, offset, length, position) {
            FS.forceLoadFile(node);
            var contents = stream.node.contents;
            if (position >= contents.length)
              return 0;
            var size = Math.min(contents.length - position, length);
            if (contents.slice) {
              for (var i = 0; i < size; i++) {
                buffer2[offset + i] = contents[position + i];
              }
            } else {
              for (var i = 0; i < size; i++) {
                buffer2[offset + i] = contents.get(position + i);
              }
            }
            return size;
          };
          node.stream_ops = stream_ops;
          return node;
        }, createPreloadedFile: function(parent, name2, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
          Browser.init();
          var fullname = name2 ? PATH_FS.resolve(PATH.join2(parent, name2)) : parent;
          function processData(byteArray) {
            function finish(byteArray2) {
              if (preFinish)
                preFinish();
              if (!dontCreateFile) {
                FS.createDataFile(parent, name2, byteArray2, canRead, canWrite, canOwn);
              }
              if (onload)
                onload();
              removeRunDependency();
            }
            var handled = false;
            Module["preloadPlugins"].forEach(function(plugin) {
              if (handled)
                return;
              if (plugin["canHandle"](fullname)) {
                plugin["handle"](byteArray, fullname, finish, function() {
                  if (onerror)
                    onerror();
                  removeRunDependency();
                });
                handled = true;
              }
            });
            if (!handled)
              finish(byteArray);
          }
          addRunDependency();
          if (typeof url == "string") {
            asyncLoad(url, function(byteArray) {
              processData(byteArray);
            }, onerror);
          } else {
            processData(url);
          }
        }, indexedDB: function() {
          return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        }, DB_NAME: function() {
          return "EM_FS_" + window.location.pathname;
        }, DB_VERSION: 20, DB_STORE_NAME: "FILE_DATA", saveFilesToDB: function(paths, onload, onerror) {
          onload = onload || function() {
          };
          onerror = onerror || function() {
          };
          var indexedDB = FS.indexedDB();
          try {
            var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
          } catch (e) {
            return onerror(e);
          }
          openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
            out("creating db");
            var db = openRequest.result;
            db.createObjectStore(FS.DB_STORE_NAME);
          };
          openRequest.onsuccess = function openRequest_onsuccess() {
            var db = openRequest.result;
            var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
            var files = transaction.objectStore(FS.DB_STORE_NAME);
            var ok = 0, fail = 0, total = paths.length;
            function finish() {
              if (fail == 0)
                onload();
              else
                onerror();
            }
            paths.forEach(function(path) {
              var putRequest = files.put(FS.analyzePath(path).object.contents, path);
              putRequest.onsuccess = function putRequest_onsuccess() {
                ok++;
                if (ok + fail == total)
                  finish();
              };
              putRequest.onerror = function putRequest_onerror() {
                fail++;
                if (ok + fail == total)
                  finish();
              };
            });
            transaction.onerror = onerror;
          };
          openRequest.onerror = onerror;
        }, loadFilesFromDB: function(paths, onload, onerror) {
          onload = onload || function() {
          };
          onerror = onerror || function() {
          };
          var indexedDB = FS.indexedDB();
          try {
            var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
          } catch (e) {
            return onerror(e);
          }
          openRequest.onupgradeneeded = onerror;
          openRequest.onsuccess = function openRequest_onsuccess() {
            var db = openRequest.result;
            try {
              var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
            } catch (e) {
              onerror(e);
              return;
            }
            var files = transaction.objectStore(FS.DB_STORE_NAME);
            var ok = 0, fail = 0, total = paths.length;
            function finish() {
              if (fail == 0)
                onload();
              else
                onerror();
            }
            paths.forEach(function(path) {
              var getRequest = files.get(path);
              getRequest.onsuccess = function getRequest_onsuccess() {
                if (FS.analyzePath(path).exists) {
                  FS.unlink(path);
                }
                FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
                ok++;
                if (ok + fail == total)
                  finish();
              };
              getRequest.onerror = function getRequest_onerror() {
                fail++;
                if (ok + fail == total)
                  finish();
              };
            });
            transaction.onerror = onerror;
          };
          openRequest.onerror = onerror;
        } };
        var SYSCALLS = { mappings: {}, DEFAULT_POLLMASK: 5, umask: 511, calculateAt: function(dirfd, path, allowEmpty) {
          if (path[0] === "/") {
            return path;
          }
          var dir;
          if (dirfd === -100) {
            dir = FS.cwd();
          } else {
            var dirstream = FS.getStream(dirfd);
            if (!dirstream)
              throw new FS.ErrnoError(8);
            dir = dirstream.path;
          }
          if (path.length == 0) {
            if (!allowEmpty) {
              throw new FS.ErrnoError(44);
            }
            return dir;
          }
          return PATH.join2(dir, path);
        }, doStat: function(func, path, buf) {
          try {
            var stat = func(path);
          } catch (e) {
            if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
              return -54;
            }
            throw e;
          }
          GROWABLE_HEAP_I32()[buf >>> 2] = stat.dev;
          GROWABLE_HEAP_I32()[buf + 4 >>> 2] = 0;
          GROWABLE_HEAP_I32()[buf + 8 >>> 2] = stat.ino;
          GROWABLE_HEAP_I32()[buf + 12 >>> 2] = stat.mode;
          GROWABLE_HEAP_I32()[buf + 16 >>> 2] = stat.nlink;
          GROWABLE_HEAP_I32()[buf + 20 >>> 2] = stat.uid;
          GROWABLE_HEAP_I32()[buf + 24 >>> 2] = stat.gid;
          GROWABLE_HEAP_I32()[buf + 28 >>> 2] = stat.rdev;
          GROWABLE_HEAP_I32()[buf + 32 >>> 2] = 0;
          tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], GROWABLE_HEAP_I32()[buf + 40 >>> 2] = tempI64[0], GROWABLE_HEAP_I32()[buf + 44 >>> 2] = tempI64[1];
          GROWABLE_HEAP_I32()[buf + 48 >>> 2] = 4096;
          GROWABLE_HEAP_I32()[buf + 52 >>> 2] = stat.blocks;
          GROWABLE_HEAP_I32()[buf + 56 >>> 2] = stat.atime.getTime() / 1e3 | 0;
          GROWABLE_HEAP_I32()[buf + 60 >>> 2] = 0;
          GROWABLE_HEAP_I32()[buf + 64 >>> 2] = stat.mtime.getTime() / 1e3 | 0;
          GROWABLE_HEAP_I32()[buf + 68 >>> 2] = 0;
          GROWABLE_HEAP_I32()[buf + 72 >>> 2] = stat.ctime.getTime() / 1e3 | 0;
          GROWABLE_HEAP_I32()[buf + 76 >>> 2] = 0;
          tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], GROWABLE_HEAP_I32()[buf + 80 >>> 2] = tempI64[0], GROWABLE_HEAP_I32()[buf + 84 >>> 2] = tempI64[1];
          return 0;
        }, doMsync: function(addr, stream, len, flags, offset) {
          var buffer2 = GROWABLE_HEAP_U8().slice(addr, addr + len);
          FS.msync(stream, buffer2, offset, len, flags);
        }, doMkdir: function(path, mode) {
          path = PATH.normalize(path);
          if (path[path.length - 1] === "/")
            path = path.substr(0, path.length - 1);
          FS.mkdir(path, mode, 0);
          return 0;
        }, doMknod: function(path, mode, dev) {
          switch (mode & 61440) {
            case 32768:
            case 8192:
            case 24576:
            case 4096:
            case 49152:
              break;
            default:
              return -28;
          }
          FS.mknod(path, mode, dev);
          return 0;
        }, doReadlink: function(path, buf, bufsize) {
          if (bufsize <= 0)
            return -28;
          var ret = FS.readlink(path);
          var len = Math.min(bufsize, lengthBytesUTF8(ret));
          var endChar = GROWABLE_HEAP_I8()[buf + len >>> 0];
          stringToUTF8(ret, buf, bufsize + 1);
          GROWABLE_HEAP_I8()[buf + len >>> 0] = endChar;
          return len;
        }, doAccess: function(path, amode) {
          if (amode & ~7) {
            return -28;
          }
          var node;
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
          if (!node) {
            return -44;
          }
          var perms = "";
          if (amode & 4)
            perms += "r";
          if (amode & 2)
            perms += "w";
          if (amode & 1)
            perms += "x";
          if (perms && FS.nodePermissions(node, perms)) {
            return -2;
          }
          return 0;
        }, doDup: function(path, flags, suggestFD) {
          var suggest = FS.getStream(suggestFD);
          if (suggest)
            FS.close(suggest);
          return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
        }, doReadv: function(stream, iov, iovcnt, offset) {
          var ret = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = GROWABLE_HEAP_I32()[iov + i * 8 >>> 2];
            var len = GROWABLE_HEAP_I32()[iov + (i * 8 + 4) >>> 2];
            var curr = FS.read(stream, GROWABLE_HEAP_I8(), ptr, len, offset);
            if (curr < 0)
              return -1;
            ret += curr;
            if (curr < len)
              break;
          }
          return ret;
        }, doWritev: function(stream, iov, iovcnt, offset) {
          var ret = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = GROWABLE_HEAP_I32()[iov + i * 8 >>> 2];
            var len = GROWABLE_HEAP_I32()[iov + (i * 8 + 4) >>> 2];
            var curr = FS.write(stream, GROWABLE_HEAP_I8(), ptr, len, offset);
            if (curr < 0)
              return -1;
            ret += curr;
          }
          return ret;
        }, varargs: void 0, get: function() {
          SYSCALLS.varargs += 4;
          var ret = GROWABLE_HEAP_I32()[SYSCALLS.varargs - 4 >>> 2];
          return ret;
        }, getStr: function(ptr) {
          var ret = UTF8ToString(ptr);
          return ret;
        }, getStreamFromFD: function(fd) {
          var stream = FS.getStream(fd);
          if (!stream)
            throw new FS.ErrnoError(8);
          return stream;
        }, get64: function(low, high) {
          return low;
        } };
        function ___sys_fcntl64(fd, cmd, varargs) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(2, 1, fd, cmd, varargs);
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (cmd) {
              case 0: {
                var arg = SYSCALLS.get();
                if (arg < 0) {
                  return -28;
                }
                var newStream;
                newStream = FS.open(stream.path, stream.flags, 0, arg);
                return newStream.fd;
              }
              case 1:
              case 2:
                return 0;
              case 3:
                return stream.flags;
              case 4: {
                var arg = SYSCALLS.get();
                stream.flags |= arg;
                return 0;
              }
              case 12: {
                var arg = SYSCALLS.get();
                var offset = 0;
                GROWABLE_HEAP_I16()[arg + offset >>> 1] = 2;
                return 0;
              }
              case 13:
              case 14:
                return 0;
              case 16:
              case 8:
                return -28;
              case 9:
                setErrNo(28);
                return -1;
              default: {
                return -28;
              }
            }
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        function ___sys_ioctl(fd, op, varargs) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(3, 1, fd, op, varargs);
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (op) {
              case 21509:
              case 21505: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21510:
              case 21511:
              case 21512:
              case 21506:
              case 21507:
              case 21508: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21519: {
                if (!stream.tty)
                  return -59;
                var argp = SYSCALLS.get();
                GROWABLE_HEAP_I32()[argp >>> 2] = 0;
                return 0;
              }
              case 21520: {
                if (!stream.tty)
                  return -59;
                return -28;
              }
              case 21531: {
                var argp = SYSCALLS.get();
                return FS.ioctl(stream, op, argp);
              }
              case 21523: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21524: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              default:
                abort("bad ioctl syscall " + op);
            }
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        function ___sys_open(path, flags, varargs) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(4, 1, path, flags, varargs);
          SYSCALLS.varargs = varargs;
          try {
            var pathname = SYSCALLS.getStr(path);
            var mode = varargs ? SYSCALLS.get() : 0;
            var stream = FS.open(pathname, flags, mode);
            return stream.fd;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        var tupleRegistrations = {};
        function runDestructors(destructors) {
          while (destructors.length) {
            var ptr = destructors.pop();
            var del = destructors.pop();
            del(ptr);
          }
        }
        function simpleReadValueFromPointer(pointer) {
          return this["fromWireType"](GROWABLE_HEAP_U32()[pointer >>> 2]);
        }
        var awaitingDependencies = {};
        var registeredTypes = {};
        var typeDependencies = {};
        var char_0 = 48;
        var char_9 = 57;
        function makeLegalFunctionName(name2) {
          if (name2 === void 0) {
            return "_unknown";
          }
          name2 = name2.replace(/[^a-zA-Z0-9_]/g, "$");
          var f = name2.charCodeAt(0);
          if (f >= char_0 && f <= char_9) {
            return "_" + name2;
          } else {
            return name2;
          }
        }
        function createNamedFunction(name2, body) {
          name2 = makeLegalFunctionName(name2);
          return new Function("body", "return function " + name2 + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(body);
        }
        function extendError(baseErrorType, errorName) {
          var errorClass = createNamedFunction(errorName, function(message) {
            this.name = errorName;
            this.message = message;
            var stack = new Error(message).stack;
            if (stack !== void 0) {
              this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
            }
          });
          errorClass.prototype = Object.create(baseErrorType.prototype);
          errorClass.prototype.constructor = errorClass;
          errorClass.prototype.toString = function() {
            if (this.message === void 0) {
              return this.name;
            } else {
              return this.name + ": " + this.message;
            }
          };
          return errorClass;
        }
        var InternalError = void 0;
        function throwInternalError(message) {
          throw new InternalError(message);
        }
        function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
          myTypes.forEach(function(type) {
            typeDependencies[type] = dependentTypes;
          });
          function onComplete(typeConverters2) {
            var myTypeConverters = getTypeConverters(typeConverters2);
            if (myTypeConverters.length !== myTypes.length) {
              throwInternalError("Mismatched type converter count");
            }
            for (var i = 0; i < myTypes.length; ++i) {
              registerType(myTypes[i], myTypeConverters[i]);
            }
          }
          var typeConverters = new Array(dependentTypes.length);
          var unregisteredTypes = [];
          var registered = 0;
          dependentTypes.forEach(function(dt, i) {
            if (registeredTypes.hasOwnProperty(dt)) {
              typeConverters[i] = registeredTypes[dt];
            } else {
              unregisteredTypes.push(dt);
              if (!awaitingDependencies.hasOwnProperty(dt)) {
                awaitingDependencies[dt] = [];
              }
              awaitingDependencies[dt].push(function() {
                typeConverters[i] = registeredTypes[dt];
                ++registered;
                if (registered === unregisteredTypes.length) {
                  onComplete(typeConverters);
                }
              });
            }
          });
          if (unregisteredTypes.length === 0) {
            onComplete(typeConverters);
          }
        }
        function __embind_finalize_value_array(rawTupleType) {
          var reg = tupleRegistrations[rawTupleType];
          delete tupleRegistrations[rawTupleType];
          var elements = reg.elements;
          var elementsLength = elements.length;
          var elementTypes = elements.map(function(elt) {
            return elt.getterReturnType;
          }).concat(elements.map(function(elt) {
            return elt.setterArgumentType;
          }));
          var rawConstructor = reg.rawConstructor;
          var rawDestructor = reg.rawDestructor;
          whenDependentTypesAreResolved([rawTupleType], elementTypes, function(elementTypes2) {
            elements.forEach(function(elt, i) {
              var getterReturnType = elementTypes2[i];
              var getter = elt.getter;
              var getterContext = elt.getterContext;
              var setterArgumentType = elementTypes2[i + elementsLength];
              var setter = elt.setter;
              var setterContext = elt.setterContext;
              elt.read = function(ptr) {
                return getterReturnType["fromWireType"](getter(getterContext, ptr));
              };
              elt.write = function(ptr, o) {
                var destructors = [];
                setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                runDestructors(destructors);
              };
            });
            return [{ name: reg.name, "fromWireType": function(ptr) {
              var rv = new Array(elementsLength);
              for (var i = 0; i < elementsLength; ++i) {
                rv[i] = elements[i].read(ptr);
              }
              rawDestructor(ptr);
              return rv;
            }, "toWireType": function(destructors, o) {
              if (elementsLength !== o.length) {
                throw new TypeError("Incorrect number of tuple elements for " + reg.name + ": expected=" + elementsLength + ", actual=" + o.length);
              }
              var ptr = rawConstructor();
              for (var i = 0; i < elementsLength; ++i) {
                elements[i].write(ptr, o[i]);
              }
              if (destructors !== null) {
                destructors.push(rawDestructor, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: rawDestructor }];
          });
        }
        var structRegistrations = {};
        function __embind_finalize_value_object(structType) {
          var reg = structRegistrations[structType];
          delete structRegistrations[structType];
          var rawConstructor = reg.rawConstructor;
          var rawDestructor = reg.rawDestructor;
          var fieldRecords = reg.fields;
          var fieldTypes = fieldRecords.map(function(field) {
            return field.getterReturnType;
          }).concat(fieldRecords.map(function(field) {
            return field.setterArgumentType;
          }));
          whenDependentTypesAreResolved([structType], fieldTypes, function(fieldTypes2) {
            var fields = {};
            fieldRecords.forEach(function(field, i) {
              var fieldName = field.fieldName;
              var getterReturnType = fieldTypes2[i];
              var getter = field.getter;
              var getterContext = field.getterContext;
              var setterArgumentType = fieldTypes2[i + fieldRecords.length];
              var setter = field.setter;
              var setterContext = field.setterContext;
              fields[fieldName] = { read: function(ptr) {
                return getterReturnType["fromWireType"](getter(getterContext, ptr));
              }, write: function(ptr, o) {
                var destructors = [];
                setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                runDestructors(destructors);
              } };
            });
            return [{ name: reg.name, "fromWireType": function(ptr) {
              var rv = {};
              for (var i in fields) {
                rv[i] = fields[i].read(ptr);
              }
              rawDestructor(ptr);
              return rv;
            }, "toWireType": function(destructors, o) {
              for (var fieldName in fields) {
                if (!(fieldName in o)) {
                  throw new TypeError('Missing field:  "' + fieldName + '"');
                }
              }
              var ptr = rawConstructor();
              for (fieldName in fields) {
                fields[fieldName].write(ptr, o[fieldName]);
              }
              if (destructors !== null) {
                destructors.push(rawDestructor, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: rawDestructor }];
          });
        }
        function __embind_register_bigint(primitiveType, name2, size, minRange, maxRange) {
        }
        function getShiftFromSize(size) {
          switch (size) {
            case 1:
              return 0;
            case 2:
              return 1;
            case 4:
              return 2;
            case 8:
              return 3;
            default:
              throw new TypeError("Unknown type size: " + size);
          }
        }
        function embind_init_charCodes() {
          var codes = new Array(256);
          for (var i = 0; i < 256; ++i) {
            codes[i] = String.fromCharCode(i);
          }
          embind_charCodes = codes;
        }
        var embind_charCodes = void 0;
        function readLatin1String(ptr) {
          var ret = "";
          var c = ptr;
          while (GROWABLE_HEAP_U8()[c >>> 0]) {
            ret += embind_charCodes[GROWABLE_HEAP_U8()[c++ >>> 0]];
          }
          return ret;
        }
        var BindingError = void 0;
        function throwBindingError(message) {
          throw new BindingError(message);
        }
        function registerType(rawType, registeredInstance, options) {
          options = options || {};
          if (!("argPackAdvance" in registeredInstance)) {
            throw new TypeError("registerType registeredInstance requires argPackAdvance");
          }
          var name2 = registeredInstance.name;
          if (!rawType) {
            throwBindingError('type "' + name2 + '" must have a positive integer typeid pointer');
          }
          if (registeredTypes.hasOwnProperty(rawType)) {
            if (options.ignoreDuplicateRegistrations) {
              return;
            } else {
              throwBindingError("Cannot register type '" + name2 + "' twice");
            }
          }
          registeredTypes[rawType] = registeredInstance;
          delete typeDependencies[rawType];
          if (awaitingDependencies.hasOwnProperty(rawType)) {
            var callbacks = awaitingDependencies[rawType];
            delete awaitingDependencies[rawType];
            callbacks.forEach(function(cb) {
              cb();
            });
          }
        }
        function __embind_register_bool(rawType, name2, size, trueValue, falseValue) {
          var shift = getShiftFromSize(size);
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": function(wt) {
            return !!wt;
          }, "toWireType": function(destructors, o) {
            return o ? trueValue : falseValue;
          }, "argPackAdvance": 8, "readValueFromPointer": function(pointer) {
            var heap;
            if (size === 1) {
              heap = GROWABLE_HEAP_I8();
            } else if (size === 2) {
              heap = GROWABLE_HEAP_I16();
            } else if (size === 4) {
              heap = GROWABLE_HEAP_I32();
            } else {
              throw new TypeError("Unknown boolean type size: " + name2);
            }
            return this["fromWireType"](heap[pointer >>> shift]);
          }, destructorFunction: null });
        }
        function ClassHandle_isAliasOf(other) {
          if (!(this instanceof ClassHandle)) {
            return false;
          }
          if (!(other instanceof ClassHandle)) {
            return false;
          }
          var leftClass = this.$$.ptrType.registeredClass;
          var left = this.$$.ptr;
          var rightClass = other.$$.ptrType.registeredClass;
          var right = other.$$.ptr;
          while (leftClass.baseClass) {
            left = leftClass.upcast(left);
            leftClass = leftClass.baseClass;
          }
          while (rightClass.baseClass) {
            right = rightClass.upcast(right);
            rightClass = rightClass.baseClass;
          }
          return leftClass === rightClass && left === right;
        }
        function shallowCopyInternalPointer(o) {
          return { count: o.count, deleteScheduled: o.deleteScheduled, preservePointerOnDelete: o.preservePointerOnDelete, ptr: o.ptr, ptrType: o.ptrType, smartPtr: o.smartPtr, smartPtrType: o.smartPtrType };
        }
        function throwInstanceAlreadyDeleted(obj) {
          function getInstanceTypeName(handle) {
            return handle.$$.ptrType.registeredClass.name;
          }
          throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
        }
        var finalizationGroup = false;
        function detachFinalizer(handle) {
        }
        function runDestructor($$) {
          if ($$.smartPtr) {
            $$.smartPtrType.rawDestructor($$.smartPtr);
          } else {
            $$.ptrType.registeredClass.rawDestructor($$.ptr);
          }
        }
        function releaseClassHandle($$) {
          $$.count.value -= 1;
          var toDelete = $$.count.value === 0;
          if (toDelete) {
            runDestructor($$);
          }
        }
        function attachFinalizer(handle) {
          if (typeof FinalizationGroup === "undefined") {
            attachFinalizer = function(handle2) {
              return handle2;
            };
            return handle;
          }
          finalizationGroup = new FinalizationGroup(function(iter) {
            for (var result = iter.next(); !result.done; result = iter.next()) {
              var $$ = result.value;
              if (!$$.ptr) {
                console.warn("object already deleted: " + $$.ptr);
              } else {
                releaseClassHandle($$);
              }
            }
          });
          attachFinalizer = function(handle2) {
            finalizationGroup.register(handle2, handle2.$$, handle2.$$);
            return handle2;
          };
          detachFinalizer = function(handle2) {
            finalizationGroup.unregister(handle2.$$);
          };
          return attachFinalizer(handle);
        }
        function ClassHandle_clone() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.preservePointerOnDelete) {
            this.$$.count.value += 1;
            return this;
          } else {
            var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), { $$: { value: shallowCopyInternalPointer(this.$$) } }));
            clone.$$.count.value += 1;
            clone.$$.deleteScheduled = false;
            return clone;
          }
        }
        function ClassHandle_delete() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
            throwBindingError("Object already scheduled for deletion");
          }
          detachFinalizer(this);
          releaseClassHandle(this.$$);
          if (!this.$$.preservePointerOnDelete) {
            this.$$.smartPtr = void 0;
            this.$$.ptr = void 0;
          }
        }
        function ClassHandle_isDeleted() {
          return !this.$$.ptr;
        }
        var delayFunction = void 0;
        var deletionQueue = [];
        function flushPendingDeletes() {
          while (deletionQueue.length) {
            var obj = deletionQueue.pop();
            obj.$$.deleteScheduled = false;
            obj["delete"]();
          }
        }
        function ClassHandle_deleteLater() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
            throwBindingError("Object already scheduled for deletion");
          }
          deletionQueue.push(this);
          if (deletionQueue.length === 1 && delayFunction) {
            delayFunction(flushPendingDeletes);
          }
          this.$$.deleteScheduled = true;
          return this;
        }
        function init_ClassHandle() {
          ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;
          ClassHandle.prototype["clone"] = ClassHandle_clone;
          ClassHandle.prototype["delete"] = ClassHandle_delete;
          ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;
          ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
        }
        function ClassHandle() {
        }
        var registeredPointers = {};
        function ensureOverloadTable(proto, methodName, humanName) {
          if (proto[methodName].overloadTable === void 0) {
            var prevFunc = proto[methodName];
            proto[methodName] = function() {
              if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
              }
              return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
            };
            proto[methodName].overloadTable = [];
            proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
          }
        }
        function exposePublicSymbol(name2, value, numArguments) {
          if (Module.hasOwnProperty(name2)) {
            if (numArguments === void 0 || Module[name2].overloadTable !== void 0 && Module[name2].overloadTable[numArguments] !== void 0) {
              throwBindingError("Cannot register public name '" + name2 + "' twice");
            }
            ensureOverloadTable(Module, name2, name2);
            if (Module.hasOwnProperty(numArguments)) {
              throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
            }
            Module[name2].overloadTable[numArguments] = value;
          } else {
            Module[name2] = value;
            if (numArguments !== void 0) {
              Module[name2].numArguments = numArguments;
            }
          }
        }
        function RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
          this.name = name2;
          this.constructor = constructor;
          this.instancePrototype = instancePrototype;
          this.rawDestructor = rawDestructor;
          this.baseClass = baseClass;
          this.getActualType = getActualType;
          this.upcast = upcast;
          this.downcast = downcast;
          this.pureVirtualFunctions = [];
        }
        function upcastPointer(ptr, ptrClass, desiredClass) {
          while (ptrClass !== desiredClass) {
            if (!ptrClass.upcast) {
              throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
            }
            ptr = ptrClass.upcast(ptr);
            ptrClass = ptrClass.baseClass;
          }
          return ptr;
        }
        function constNoSmartPtrRawPointerToWireType(destructors, handle) {
          if (handle === null) {
            if (this.isReference) {
              throwBindingError("null is not a valid " + this.name);
            }
            return 0;
          }
          if (!handle.$$) {
            throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
          }
          if (!handle.$$.ptr) {
            throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          return ptr;
        }
        function genericPointerToWireType(destructors, handle) {
          var ptr;
          if (handle === null) {
            if (this.isReference) {
              throwBindingError("null is not a valid " + this.name);
            }
            if (this.isSmartPointer) {
              ptr = this.rawConstructor();
              if (destructors !== null) {
                destructors.push(this.rawDestructor, ptr);
              }
              return ptr;
            } else {
              return 0;
            }
          }
          if (!handle.$$) {
            throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
          }
          if (!handle.$$.ptr) {
            throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
          }
          if (!this.isConst && handle.$$.ptrType.isConst) {
            throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          if (this.isSmartPointer) {
            if (handle.$$.smartPtr === void 0) {
              throwBindingError("Passing raw pointer to smart pointer is illegal");
            }
            switch (this.sharingPolicy) {
              case 0:
                if (handle.$$.smartPtrType === this) {
                  ptr = handle.$$.smartPtr;
                } else {
                  throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
                }
                break;
              case 1:
                ptr = handle.$$.smartPtr;
                break;
              case 2:
                if (handle.$$.smartPtrType === this) {
                  ptr = handle.$$.smartPtr;
                } else {
                  var clonedHandle = handle["clone"]();
                  ptr = this.rawShare(ptr, __emval_register(function() {
                    clonedHandle["delete"]();
                  }));
                  if (destructors !== null) {
                    destructors.push(this.rawDestructor, ptr);
                  }
                }
                break;
              default:
                throwBindingError("Unsupporting sharing policy");
            }
          }
          return ptr;
        }
        function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
          if (handle === null) {
            if (this.isReference) {
              throwBindingError("null is not a valid " + this.name);
            }
            return 0;
          }
          if (!handle.$$) {
            throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
          }
          if (!handle.$$.ptr) {
            throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
          }
          if (handle.$$.ptrType.isConst) {
            throwBindingError("Cannot convert argument of type " + handle.$$.ptrType.name + " to parameter type " + this.name);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          return ptr;
        }
        function RegisteredPointer_getPointee(ptr) {
          if (this.rawGetPointee) {
            ptr = this.rawGetPointee(ptr);
          }
          return ptr;
        }
        function RegisteredPointer_destructor(ptr) {
          if (this.rawDestructor) {
            this.rawDestructor(ptr);
          }
        }
        function RegisteredPointer_deleteObject(handle) {
          if (handle !== null) {
            handle["delete"]();
          }
        }
        function downcastPointer(ptr, ptrClass, desiredClass) {
          if (ptrClass === desiredClass) {
            return ptr;
          }
          if (desiredClass.baseClass === void 0) {
            return null;
          }
          var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
          if (rv === null) {
            return null;
          }
          return desiredClass.downcast(rv);
        }
        function getInheritedInstanceCount() {
          return Object.keys(registeredInstances).length;
        }
        function getLiveInheritedInstances() {
          var rv = [];
          for (var k in registeredInstances) {
            if (registeredInstances.hasOwnProperty(k)) {
              rv.push(registeredInstances[k]);
            }
          }
          return rv;
        }
        function setDelayFunction(fn) {
          delayFunction = fn;
          if (deletionQueue.length && delayFunction) {
            delayFunction(flushPendingDeletes);
          }
        }
        function init_embind() {
          Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
          Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
          Module["flushPendingDeletes"] = flushPendingDeletes;
          Module["setDelayFunction"] = setDelayFunction;
        }
        var registeredInstances = {};
        function getBasestPointer(class_, ptr) {
          if (ptr === void 0) {
            throwBindingError("ptr should not be undefined");
          }
          while (class_.baseClass) {
            ptr = class_.upcast(ptr);
            class_ = class_.baseClass;
          }
          return ptr;
        }
        function getInheritedInstance(class_, ptr) {
          ptr = getBasestPointer(class_, ptr);
          return registeredInstances[ptr];
        }
        function makeClassHandle(prototype, record) {
          if (!record.ptrType || !record.ptr) {
            throwInternalError("makeClassHandle requires ptr and ptrType");
          }
          var hasSmartPtrType = !!record.smartPtrType;
          var hasSmartPtr = !!record.smartPtr;
          if (hasSmartPtrType !== hasSmartPtr) {
            throwInternalError("Both smartPtrType and smartPtr must be specified");
          }
          record.count = { value: 1 };
          return attachFinalizer(Object.create(prototype, { $$: { value: record } }));
        }
        function RegisteredPointer_fromWireType(ptr) {
          var rawPointer = this.getPointee(ptr);
          if (!rawPointer) {
            this.destructor(ptr);
            return null;
          }
          var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
          if (registeredInstance !== void 0) {
            if (registeredInstance.$$.count.value === 0) {
              registeredInstance.$$.ptr = rawPointer;
              registeredInstance.$$.smartPtr = ptr;
              return registeredInstance["clone"]();
            } else {
              var rv = registeredInstance["clone"]();
              this.destructor(ptr);
              return rv;
            }
          }
          function makeDefaultHandle() {
            if (this.isSmartPointer) {
              return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: rawPointer, smartPtrType: this, smartPtr: ptr });
            } else {
              return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this, ptr });
            }
          }
          var actualType = this.registeredClass.getActualType(rawPointer);
          var registeredPointerRecord = registeredPointers[actualType];
          if (!registeredPointerRecord) {
            return makeDefaultHandle.call(this);
          }
          var toType;
          if (this.isConst) {
            toType = registeredPointerRecord.constPointerType;
          } else {
            toType = registeredPointerRecord.pointerType;
          }
          var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
          if (dp === null) {
            return makeDefaultHandle.call(this);
          }
          if (this.isSmartPointer) {
            return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp, smartPtrType: this, smartPtr: ptr });
          } else {
            return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp });
          }
        }
        function init_RegisteredPointer() {
          RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
          RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
          RegisteredPointer.prototype["argPackAdvance"] = 8;
          RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;
          RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;
          RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
        }
        function RegisteredPointer(name2, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
          this.name = name2;
          this.registeredClass = registeredClass;
          this.isReference = isReference;
          this.isConst = isConst;
          this.isSmartPointer = isSmartPointer;
          this.pointeeType = pointeeType;
          this.sharingPolicy = sharingPolicy;
          this.rawGetPointee = rawGetPointee;
          this.rawConstructor = rawConstructor;
          this.rawShare = rawShare;
          this.rawDestructor = rawDestructor;
          if (!isSmartPointer && registeredClass.baseClass === void 0) {
            if (isConst) {
              this["toWireType"] = constNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            } else {
              this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            }
          } else {
            this["toWireType"] = genericPointerToWireType;
          }
        }
        function replacePublicSymbol(name2, value, numArguments) {
          if (!Module.hasOwnProperty(name2)) {
            throwInternalError("Replacing nonexistant public symbol");
          }
          if (Module[name2].overloadTable !== void 0 && numArguments !== void 0) {
            Module[name2].overloadTable[numArguments] = value;
          } else {
            Module[name2] = value;
            Module[name2].argCount = numArguments;
          }
        }
        function dynCallLegacy(sig, ptr, args) {
          var f = Module["dynCall_" + sig];
          return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);
        }
        function dynCall(sig, ptr, args) {
          if (sig.includes("j")) {
            return dynCallLegacy(sig, ptr, args);
          }
          return wasmTable.get(ptr).apply(null, args);
        }
        function getDynCaller(sig, ptr) {
          var argCache = [];
          return function() {
            argCache.length = arguments.length;
            for (var i = 0; i < arguments.length; i++) {
              argCache[i] = arguments[i];
            }
            return dynCall(sig, ptr, argCache);
          };
        }
        function embind__requireFunction(signature, rawFunction) {
          signature = readLatin1String(signature);
          function makeDynCaller() {
            if (signature.includes("j")) {
              return getDynCaller(signature, rawFunction);
            }
            return wasmTable.get(rawFunction);
          }
          var fp = makeDynCaller();
          if (typeof fp !== "function") {
            throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
          }
          return fp;
        }
        var UnboundTypeError = void 0;
        function getTypeName(type) {
          var ptr = ___getTypeName(type);
          var rv = readLatin1String(ptr);
          _free(ptr);
          return rv;
        }
        function throwUnboundTypeError(message, types) {
          var unboundTypes = [];
          var seen = {};
          function visit(type) {
            if (seen[type]) {
              return;
            }
            if (registeredTypes[type]) {
              return;
            }
            if (typeDependencies[type]) {
              typeDependencies[type].forEach(visit);
              return;
            }
            unboundTypes.push(type);
            seen[type] = true;
          }
          types.forEach(visit);
          throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([", "]));
        }
        function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name2, destructorSignature, rawDestructor) {
          name2 = readLatin1String(name2);
          getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
          if (upcast) {
            upcast = embind__requireFunction(upcastSignature, upcast);
          }
          if (downcast) {
            downcast = embind__requireFunction(downcastSignature, downcast);
          }
          rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
          var legalFunctionName = makeLegalFunctionName(name2);
          exposePublicSymbol(legalFunctionName, function() {
            throwUnboundTypeError("Cannot construct " + name2 + " due to unbound types", [baseClassRawType]);
          });
          whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function(base) {
            base = base[0];
            var baseClass;
            var basePrototype;
            if (baseClassRawType) {
              baseClass = base.registeredClass;
              basePrototype = baseClass.instancePrototype;
            } else {
              basePrototype = ClassHandle.prototype;
            }
            var constructor = createNamedFunction(legalFunctionName, function() {
              if (Object.getPrototypeOf(this) !== instancePrototype) {
                throw new BindingError("Use 'new' to construct " + name2);
              }
              if (registeredClass.constructor_body === void 0) {
                throw new BindingError(name2 + " has no accessible constructor");
              }
              var body = registeredClass.constructor_body[arguments.length];
              if (body === void 0) {
                throw new BindingError("Tried to invoke ctor of " + name2 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
              }
              return body.apply(this, arguments);
            });
            var instancePrototype = Object.create(basePrototype, { constructor: { value: constructor } });
            constructor.prototype = instancePrototype;
            var registeredClass = new RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
            var referenceConverter = new RegisteredPointer(name2, registeredClass, true, false, false);
            var pointerConverter = new RegisteredPointer(name2 + "*", registeredClass, false, false, false);
            var constPointerConverter = new RegisteredPointer(name2 + " const*", registeredClass, false, true, false);
            registeredPointers[rawType] = { pointerType: pointerConverter, constPointerType: constPointerConverter };
            replacePublicSymbol(legalFunctionName, constructor);
            return [referenceConverter, pointerConverter, constPointerConverter];
          });
        }
        function heap32VectorToArray(count, firstElement) {
          var array = [];
          for (var i = 0; i < count; i++) {
            array.push(GROWABLE_HEAP_I32()[(firstElement >> 2) + i >>> 0]);
          }
          return array;
        }
        function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
          assert(argCount > 0);
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          invoker = embind__requireFunction(invokerSignature, invoker);
          var args = [rawConstructor];
          var destructors = [];
          whenDependentTypesAreResolved([], [rawClassType], function(classType) {
            classType = classType[0];
            var humanName = "constructor " + classType.name;
            if (classType.registeredClass.constructor_body === void 0) {
              classType.registeredClass.constructor_body = [];
            }
            if (classType.registeredClass.constructor_body[argCount - 1] !== void 0) {
              throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount - 1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
            }
            classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {
              throwUnboundTypeError("Cannot construct " + classType.name + " due to unbound types", rawArgTypes);
            };
            whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
              classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {
                if (arguments.length !== argCount - 1) {
                  throwBindingError(humanName + " called with " + arguments.length + " arguments, expected " + (argCount - 1));
                }
                destructors.length = 0;
                args.length = argCount;
                for (var i = 1; i < argCount; ++i) {
                  args[i] = argTypes[i]["toWireType"](destructors, arguments[i - 1]);
                }
                var ptr = invoker.apply(null, args);
                runDestructors(destructors);
                return argTypes[0]["fromWireType"](ptr);
              };
              return [];
            });
            return [];
          });
        }
        function new_(constructor, argumentList) {
          if (!(constructor instanceof Function)) {
            throw new TypeError("new_ called with constructor type " + typeof constructor + " which is not a function");
          }
          var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {
          });
          dummy.prototype = constructor.prototype;
          var obj = new dummy();
          var r = constructor.apply(obj, argumentList);
          return r instanceof Object ? r : obj;
        }
        function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
          var argCount = argTypes.length;
          if (argCount < 2) {
            throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
          }
          var isClassMethodFunc = argTypes[1] !== null && classType !== null;
          var needsDestructorStack = false;
          for (var i = 1; i < argTypes.length; ++i) {
            if (argTypes[i] !== null && argTypes[i].destructorFunction === void 0) {
              needsDestructorStack = true;
              break;
            }
          }
          var returns = argTypes[0].name !== "void";
          var argsList = "";
          var argsListWired = "";
          for (var i = 0; i < argCount - 2; ++i) {
            argsList += (i !== 0 ? ", " : "") + "arg" + i;
            argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
          }
          var invokerFnBody = "return function " + makeLegalFunctionName(humanName) + "(" + argsList + ") {\nif (arguments.length !== " + (argCount - 2) + ") {\nthrowBindingError('function " + humanName + " called with ' + arguments.length + ' arguments, expected " + (argCount - 2) + " args!');\n}\n";
          if (needsDestructorStack) {
            invokerFnBody += "var destructors = [];\n";
          }
          var dtorStack = needsDestructorStack ? "destructors" : "null";
          var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
          var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
          if (isClassMethodFunc) {
            invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
          }
          for (var i = 0; i < argCount - 2; ++i) {
            invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
            args1.push("argType" + i);
            args2.push(argTypes[i + 2]);
          }
          if (isClassMethodFunc) {
            argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
          }
          invokerFnBody += (returns ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
          if (needsDestructorStack) {
            invokerFnBody += "runDestructors(destructors);\n";
          } else {
            for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
              var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
              if (argTypes[i].destructorFunction !== null) {
                invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
                args1.push(paramName + "_dtor");
                args2.push(argTypes[i].destructorFunction);
              }
            }
          }
          if (returns) {
            invokerFnBody += "var ret = retType.fromWireType(rv);\nreturn ret;\n";
          }
          invokerFnBody += "}\n";
          args1.push(invokerFnBody);
          var invokerFunction = new_(Function, args1).apply(null, args2);
          return invokerFunction;
        }
        function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          methodName = readLatin1String(methodName);
          rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
          whenDependentTypesAreResolved([], [rawClassType], function(classType) {
            classType = classType[0];
            var humanName = classType.name + "." + methodName;
            if (methodName.startsWith("@@")) {
              methodName = Symbol[methodName.substring(2)];
            }
            if (isPureVirtual) {
              classType.registeredClass.pureVirtualFunctions.push(methodName);
            }
            function unboundTypesHandler() {
              throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
            }
            var proto = classType.registeredClass.instancePrototype;
            var method = proto[methodName];
            if (method === void 0 || method.overloadTable === void 0 && method.className !== classType.name && method.argCount === argCount - 2) {
              unboundTypesHandler.argCount = argCount - 2;
              unboundTypesHandler.className = classType.name;
              proto[methodName] = unboundTypesHandler;
            } else {
              ensureOverloadTable(proto, methodName, humanName);
              proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
            }
            whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
              var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
              if (proto[methodName].overloadTable === void 0) {
                memberFunction.argCount = argCount - 2;
                proto[methodName] = memberFunction;
              } else {
                proto[methodName].overloadTable[argCount - 2] = memberFunction;
              }
              return [];
            });
            return [];
          });
        }
        var emval_free_list = [];
        var emval_handle_array = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];
        function __emval_decref(handle) {
          if (handle > 4 && --emval_handle_array[handle].refcount === 0) {
            emval_handle_array[handle] = void 0;
            emval_free_list.push(handle);
          }
        }
        function count_emval_handles() {
          var count = 0;
          for (var i = 5; i < emval_handle_array.length; ++i) {
            if (emval_handle_array[i] !== void 0) {
              ++count;
            }
          }
          return count;
        }
        function get_first_emval() {
          for (var i = 5; i < emval_handle_array.length; ++i) {
            if (emval_handle_array[i] !== void 0) {
              return emval_handle_array[i];
            }
          }
          return null;
        }
        function init_emval() {
          Module["count_emval_handles"] = count_emval_handles;
          Module["get_first_emval"] = get_first_emval;
        }
        function __emval_register(value) {
          switch (value) {
            case void 0: {
              return 1;
            }
            case null: {
              return 2;
            }
            case true: {
              return 3;
            }
            case false: {
              return 4;
            }
            default: {
              var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
              emval_handle_array[handle] = { refcount: 1, value };
              return handle;
            }
          }
        }
        function __embind_register_emval(rawType, name2) {
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": function(handle) {
            var rv = emval_handle_array[handle].value;
            __emval_decref(handle);
            return rv;
          }, "toWireType": function(destructors, value) {
            return __emval_register(value);
          }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: null });
        }
        function enumReadValueFromPointer(name2, shift, signed) {
          switch (shift) {
            case 0:
              return function(pointer) {
                var heap = signed ? GROWABLE_HEAP_I8() : GROWABLE_HEAP_U8();
                return this["fromWireType"](heap[pointer >>> 0]);
              };
            case 1:
              return function(pointer) {
                var heap = signed ? GROWABLE_HEAP_I16() : GROWABLE_HEAP_U16();
                return this["fromWireType"](heap[pointer >>> 1]);
              };
            case 2:
              return function(pointer) {
                var heap = signed ? GROWABLE_HEAP_I32() : GROWABLE_HEAP_U32();
                return this["fromWireType"](heap[pointer >>> 2]);
              };
            default:
              throw new TypeError("Unknown integer type: " + name2);
          }
        }
        function __embind_register_enum(rawType, name2, size, isSigned) {
          var shift = getShiftFromSize(size);
          name2 = readLatin1String(name2);
          function ctor() {
          }
          ctor.values = {};
          registerType(rawType, { name: name2, constructor: ctor, "fromWireType": function(c) {
            return this.constructor.values[c];
          }, "toWireType": function(destructors, c) {
            return c.value;
          }, "argPackAdvance": 8, "readValueFromPointer": enumReadValueFromPointer(name2, shift, isSigned), destructorFunction: null });
          exposePublicSymbol(name2, ctor);
        }
        function requireRegisteredType(rawType, humanName) {
          var impl = registeredTypes[rawType];
          if (impl === void 0) {
            throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
          }
          return impl;
        }
        function __embind_register_enum_value(rawEnumType, name2, enumValue) {
          var enumType = requireRegisteredType(rawEnumType, "enum");
          name2 = readLatin1String(name2);
          var Enum = enumType.constructor;
          var Value2 = Object.create(enumType.constructor.prototype, { value: { value: enumValue }, constructor: { value: createNamedFunction(enumType.name + "_" + name2, function() {
          }) } });
          Enum.values[enumValue] = Value2;
          Enum[name2] = Value2;
        }
        function _embind_repr(v) {
          if (v === null) {
            return "null";
          }
          var t = typeof v;
          if (t === "object" || t === "array" || t === "function") {
            return v.toString();
          } else {
            return "" + v;
          }
        }
        function floatReadValueFromPointer(name2, shift) {
          switch (shift) {
            case 2:
              return function(pointer) {
                return this["fromWireType"](GROWABLE_HEAP_F32()[pointer >>> 2]);
              };
            case 3:
              return function(pointer) {
                return this["fromWireType"](GROWABLE_HEAP_F64()[pointer >>> 3]);
              };
            default:
              throw new TypeError("Unknown float type: " + name2);
          }
        }
        function __embind_register_float(rawType, name2, size) {
          var shift = getShiftFromSize(size);
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": function(value) {
            return value;
          }, "toWireType": function(destructors, value) {
            if (typeof value !== "number" && typeof value !== "boolean") {
              throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
            }
            return value;
          }, "argPackAdvance": 8, "readValueFromPointer": floatReadValueFromPointer(name2, shift), destructorFunction: null });
        }
        function __embind_register_function(name2, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {
          var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          name2 = readLatin1String(name2);
          rawInvoker = embind__requireFunction(signature, rawInvoker);
          exposePublicSymbol(name2, function() {
            throwUnboundTypeError("Cannot call " + name2 + " due to unbound types", argTypes);
          }, argCount - 1);
          whenDependentTypesAreResolved([], argTypes, function(argTypes2) {
            var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));
            replacePublicSymbol(name2, craftInvokerFunction(name2, invokerArgsArray, null, rawInvoker, fn), argCount - 1);
            return [];
          });
        }
        function integerReadValueFromPointer(name2, shift, signed) {
          switch (shift) {
            case 0:
              return signed ? function readS8FromPointer(pointer) {
                return GROWABLE_HEAP_I8()[pointer >>> 0];
              } : function readU8FromPointer(pointer) {
                return GROWABLE_HEAP_U8()[pointer >>> 0];
              };
            case 1:
              return signed ? function readS16FromPointer(pointer) {
                return GROWABLE_HEAP_I16()[pointer >>> 1];
              } : function readU16FromPointer(pointer) {
                return GROWABLE_HEAP_U16()[pointer >>> 1];
              };
            case 2:
              return signed ? function readS32FromPointer(pointer) {
                return GROWABLE_HEAP_I32()[pointer >>> 2];
              } : function readU32FromPointer(pointer) {
                return GROWABLE_HEAP_U32()[pointer >>> 2];
              };
            default:
              throw new TypeError("Unknown integer type: " + name2);
          }
        }
        function __embind_register_integer(primitiveType, name2, size, minRange, maxRange) {
          name2 = readLatin1String(name2);
          if (maxRange === -1) {
            maxRange = 4294967295;
          }
          var shift = getShiftFromSize(size);
          var fromWireType = function(value) {
            return value;
          };
          if (minRange === 0) {
            var bitshift = 32 - 8 * size;
            fromWireType = function(value) {
              return value << bitshift >>> bitshift;
            };
          }
          var isUnsignedType = name2.includes("unsigned");
          registerType(primitiveType, { name: name2, "fromWireType": fromWireType, "toWireType": function(destructors, value) {
            if (typeof value !== "number" && typeof value !== "boolean") {
              throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
            }
            if (value < minRange || value > maxRange) {
              throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name2 + '", which is outside the valid range [' + minRange + ", " + maxRange + "]!");
            }
            return isUnsignedType ? value >>> 0 : value | 0;
          }, "argPackAdvance": 8, "readValueFromPointer": integerReadValueFromPointer(name2, shift, minRange !== 0), destructorFunction: null });
        }
        function __embind_register_memory_view(rawType, dataTypeIndex, name2) {
          var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
          var TA = typeMapping[dataTypeIndex];
          function decodeMemoryView(handle) {
            handle = handle >> 2;
            var heap = GROWABLE_HEAP_U32();
            var size = heap[handle >>> 0];
            var data = heap[handle + 1 >>> 0];
            return new TA(buffer, data, size);
          }
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": decodeMemoryView, "argPackAdvance": 8, "readValueFromPointer": decodeMemoryView }, { ignoreDuplicateRegistrations: true });
        }
        function __embind_register_std_string(rawType, name2) {
          name2 = readLatin1String(name2);
          var stdStringIsUTF8 = name2 === "std::string";
          registerType(rawType, { name: name2, "fromWireType": function(value) {
            var length = GROWABLE_HEAP_U32()[value >>> 2];
            var str;
            if (stdStringIsUTF8) {
              var decodeStartPtr = value + 4;
              for (var i = 0; i <= length; ++i) {
                var currentBytePtr = value + 4 + i;
                if (i == length || GROWABLE_HEAP_U8()[currentBytePtr >>> 0] == 0) {
                  var maxRead = currentBytePtr - decodeStartPtr;
                  var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                  if (str === void 0) {
                    str = stringSegment;
                  } else {
                    str += String.fromCharCode(0);
                    str += stringSegment;
                  }
                  decodeStartPtr = currentBytePtr + 1;
                }
              }
            } else {
              var a = new Array(length);
              for (var i = 0; i < length; ++i) {
                a[i] = String.fromCharCode(GROWABLE_HEAP_U8()[value + 4 + i >>> 0]);
              }
              str = a.join("");
            }
            _free(value);
            return str;
          }, "toWireType": function(destructors, value) {
            if (value instanceof ArrayBuffer) {
              value = new Uint8Array(value);
            }
            var getLength;
            var valueIsOfTypeString = typeof value === "string";
            if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
              throwBindingError("Cannot pass non-string to std::string");
            }
            if (stdStringIsUTF8 && valueIsOfTypeString) {
              getLength = function() {
                return lengthBytesUTF8(value);
              };
            } else {
              getLength = function() {
                return value.length;
              };
            }
            var length = getLength();
            var ptr = _malloc(4 + length + 1);
            ptr >>>= 0;
            GROWABLE_HEAP_U32()[ptr >>> 2] = length;
            if (stdStringIsUTF8 && valueIsOfTypeString) {
              stringToUTF8(value, ptr + 4, length + 1);
            } else {
              if (valueIsOfTypeString) {
                for (var i = 0; i < length; ++i) {
                  var charCode = value.charCodeAt(i);
                  if (charCode > 255) {
                    _free(ptr);
                    throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
                  }
                  GROWABLE_HEAP_U8()[ptr + 4 + i >>> 0] = charCode;
                }
              } else {
                for (var i = 0; i < length; ++i) {
                  GROWABLE_HEAP_U8()[ptr + 4 + i >>> 0] = value[i];
                }
              }
            }
            if (destructors !== null) {
              destructors.push(_free, ptr);
            }
            return ptr;
          }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
            _free(ptr);
          } });
        }
        function __embind_register_std_wstring(rawType, charSize, name2) {
          name2 = readLatin1String(name2);
          var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
          if (charSize === 2) {
            decodeString = UTF16ToString;
            encodeString = stringToUTF16;
            lengthBytesUTF = lengthBytesUTF16;
            getHeap = function() {
              return GROWABLE_HEAP_U16();
            };
            shift = 1;
          } else if (charSize === 4) {
            decodeString = UTF32ToString;
            encodeString = stringToUTF32;
            lengthBytesUTF = lengthBytesUTF32;
            getHeap = function() {
              return GROWABLE_HEAP_U32();
            };
            shift = 2;
          }
          registerType(rawType, { name: name2, "fromWireType": function(value) {
            var length = GROWABLE_HEAP_U32()[value >>> 2];
            var HEAP = getHeap();
            var str;
            var decodeStartPtr = value + 4;
            for (var i = 0; i <= length; ++i) {
              var currentBytePtr = value + 4 + i * charSize;
              if (i == length || HEAP[currentBytePtr >>> shift] == 0) {
                var maxReadBytes = currentBytePtr - decodeStartPtr;
                var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
                if (str === void 0) {
                  str = stringSegment;
                } else {
                  str += String.fromCharCode(0);
                  str += stringSegment;
                }
                decodeStartPtr = currentBytePtr + charSize;
              }
            }
            _free(value);
            return str;
          }, "toWireType": function(destructors, value) {
            if (!(typeof value === "string")) {
              throwBindingError("Cannot pass non-string to C++ string type " + name2);
            }
            var length = lengthBytesUTF(value);
            var ptr = _malloc(4 + length + charSize);
            ptr >>>= 0;
            GROWABLE_HEAP_U32()[ptr >>> 2] = length >> shift;
            encodeString(value, ptr + 4, length + charSize);
            if (destructors !== null) {
              destructors.push(_free, ptr);
            }
            return ptr;
          }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
            _free(ptr);
          } });
        }
        function __embind_register_value_array(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
          tupleRegistrations[rawType] = { name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), elements: [] };
        }
        function __embind_register_value_array_element(rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
          tupleRegistrations[rawTupleType].elements.push({ getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
        }
        function __embind_register_value_object(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
          structRegistrations[rawType] = { name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), fields: [] };
        }
        function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
          structRegistrations[structType].fields.push({ fieldName: readLatin1String(fieldName), getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
        }
        function __embind_register_void(rawType, name2) {
          name2 = readLatin1String(name2);
          registerType(rawType, { isVoid: true, name: name2, "argPackAdvance": 0, "fromWireType": function() {
            return void 0;
          }, "toWireType": function(destructors, o) {
            return void 0;
          } });
        }
        function __emscripten_notify_thread_queue(targetThreadId, mainThreadId) {
          if (targetThreadId == mainThreadId) {
            postMessage({ "cmd": "processQueuedMainThreadWork" });
          } else if (ENVIRONMENT_IS_PTHREAD) {
            postMessage({ "targetThread": targetThreadId, "cmd": "processThreadQueue" });
          } else {
            var pthread = PThread.pthreads[targetThreadId];
            var worker = pthread && pthread.worker;
            if (!worker) {
              return;
            }
            worker.postMessage({ "cmd": "processThreadQueue" });
          }
          return 1;
        }
        function requireHandle(handle) {
          if (!handle) {
            throwBindingError("Cannot use deleted val. handle = " + handle);
          }
          return emval_handle_array[handle].value;
        }
        function __emval_as(handle, returnType, destructorsRef) {
          handle = requireHandle(handle);
          returnType = requireRegisteredType(returnType, "emval::as");
          var destructors = [];
          var rd = __emval_register(destructors);
          GROWABLE_HEAP_I32()[destructorsRef >>> 2] = rd;
          return returnType["toWireType"](destructors, handle);
        }
        function __emval_lookupTypes(argCount, argTypes) {
          var a = new Array(argCount);
          for (var i = 0; i < argCount; ++i) {
            a[i] = requireRegisteredType(GROWABLE_HEAP_I32()[(argTypes >> 2) + i >>> 0], "parameter " + i);
          }
          return a;
        }
        function __emval_call(handle, argCount, argTypes, argv) {
          handle = requireHandle(handle);
          var types = __emval_lookupTypes(argCount, argTypes);
          var args = new Array(argCount);
          for (var i = 0; i < argCount; ++i) {
            var type = types[i];
            args[i] = type["readValueFromPointer"](argv);
            argv += type["argPackAdvance"];
          }
          var rv = handle.apply(void 0, args);
          return __emval_register(rv);
        }
        var emval_symbols = {};
        function getStringOrSymbol(address) {
          var symbol = emval_symbols[address];
          if (symbol === void 0) {
            return readLatin1String(address);
          } else {
            return symbol;
          }
        }
        function emval_get_global() {
          if (typeof globalThis === "object") {
            return globalThis;
          }
          return function() {
            return Function;
          }()("return this")();
        }
        function __emval_get_global(name2) {
          if (name2 === 0) {
            return __emval_register(emval_get_global());
          } else {
            name2 = getStringOrSymbol(name2);
            return __emval_register(emval_get_global()[name2]);
          }
        }
        function __emval_get_property(handle, key2) {
          handle = requireHandle(handle);
          key2 = requireHandle(key2);
          return __emval_register(handle[key2]);
        }
        function __emval_incref(handle) {
          if (handle > 4) {
            emval_handle_array[handle].refcount += 1;
          }
        }
        function __emval_instanceof(object, constructor) {
          object = requireHandle(object);
          constructor = requireHandle(constructor);
          return object instanceof constructor;
        }
        function __emval_is_number(handle) {
          handle = requireHandle(handle);
          return typeof handle === "number";
        }
        function __emval_new_array() {
          return __emval_register([]);
        }
        function __emval_new_cstring(v) {
          return __emval_register(getStringOrSymbol(v));
        }
        function __emval_new_object() {
          return __emval_register({});
        }
        function __emval_run_destructors(handle) {
          var destructors = emval_handle_array[handle].value;
          runDestructors(destructors);
          __emval_decref(handle);
        }
        function __emval_set_property(handle, key2, value) {
          handle = requireHandle(handle);
          key2 = requireHandle(key2);
          value = requireHandle(value);
          handle[key2] = value;
        }
        function __emval_take_value(type, argv) {
          type = requireRegisteredType(type, "_emval_take_value");
          var v = type["readValueFromPointer"](argv);
          return __emval_register(v);
        }
        function _abort() {
          abort();
        }
        var readAsmConstArgsArray = [];
        function readAsmConstArgs(sigPtr, buf) {
          readAsmConstArgsArray.length = 0;
          var ch;
          buf >>= 2;
          while (ch = GROWABLE_HEAP_U8()[sigPtr++ >>> 0]) {
            var double = ch < 105;
            if (double && buf & 1)
              buf++;
            readAsmConstArgsArray.push(double ? GROWABLE_HEAP_F64()[buf++ >>> 1] : GROWABLE_HEAP_I32()[buf >>> 0]);
            ++buf;
          }
          return readAsmConstArgsArray;
        }
        function _emscripten_asm_const_int(code, sigPtr, argbuf) {
          var args = readAsmConstArgs(sigPtr, argbuf);
          return ASM_CONSTS[code].apply(null, args);
        }
        function _emscripten_check_blocking_allowed() {
          if (ENVIRONMENT_IS_NODE)
            return;
          if (ENVIRONMENT_IS_WORKER)
            return;
          warnOnce("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread");
        }
        function _emscripten_conditional_set_current_thread_status(expectedStatus, newStatus) {
        }
        function _emscripten_futex_wait(addr, val, timeout) {
          if (addr <= 0 || addr > GROWABLE_HEAP_I8().length || addr & true)
            return -28;
          if (!ENVIRONMENT_IS_WEB) {
            var ret = Atomics.wait(GROWABLE_HEAP_I32(), addr >> 2, val, timeout);
            if (ret === "timed-out")
              return -73;
            if (ret === "not-equal")
              return -6;
            if (ret === "ok")
              return 0;
            throw "Atomics.wait returned an unexpected value " + ret;
          } else {
            if (Atomics.load(GROWABLE_HEAP_I32(), addr >> 2) != val) {
              return -6;
            }
            var tNow = performance.now();
            var tEnd = tNow + timeout;
            var lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, addr);
            while (1) {
              tNow = performance.now();
              if (tNow > tEnd) {
                lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, 0);
                return -73;
              }
              lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, 0);
              if (lastAddr == 0) {
                break;
              }
              _emscripten_main_thread_process_queued_calls();
              if (Atomics.load(GROWABLE_HEAP_I32(), addr >> 2) != val) {
                return -6;
              }
              lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, addr);
            }
            return 0;
          }
        }
        function _emscripten_memcpy_big(dest, src, num) {
          GROWABLE_HEAP_U8().copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);
        }
        function _emscripten_proxy_to_main_thread_js(index, sync) {
          var numCallArgs = arguments.length - 2;
          var stack = stackSave();
          var serializedNumCallArgs = numCallArgs;
          var args = stackAlloc(serializedNumCallArgs * 8);
          var b = args >> 3;
          for (var i = 0; i < numCallArgs; i++) {
            var arg = arguments[2 + i];
            GROWABLE_HEAP_F64()[b + i >>> 0] = arg;
          }
          var ret = _emscripten_run_in_main_runtime_thread_js(index, serializedNumCallArgs, args, sync);
          stackRestore(stack);
          return ret;
        }
        var _emscripten_receive_on_main_thread_js_callArgs = [];
        function _emscripten_receive_on_main_thread_js(index, numCallArgs, args) {
          _emscripten_receive_on_main_thread_js_callArgs.length = numCallArgs;
          var b = args >> 3;
          for (var i = 0; i < numCallArgs; i++) {
            _emscripten_receive_on_main_thread_js_callArgs[i] = GROWABLE_HEAP_F64()[b + i >>> 0];
          }
          var isEmAsmConst = index < 0;
          var func = !isEmAsmConst ? proxiedFunctionTable[index] : ASM_CONSTS[-index - 1];
          return func.apply(null, _emscripten_receive_on_main_thread_js_callArgs);
        }
        function emscripten_realloc_buffer(size) {
          try {
            wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
            updateGlobalBufferAndViews(wasmMemory.buffer);
            return 1;
          } catch (e) {
          }
        }
        function _emscripten_resize_heap(requestedSize) {
          var oldSize = GROWABLE_HEAP_U8().length;
          requestedSize = requestedSize >>> 0;
          if (requestedSize <= oldSize) {
            return false;
          }
          var maxHeapSize = 4294901760;
          if (requestedSize > maxHeapSize) {
            return false;
          }
          for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
            var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
            overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
            var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
            var replacement = emscripten_realloc_buffer(newSize);
            if (replacement) {
              return true;
            }
          }
          return false;
        }
        var JSEvents = { inEventHandler: 0, removeAllEventListeners: function() {
          for (var i = JSEvents.eventHandlers.length - 1; i >= 0; --i) {
            JSEvents._removeHandler(i);
          }
          JSEvents.eventHandlers = [];
          JSEvents.deferredCalls = [];
        }, registerRemoveEventListeners: function() {
          if (!JSEvents.removeEventListenersRegistered) {
            JSEvents.removeEventListenersRegistered = true;
          }
        }, deferredCalls: [], deferCall: function(targetFunction, precedence, argsList) {
          function arraysHaveEqualContent(arrA, arrB) {
            if (arrA.length != arrB.length)
              return false;
            for (var i2 in arrA) {
              if (arrA[i2] != arrB[i2])
                return false;
            }
            return true;
          }
          for (var i in JSEvents.deferredCalls) {
            var call = JSEvents.deferredCalls[i];
            if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) {
              return;
            }
          }
          JSEvents.deferredCalls.push({ targetFunction, precedence, argsList });
          JSEvents.deferredCalls.sort(function(x, y) {
            return x.precedence < y.precedence;
          });
        }, removeDeferredCalls: function(targetFunction) {
          for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
            if (JSEvents.deferredCalls[i].targetFunction == targetFunction) {
              JSEvents.deferredCalls.splice(i, 1);
              --i;
            }
          }
        }, canPerformEventHandlerRequests: function() {
          return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls;
        }, runDeferredCalls: function() {
          if (!JSEvents.canPerformEventHandlerRequests()) {
            return;
          }
          for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
            var call = JSEvents.deferredCalls[i];
            JSEvents.deferredCalls.splice(i, 1);
            --i;
            call.targetFunction.apply(null, call.argsList);
          }
        }, eventHandlers: [], removeAllHandlersOnTarget: function(target, eventTypeString) {
          for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
            if (JSEvents.eventHandlers[i].target == target && (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i].eventTypeString)) {
              JSEvents._removeHandler(i--);
            }
          }
        }, _removeHandler: function(i) {
          var h = JSEvents.eventHandlers[i];
          h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);
          JSEvents.eventHandlers.splice(i, 1);
        }, registerOrRemoveHandler: function(eventHandler) {
          var jsEventHandler = function jsEventHandler2(event) {
            ++JSEvents.inEventHandler;
            JSEvents.currentEventHandler = eventHandler;
            JSEvents.runDeferredCalls();
            eventHandler.handlerFunc(event);
            JSEvents.runDeferredCalls();
            --JSEvents.inEventHandler;
          };
          if (eventHandler.callbackfunc) {
            eventHandler.eventListenerFunc = jsEventHandler;
            eventHandler.target.addEventListener(eventHandler.eventTypeString, jsEventHandler, eventHandler.useCapture);
            JSEvents.eventHandlers.push(eventHandler);
            JSEvents.registerRemoveEventListeners();
          } else {
            for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
              if (JSEvents.eventHandlers[i].target == eventHandler.target && JSEvents.eventHandlers[i].eventTypeString == eventHandler.eventTypeString) {
                JSEvents._removeHandler(i--);
              }
            }
          }
        }, queueEventHandlerOnThread_iiii: function(targetThread, eventHandlerFunc, eventTypeId, eventData, userData) {
          var stackTop = stackSave();
          var varargs = stackAlloc(12);
          GROWABLE_HEAP_I32()[varargs >>> 2] = eventTypeId;
          GROWABLE_HEAP_I32()[varargs + 4 >>> 2] = eventData;
          GROWABLE_HEAP_I32()[varargs + 8 >>> 2] = userData;
          __emscripten_call_on_thread(0, targetThread, 637534208, eventHandlerFunc, eventData, varargs);
          stackRestore(stackTop);
        }, getTargetThreadForEventCallback: function(targetThread) {
          switch (targetThread) {
            case 1:
              return 0;
            case 2:
              return PThread.currentProxiedOperationCallerThread;
            default:
              return targetThread;
          }
        }, getNodeNameForTarget: function(target) {
          if (!target)
            return "";
          if (target == window)
            return "#window";
          if (target == screen)
            return "#screen";
          return target && target.nodeName ? target.nodeName : "";
        }, fullscreenEnabled: function() {
          return document.fullscreenEnabled || document.webkitFullscreenEnabled;
        } };
        function stringToNewUTF8(jsString) {
          var length = lengthBytesUTF8(jsString) + 1;
          var cString = _malloc(length);
          stringToUTF8(jsString, cString, length);
          return cString;
        }
        function _emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread, targetCanvas, width, height) {
          var stackTop = stackSave();
          var varargs = stackAlloc(12);
          var targetCanvasPtr = 0;
          if (targetCanvas) {
            targetCanvasPtr = stringToNewUTF8(targetCanvas);
          }
          GROWABLE_HEAP_I32()[varargs >>> 2] = targetCanvasPtr;
          GROWABLE_HEAP_I32()[varargs + 4 >>> 2] = width;
          GROWABLE_HEAP_I32()[varargs + 8 >>> 2] = height;
          __emscripten_call_on_thread(0, targetThread, 657457152, 0, targetCanvasPtr, varargs);
          stackRestore(stackTop);
        }
        function _emscripten_set_offscreencanvas_size_on_target_thread(targetThread, targetCanvas, width, height) {
          targetCanvas = targetCanvas ? UTF8ToString(targetCanvas) : "";
          _emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread, targetCanvas, width, height);
        }
        function maybeCStringToJsString(cString) {
          return cString > 2 ? UTF8ToString(cString) : cString;
        }
        var specialHTMLTargets = [0, typeof document !== "undefined" ? document : 0, typeof window !== "undefined" ? window : 0];
        function findEventTarget(target) {
          target = maybeCStringToJsString(target);
          var domElement = specialHTMLTargets[target] || (typeof document !== "undefined" ? document.querySelector(target) : void 0);
          return domElement;
        }
        function findCanvasEventTarget(target) {
          return findEventTarget(target);
        }
        function _emscripten_set_canvas_element_size_calling_thread(target, width, height) {
          var canvas = findCanvasEventTarget(target);
          if (!canvas)
            return -4;
          if (canvas.canvasSharedPtr) {
            GROWABLE_HEAP_I32()[canvas.canvasSharedPtr >>> 2] = width;
            GROWABLE_HEAP_I32()[canvas.canvasSharedPtr + 4 >>> 2] = height;
          }
          if (canvas.offscreenCanvas || !canvas.controlTransferredOffscreen) {
            if (canvas.offscreenCanvas)
              canvas = canvas.offscreenCanvas;
            var autoResizeViewport = false;
            if (canvas.GLctxObject && canvas.GLctxObject.GLctx) {
              var prevViewport = canvas.GLctxObject.GLctx.getParameter(2978);
              autoResizeViewport = prevViewport[0] === 0 && prevViewport[1] === 0 && prevViewport[2] === canvas.width && prevViewport[3] === canvas.height;
            }
            canvas.width = width;
            canvas.height = height;
            if (autoResizeViewport) {
              canvas.GLctxObject.GLctx.viewport(0, 0, width, height);
            }
          } else if (canvas.canvasSharedPtr) {
            var targetThread = GROWABLE_HEAP_I32()[canvas.canvasSharedPtr + 8 >>> 2];
            _emscripten_set_offscreencanvas_size_on_target_thread(targetThread, target, width, height);
            return 1;
          } else {
            return -4;
          }
          return 0;
        }
        function _emscripten_set_canvas_element_size_main_thread(target, width, height) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(5, 1, target, width, height);
          return _emscripten_set_canvas_element_size_calling_thread(target, width, height);
        }
        function _emscripten_set_canvas_element_size(target, width, height) {
          var canvas = findCanvasEventTarget(target);
          if (canvas) {
            return _emscripten_set_canvas_element_size_calling_thread(target, width, height);
          } else {
            return _emscripten_set_canvas_element_size_main_thread(target, width, height);
          }
        }
        function _emscripten_set_current_thread_status(newStatus) {
        }
        function __webgl_enable_ANGLE_instanced_arrays(ctx) {
          var ext = ctx.getExtension("ANGLE_instanced_arrays");
          if (ext) {
            ctx["vertexAttribDivisor"] = function(index, divisor) {
              ext["vertexAttribDivisorANGLE"](index, divisor);
            };
            ctx["drawArraysInstanced"] = function(mode, first, count, primcount) {
              ext["drawArraysInstancedANGLE"](mode, first, count, primcount);
            };
            ctx["drawElementsInstanced"] = function(mode, count, type, indices, primcount) {
              ext["drawElementsInstancedANGLE"](mode, count, type, indices, primcount);
            };
            return 1;
          }
        }
        function __webgl_enable_OES_vertex_array_object(ctx) {
          var ext = ctx.getExtension("OES_vertex_array_object");
          if (ext) {
            ctx["createVertexArray"] = function() {
              return ext["createVertexArrayOES"]();
            };
            ctx["deleteVertexArray"] = function(vao) {
              ext["deleteVertexArrayOES"](vao);
            };
            ctx["bindVertexArray"] = function(vao) {
              ext["bindVertexArrayOES"](vao);
            };
            ctx["isVertexArray"] = function(vao) {
              return ext["isVertexArrayOES"](vao);
            };
            return 1;
          }
        }
        function __webgl_enable_WEBGL_draw_buffers(ctx) {
          var ext = ctx.getExtension("WEBGL_draw_buffers");
          if (ext) {
            ctx["drawBuffers"] = function(n, bufs) {
              ext["drawBuffersWEBGL"](n, bufs);
            };
            return 1;
          }
        }
        function __webgl_enable_WEBGL_multi_draw(ctx) {
          return !!(ctx.multiDrawWebgl = ctx.getExtension("WEBGL_multi_draw"));
        }
        var GL = { counter: 1, buffers: [], programs: [], framebuffers: [], renderbuffers: [], textures: [], shaders: [], vaos: [], contexts: {}, offscreenCanvases: {}, queries: [], stringCache: {}, unpackAlignment: 4, recordError: function recordError(errorCode) {
          if (!GL.lastError) {
            GL.lastError = errorCode;
          }
        }, getNewId: function(table) {
          var ret = GL.counter++;
          for (var i = table.length; i < ret; i++) {
            table[i] = null;
          }
          return ret;
        }, getSource: function(shader, count, string, length) {
          var source = "";
          for (var i = 0; i < count; ++i) {
            var len = length ? GROWABLE_HEAP_I32()[length + i * 4 >>> 2] : -1;
            source += UTF8ToString(GROWABLE_HEAP_I32()[string + i * 4 >>> 2], len < 0 ? void 0 : len);
          }
          return source;
        }, createContext: function(canvas, webGLContextAttributes) {
          if (!canvas.getContextSafariWebGL2Fixed) {
            canvas.getContextSafariWebGL2Fixed = canvas.getContext;
            canvas.getContext = function(ver, attrs) {
              var gl = canvas.getContextSafariWebGL2Fixed(ver, attrs);
              return ver == "webgl" == gl instanceof WebGLRenderingContext ? gl : null;
            };
          }
          var ctx = canvas.getContext("webgl", webGLContextAttributes);
          if (!ctx)
            return 0;
          var handle = GL.registerContext(ctx, webGLContextAttributes);
          return handle;
        }, registerContext: function(ctx, webGLContextAttributes) {
          var handle = _malloc(8);
          GROWABLE_HEAP_I32()[handle + 4 >>> 2] = _pthread_self();
          var context = { handle, attributes: webGLContextAttributes, version: webGLContextAttributes.majorVersion, GLctx: ctx };
          if (ctx.canvas)
            ctx.canvas.GLctxObject = context;
          GL.contexts[handle] = context;
          if (typeof webGLContextAttributes.enableExtensionsByDefault === "undefined" || webGLContextAttributes.enableExtensionsByDefault) {
            GL.initExtensions(context);
          }
          return handle;
        }, makeContextCurrent: function(contextHandle) {
          GL.currentContext = GL.contexts[contextHandle];
          Module.ctx = GLctx = GL.currentContext && GL.currentContext.GLctx;
          return !(contextHandle && !GLctx);
        }, getContext: function(contextHandle) {
          return GL.contexts[contextHandle];
        }, deleteContext: function(contextHandle) {
          if (GL.currentContext === GL.contexts[contextHandle])
            GL.currentContext = null;
          if (typeof JSEvents === "object")
            JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);
          if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas)
            GL.contexts[contextHandle].GLctx.canvas.GLctxObject = void 0;
          _free(GL.contexts[contextHandle].handle);
          GL.contexts[contextHandle] = null;
        }, initExtensions: function(context) {
          if (!context)
            context = GL.currentContext;
          if (context.initExtensionsDone)
            return;
          context.initExtensionsDone = true;
          var GLctx2 = context.GLctx;
          __webgl_enable_ANGLE_instanced_arrays(GLctx2);
          __webgl_enable_OES_vertex_array_object(GLctx2);
          __webgl_enable_WEBGL_draw_buffers(GLctx2);
          {
            GLctx2.disjointTimerQueryExt = GLctx2.getExtension("EXT_disjoint_timer_query");
          }
          __webgl_enable_WEBGL_multi_draw(GLctx2);
          var exts = GLctx2.getSupportedExtensions() || [];
          exts.forEach(function(ext) {
            if (!ext.includes("lose_context") && !ext.includes("debug")) {
              GLctx2.getExtension(ext);
            }
          });
        } };
        var __emscripten_webgl_power_preferences = ["default", "low-power", "high-performance"];
        function _emscripten_webgl_do_create_context(target, attributes) {
          var a = attributes >> 2;
          var powerPreference = GROWABLE_HEAP_I32()[a + (24 >> 2) >>> 0];
          var contextAttributes = { "alpha": !!GROWABLE_HEAP_I32()[a + (0 >> 2) >>> 0], "depth": !!GROWABLE_HEAP_I32()[a + (4 >> 2) >>> 0], "stencil": !!GROWABLE_HEAP_I32()[a + (8 >> 2) >>> 0], "antialias": !!GROWABLE_HEAP_I32()[a + (12 >> 2) >>> 0], "premultipliedAlpha": !!GROWABLE_HEAP_I32()[a + (16 >> 2) >>> 0], "preserveDrawingBuffer": !!GROWABLE_HEAP_I32()[a + (20 >> 2) >>> 0], "powerPreference": __emscripten_webgl_power_preferences[powerPreference], "failIfMajorPerformanceCaveat": !!GROWABLE_HEAP_I32()[a + (28 >> 2) >>> 0], majorVersion: GROWABLE_HEAP_I32()[a + (32 >> 2) >>> 0], minorVersion: GROWABLE_HEAP_I32()[a + (36 >> 2) >>> 0], enableExtensionsByDefault: GROWABLE_HEAP_I32()[a + (40 >> 2) >>> 0], explicitSwapControl: GROWABLE_HEAP_I32()[a + (44 >> 2) >>> 0], proxyContextToMainThread: GROWABLE_HEAP_I32()[a + (48 >> 2) >>> 0], renderViaOffscreenBackBuffer: GROWABLE_HEAP_I32()[a + (52 >> 2) >>> 0] };
          var canvas = findCanvasEventTarget(target);
          if (!canvas) {
            return 0;
          }
          if (contextAttributes.explicitSwapControl) {
            return 0;
          }
          var contextHandle = GL.createContext(canvas, contextAttributes);
          return contextHandle;
        }
        function _emscripten_webgl_create_context(a0, a1) {
          return _emscripten_webgl_do_create_context(a0, a1);
        }
        var ENV = {};
        function getExecutableName() {
          return thisProgram || "./this.program";
        }
        function getEnvStrings() {
          if (!getEnvStrings.strings) {
            var lang = (typeof navigator === "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
            var env = { "USER": "web_user", "LOGNAME": "web_user", "PATH": "/", "PWD": "/", "HOME": "/home/web_user", "LANG": lang, "_": getExecutableName() };
            for (var x in ENV) {
              if (ENV[x] === void 0)
                delete env[x];
              else
                env[x] = ENV[x];
            }
            var strings = [];
            for (var x in env) {
              strings.push(x + "=" + env[x]);
            }
            getEnvStrings.strings = strings;
          }
          return getEnvStrings.strings;
        }
        function _environ_get(__environ, environ_buf) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(6, 1, __environ, environ_buf);
          try {
            var bufSize = 0;
            getEnvStrings().forEach(function(string, i) {
              var ptr = environ_buf + bufSize;
              GROWABLE_HEAP_I32()[__environ + i * 4 >>> 2] = ptr;
              writeAsciiToMemory(string, ptr);
              bufSize += string.length + 1;
            });
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _environ_sizes_get(penviron_count, penviron_buf_size) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(7, 1, penviron_count, penviron_buf_size);
          try {
            var strings = getEnvStrings();
            GROWABLE_HEAP_I32()[penviron_count >>> 2] = strings.length;
            var bufSize = 0;
            strings.forEach(function(string) {
              bufSize += string.length + 1;
            });
            GROWABLE_HEAP_I32()[penviron_buf_size >>> 2] = bufSize;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _fd_close(fd) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(8, 1, fd);
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.close(stream);
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _fd_read(fd, iov, iovcnt, pnum) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(9, 1, fd, iov, iovcnt, pnum);
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = SYSCALLS.doReadv(stream, iov, iovcnt);
            GROWABLE_HEAP_I32()[pnum >>> 2] = num;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(10, 1, fd, offset_low, offset_high, whence, newOffset);
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var HIGH_OFFSET = 4294967296;
            var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
            var DOUBLE_LIMIT = 9007199254740992;
            if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
              return -61;
            }
            FS.llseek(stream, offset, whence);
            tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], GROWABLE_HEAP_I32()[newOffset >>> 2] = tempI64[0], GROWABLE_HEAP_I32()[newOffset + 4 >>> 2] = tempI64[1];
            if (stream.getdents && offset === 0 && whence === 0)
              stream.getdents = null;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _fd_write(fd, iov, iovcnt, pnum) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(11, 1, fd, iov, iovcnt, pnum);
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = SYSCALLS.doWritev(stream, iov, iovcnt);
            GROWABLE_HEAP_I32()[pnum >>> 2] = num;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _getTempRet0() {
          return getTempRet0();
        }
        function _llvm_eh_typeid_for(type) {
          return type;
        }
        function spawnThread(threadParams) {
          if (ENVIRONMENT_IS_PTHREAD)
            throw "Internal Error! spawnThread() can only ever be called from main application thread!";
          var worker = PThread.getNewWorker();
          if (!worker) {
            return 6;
          }
          if (worker.pthread !== void 0)
            throw "Internal error!";
          if (!threadParams.pthread_ptr)
            throw "Internal error, no pthread ptr!";
          PThread.runningWorkers.push(worker);
          var tlsMemory = _malloc(128 * 4);
          for (var i = 0; i < 128; ++i) {
            GROWABLE_HEAP_I32()[tlsMemory + i * 4 >>> 2] = 0;
          }
          var stackHigh = threadParams.stackBase + threadParams.stackSize;
          var pthread = PThread.pthreads[threadParams.pthread_ptr] = { worker, stackBase: threadParams.stackBase, stackSize: threadParams.stackSize, allocatedOwnStack: threadParams.allocatedOwnStack, threadInfoStruct: threadParams.pthread_ptr };
          var tis = pthread.threadInfoStruct >> 2;
          Atomics.store(GROWABLE_HEAP_U32(), tis + (64 >> 2), threadParams.detached);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (100 >> 2), tlsMemory);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (40 >> 2), pthread.threadInfoStruct);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (80 >> 2), threadParams.stackSize);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (76 >> 2), stackHigh);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (104 >> 2), threadParams.stackSize);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (104 + 8 >> 2), stackHigh);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (104 + 12 >> 2), threadParams.detached);
          var global_libc = _emscripten_get_global_libc();
          var global_locale = global_libc + 40;
          Atomics.store(GROWABLE_HEAP_U32(), tis + (172 >> 2), global_locale);
          worker.pthread = pthread;
          var msg = { "cmd": "run", "start_routine": threadParams.startRoutine, "arg": threadParams.arg, "threadInfoStruct": threadParams.pthread_ptr, "stackBase": threadParams.stackBase, "stackSize": threadParams.stackSize };
          worker.runPthread = function() {
            msg.time = performance.now();
            worker.postMessage(msg, threadParams.transferList);
          };
          if (worker.loaded) {
            worker.runPthread();
            delete worker.runPthread;
          }
          return 0;
        }
        function _pthread_create(pthread_ptr, attr, start_routine, arg) {
          if (typeof SharedArrayBuffer === "undefined") {
            err("Current environment does not support SharedArrayBuffer, pthreads are not available!");
            return 6;
          }
          if (!pthread_ptr) {
            err("pthread_create called with a null thread pointer!");
            return 28;
          }
          var transferList = [];
          var error = 0;
          if (ENVIRONMENT_IS_PTHREAD && (transferList.length === 0 || error)) {
            return _emscripten_sync_run_in_main_thread_4(687865856, pthread_ptr, attr, start_routine, arg);
          }
          var stackSize = 0;
          var stackBase = 0;
          var detached = 0;
          if (attr && attr != -1) {
            stackSize = GROWABLE_HEAP_I32()[attr >>> 2];
            stackSize += 81920;
            stackBase = GROWABLE_HEAP_I32()[attr + 8 >>> 2];
            detached = GROWABLE_HEAP_I32()[attr + 12 >>> 2] !== 0;
          } else {
            stackSize = 2097152;
          }
          var allocatedOwnStack = stackBase == 0;
          if (allocatedOwnStack) {
            stackBase = _memalign(16, stackSize);
          } else {
            stackBase -= stackSize;
            assert(stackBase > 0);
          }
          var threadInfoStruct = _malloc(228);
          for (var i = 0; i < 228 >> 2; ++i)
            GROWABLE_HEAP_U32()[(threadInfoStruct >> 2) + i >>> 0] = 0;
          GROWABLE_HEAP_I32()[pthread_ptr >>> 2] = threadInfoStruct;
          GROWABLE_HEAP_I32()[threadInfoStruct + 12 >>> 2] = threadInfoStruct;
          var headPtr = threadInfoStruct + 152;
          GROWABLE_HEAP_I32()[headPtr >>> 2] = headPtr;
          var threadParams = { stackBase, stackSize, allocatedOwnStack, detached, startRoutine: start_routine, pthread_ptr: threadInfoStruct, arg, transferList };
          if (ENVIRONMENT_IS_PTHREAD) {
            threadParams.cmd = "spawnThread";
            postMessage(threadParams, transferList);
            return 0;
          }
          return spawnThread(threadParams);
        }
        function _setTempRet0(val) {
          setTempRet0(val);
        }
        function __isLeapYear(year) {
          return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
        }
        function __arraySum(array, index) {
          var sum = 0;
          for (var i = 0; i <= index; sum += array[i++]) {
          }
          return sum;
        }
        var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        function __addDays(date, days) {
          var newDate = new Date(date.getTime());
          while (days > 0) {
            var leap = __isLeapYear(newDate.getFullYear());
            var currentMonth = newDate.getMonth();
            var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];
            if (days > daysInCurrentMonth - newDate.getDate()) {
              days -= daysInCurrentMonth - newDate.getDate() + 1;
              newDate.setDate(1);
              if (currentMonth < 11) {
                newDate.setMonth(currentMonth + 1);
              } else {
                newDate.setMonth(0);
                newDate.setFullYear(newDate.getFullYear() + 1);
              }
            } else {
              newDate.setDate(newDate.getDate() + days);
              return newDate;
            }
          }
          return newDate;
        }
        function _strftime(s, maxsize, format, tm) {
          var tm_zone = GROWABLE_HEAP_I32()[tm + 40 >>> 2];
          var date = { tm_sec: GROWABLE_HEAP_I32()[tm >>> 2], tm_min: GROWABLE_HEAP_I32()[tm + 4 >>> 2], tm_hour: GROWABLE_HEAP_I32()[tm + 8 >>> 2], tm_mday: GROWABLE_HEAP_I32()[tm + 12 >>> 2], tm_mon: GROWABLE_HEAP_I32()[tm + 16 >>> 2], tm_year: GROWABLE_HEAP_I32()[tm + 20 >>> 2], tm_wday: GROWABLE_HEAP_I32()[tm + 24 >>> 2], tm_yday: GROWABLE_HEAP_I32()[tm + 28 >>> 2], tm_isdst: GROWABLE_HEAP_I32()[tm + 32 >>> 2], tm_gmtoff: GROWABLE_HEAP_I32()[tm + 36 >>> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : "" };
          var pattern = UTF8ToString(format);
          var EXPANSION_RULES_1 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
          for (var rule in EXPANSION_RULES_1) {
            pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
          }
          var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
          var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
          function leadingSomething(value, digits, character) {
            var str = typeof value === "number" ? value.toString() : value || "";
            while (str.length < digits) {
              str = character[0] + str;
            }
            return str;
          }
          function leadingNulls(value, digits) {
            return leadingSomething(value, digits, "0");
          }
          function compareByDay(date1, date2) {
            function sgn(value) {
              return value < 0 ? -1 : value > 0 ? 1 : 0;
            }
            var compare;
            if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
              if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
                compare = sgn(date1.getDate() - date2.getDate());
              }
            }
            return compare;
          }
          function getFirstWeekStartDate(janFourth) {
            switch (janFourth.getDay()) {
              case 0:
                return new Date(janFourth.getFullYear() - 1, 11, 29);
              case 1:
                return janFourth;
              case 2:
                return new Date(janFourth.getFullYear(), 0, 3);
              case 3:
                return new Date(janFourth.getFullYear(), 0, 2);
              case 4:
                return new Date(janFourth.getFullYear(), 0, 1);
              case 5:
                return new Date(janFourth.getFullYear() - 1, 11, 31);
              case 6:
                return new Date(janFourth.getFullYear() - 1, 11, 30);
            }
          }
          function getWeekBasedYear(date2) {
            var thisDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
            var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
            var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
            var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
            var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
            if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
              if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
                return thisDate.getFullYear() + 1;
              } else {
                return thisDate.getFullYear();
              }
            } else {
              return thisDate.getFullYear() - 1;
            }
          }
          var EXPANSION_RULES_2 = { "%a": function(date2) {
            return WEEKDAYS[date2.tm_wday].substring(0, 3);
          }, "%A": function(date2) {
            return WEEKDAYS[date2.tm_wday];
          }, "%b": function(date2) {
            return MONTHS[date2.tm_mon].substring(0, 3);
          }, "%B": function(date2) {
            return MONTHS[date2.tm_mon];
          }, "%C": function(date2) {
            var year = date2.tm_year + 1900;
            return leadingNulls(year / 100 | 0, 2);
          }, "%d": function(date2) {
            return leadingNulls(date2.tm_mday, 2);
          }, "%e": function(date2) {
            return leadingSomething(date2.tm_mday, 2, " ");
          }, "%g": function(date2) {
            return getWeekBasedYear(date2).toString().substring(2);
          }, "%G": function(date2) {
            return getWeekBasedYear(date2);
          }, "%H": function(date2) {
            return leadingNulls(date2.tm_hour, 2);
          }, "%I": function(date2) {
            var twelveHour = date2.tm_hour;
            if (twelveHour == 0)
              twelveHour = 12;
            else if (twelveHour > 12)
              twelveHour -= 12;
            return leadingNulls(twelveHour, 2);
          }, "%j": function(date2) {
            return leadingNulls(date2.tm_mday + __arraySum(__isLeapYear(date2.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3);
          }, "%m": function(date2) {
            return leadingNulls(date2.tm_mon + 1, 2);
          }, "%M": function(date2) {
            return leadingNulls(date2.tm_min, 2);
          }, "%n": function() {
            return "\n";
          }, "%p": function(date2) {
            if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
              return "AM";
            } else {
              return "PM";
            }
          }, "%S": function(date2) {
            return leadingNulls(date2.tm_sec, 2);
          }, "%t": function() {
            return "	";
          }, "%u": function(date2) {
            return date2.tm_wday || 7;
          }, "%U": function(date2) {
            var janFirst = new Date(date2.tm_year + 1900, 0, 1);
            var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());
            var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
            if (compareByDay(firstSunday, endDate) < 0) {
              var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
              var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();
              var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
              return leadingNulls(Math.ceil(days / 7), 2);
            }
            return compareByDay(firstSunday, janFirst) === 0 ? "01" : "00";
          }, "%V": function(date2) {
            var janFourthThisYear = new Date(date2.tm_year + 1900, 0, 4);
            var janFourthNextYear = new Date(date2.tm_year + 1901, 0, 4);
            var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
            var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
            var endDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
            if (compareByDay(endDate, firstWeekStartThisYear) < 0) {
              return "53";
            }
            if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {
              return "01";
            }
            var daysDifference;
            if (firstWeekStartThisYear.getFullYear() < date2.tm_year + 1900) {
              daysDifference = date2.tm_yday + 32 - firstWeekStartThisYear.getDate();
            } else {
              daysDifference = date2.tm_yday + 1 - firstWeekStartThisYear.getDate();
            }
            return leadingNulls(Math.ceil(daysDifference / 7), 2);
          }, "%w": function(date2) {
            return date2.tm_wday;
          }, "%W": function(date2) {
            var janFirst = new Date(date2.tm_year, 0, 1);
            var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);
            var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
            if (compareByDay(firstMonday, endDate) < 0) {
              var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
              var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();
              var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
              return leadingNulls(Math.ceil(days / 7), 2);
            }
            return compareByDay(firstMonday, janFirst) === 0 ? "01" : "00";
          }, "%y": function(date2) {
            return (date2.tm_year + 1900).toString().substring(2);
          }, "%Y": function(date2) {
            return date2.tm_year + 1900;
          }, "%z": function(date2) {
            var off = date2.tm_gmtoff;
            var ahead = off >= 0;
            off = Math.abs(off) / 60;
            off = off / 60 * 100 + off % 60;
            return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
          }, "%Z": function(date2) {
            return date2.tm_zone;
          }, "%%": function() {
            return "%";
          } };
          for (var rule in EXPANSION_RULES_2) {
            if (pattern.includes(rule)) {
              pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
            }
          }
          var bytes = intArrayFromString(pattern, false);
          if (bytes.length > maxsize) {
            return 0;
          }
          writeArrayToMemory(bytes, s);
          return bytes.length - 1;
        }
        function _strftime_l(s, maxsize, format, tm) {
          return _strftime(s, maxsize, format, tm);
        }
        if (!ENVIRONMENT_IS_PTHREAD)
          PThread.initMainThreadBlock();
        var FSNode = function(parent, name2, mode, rdev) {
          if (!parent) {
            parent = this;
          }
          this.parent = parent;
          this.mount = parent.mount;
          this.mounted = null;
          this.id = FS.nextInode++;
          this.name = name2;
          this.mode = mode;
          this.node_ops = {};
          this.stream_ops = {};
          this.rdev = rdev;
        };
        var readMode = 292 | 73;
        var writeMode = 146;
        Object.defineProperties(FSNode.prototype, { read: { get: function() {
          return (this.mode & readMode) === readMode;
        }, set: function(val) {
          val ? this.mode |= readMode : this.mode &= ~readMode;
        } }, write: { get: function() {
          return (this.mode & writeMode) === writeMode;
        }, set: function(val) {
          val ? this.mode |= writeMode : this.mode &= ~writeMode;
        } }, isFolder: { get: function() {
          return FS.isDir(this.mode);
        } }, isDevice: { get: function() {
          return FS.isChrdev(this.mode);
        } } });
        FS.FSNode = FSNode;
        FS.staticInit();
        Module["FS_createPath"] = FS.createPath;
        Module["FS_createDataFile"] = FS.createDataFile;
        Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
        Module["FS_createLazyFile"] = FS.createLazyFile;
        Module["FS_createDevice"] = FS.createDevice;
        Module["FS_unlink"] = FS.unlink;
        InternalError = Module["InternalError"] = extendError(Error, "InternalError");
        embind_init_charCodes();
        BindingError = Module["BindingError"] = extendError(Error, "BindingError");
        init_ClassHandle();
        init_RegisteredPointer();
        init_embind();
        UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
        init_emval();
        var GLctx;
        var proxiedFunctionTable = [null, _atexit, ___sys_fcntl64, ___sys_ioctl, ___sys_open, _emscripten_set_canvas_element_size_main_thread, _environ_get, _environ_sizes_get, _fd_close, _fd_read, _fd_seek, _fd_write];
        function intArrayFromString(stringy, dontAddNull, length) {
          var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
          var u8array = new Array(len);
          var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
          if (dontAddNull)
            u8array.length = numBytesWritten;
          return u8array;
        }
        var asmLibraryArg = { "z": ___assert_fail, "n": ___cxa_allocate_exception, "v": ___cxa_begin_catch, "y": ___cxa_end_catch, "c": ___cxa_find_matching_catch_2, "m": ___cxa_find_matching_catch_3, "C": ___cxa_free_exception, "ba": ___cxa_rethrow, "La": ___cxa_thread_atexit, "o": ___cxa_throw, "ta": ___cxa_uncaught_exceptions, "i": ___resumeException, "da": ___sys_fcntl64, "ua": ___sys_ioctl, "va": ___sys_open, "Oa": __embind_finalize_value_array, "Ra": __embind_finalize_value_object, "_a": __embind_register_bigint, "Ja": __embind_register_bool, "O": __embind_register_class, "N": __embind_register_class_constructor, "q": __embind_register_class_function, "Ia": __embind_register_emval, "Ma": __embind_register_enum, "T": __embind_register_enum_value, "ja": __embind_register_float, "t": __embind_register_function, "B": __embind_register_integer, "x": __embind_register_memory_view, "ka": __embind_register_std_string, "Y": __embind_register_std_wstring, "Pa": __embind_register_value_array, "Na": __embind_register_value_array_element, "M": __embind_register_value_object, "Qa": __embind_register_value_object_field, "Ka": __embind_register_void, "Ca": __emscripten_notify_thread_queue, "U": __emval_as, "la": __emval_call, "xa": __emval_decref, "$a": __emval_get_global, "Ua": __emval_get_property, "aa": __emval_incref, "pa": __emval_instanceof, "Xa": __emval_is_number, "Wa": __emval_new_array, "Z": __emval_new_cstring, "Va": __emval_new_object, "Ta": __emval_run_destructors, "Sa": __emval_set_property, "D": __emval_take_value, "ia": _abort, "ca": _clock_gettime, "ga": _emscripten_asm_const_int, "wa": _emscripten_check_blocking_allowed, "fa": _emscripten_conditional_set_current_thread_status, "K": _emscripten_futex_wait, "J": _emscripten_futex_wake, "S": _emscripten_get_now, "ra": _emscripten_memcpy_big, "ya": _emscripten_receive_on_main_thread_js, "sa": _emscripten_resize_heap, "za": _emscripten_set_canvas_element_size, "ea": _emscripten_set_current_thread_status, "Aa": _emscripten_webgl_create_context, "Ea": _environ_get, "Fa": _environ_sizes_get, "ha": _fd_close, "Ha": _fd_read, "Za": _fd_seek, "Ga": _fd_write, "b": _getTempRet0, "qa": initPthreadsJS, "I": invoke_diii, "E": invoke_i, "d": invoke_ii, "Q": invoke_iid, "j": invoke_iii, "k": invoke_iiii, "R": invoke_iiiii, "na": invoke_iiiiid, "G": invoke_iiiiii, "A": invoke_iiiiiii, "_": invoke_iiiiiiii, "P": invoke_iiiiiiiii, "W": invoke_iiiiiiiiiiii, "Ya": invoke_j, "g": invoke_v, "f": invoke_vi, "L": invoke_viddi, "H": invoke_viffiid, "h": invoke_vii, "s": invoke_viidd, "e": invoke_viii, "l": invoke_viiii, "$": invoke_viiiid, "X": invoke_viiiidii, "F": invoke_viiiii, "w": invoke_viiiiii, "r": invoke_viiiiiii, "u": invoke_viiiiiiiii, "p": invoke_viiiiiiiiii, "V": invoke_viiiiiiiiiiiiiii, "oa": _llvm_eh_typeid_for, "a": wasmMemory || Module["wasmMemory"], "Ba": _pthread_create, "ma": _setTempRet0, "Da": _strftime_l };
        createWasm();
        Module["___wasm_call_ctors"] = function() {
          return (Module["___wasm_call_ctors"] = Module["asm"]["ab"]).apply(null, arguments);
        };
        Module["_main"] = function() {
          return (Module["_main"] = Module["asm"]["bb"]).apply(null, arguments);
        };
        var _malloc = Module["_malloc"] = function() {
          return (_malloc = Module["_malloc"] = Module["asm"]["cb"]).apply(null, arguments);
        };
        var _free = Module["_free"] = function() {
          return (_free = Module["_free"] = Module["asm"]["eb"]).apply(null, arguments);
        };
        Module["_emscripten_tls_init"] = function() {
          return (Module["_emscripten_tls_init"] = Module["asm"]["fb"]).apply(null, arguments);
        };
        var ___getTypeName = Module["___getTypeName"] = function() {
          return (___getTypeName = Module["___getTypeName"] = Module["asm"]["gb"]).apply(null, arguments);
        };
        Module["___embind_register_native_and_builtin_types"] = function() {
          return (Module["___embind_register_native_and_builtin_types"] = Module["asm"]["hb"]).apply(null, arguments);
        };
        Module["_emscripten_current_thread_process_queued_calls"] = function() {
          return (Module["_emscripten_current_thread_process_queued_calls"] = Module["asm"]["ib"]).apply(null, arguments);
        };
        var _emscripten_register_main_browser_thread_id = Module["_emscripten_register_main_browser_thread_id"] = function() {
          return (_emscripten_register_main_browser_thread_id = Module["_emscripten_register_main_browser_thread_id"] = Module["asm"]["jb"]).apply(null, arguments);
        };
        var __emscripten_do_dispatch_to_thread = Module["__emscripten_do_dispatch_to_thread"] = function() {
          return (__emscripten_do_dispatch_to_thread = Module["__emscripten_do_dispatch_to_thread"] = Module["asm"]["kb"]).apply(null, arguments);
        };
        var _emscripten_sync_run_in_main_thread_4 = Module["_emscripten_sync_run_in_main_thread_4"] = function() {
          return (_emscripten_sync_run_in_main_thread_4 = Module["_emscripten_sync_run_in_main_thread_4"] = Module["asm"]["lb"]).apply(null, arguments);
        };
        var _emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = function() {
          return (_emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = Module["asm"]["mb"]).apply(null, arguments);
        };
        var _emscripten_run_in_main_runtime_thread_js = Module["_emscripten_run_in_main_runtime_thread_js"] = function() {
          return (_emscripten_run_in_main_runtime_thread_js = Module["_emscripten_run_in_main_runtime_thread_js"] = Module["asm"]["nb"]).apply(null, arguments);
        };
        var __emscripten_call_on_thread = Module["__emscripten_call_on_thread"] = function() {
          return (__emscripten_call_on_thread = Module["__emscripten_call_on_thread"] = Module["asm"]["ob"]).apply(null, arguments);
        };
        var __emscripten_thread_init = Module["__emscripten_thread_init"] = function() {
          return (__emscripten_thread_init = Module["__emscripten_thread_init"] = Module["asm"]["pb"]).apply(null, arguments);
        };
        var _emscripten_get_global_libc = Module["_emscripten_get_global_libc"] = function() {
          return (_emscripten_get_global_libc = Module["_emscripten_get_global_libc"] = Module["asm"]["qb"]).apply(null, arguments);
        };
        var ___errno_location = Module["___errno_location"] = function() {
          return (___errno_location = Module["___errno_location"] = Module["asm"]["rb"]).apply(null, arguments);
        };
        var _pthread_self = Module["_pthread_self"] = function() {
          return (_pthread_self = Module["_pthread_self"] = Module["asm"]["sb"]).apply(null, arguments);
        };
        var ___pthread_tsd_run_dtors = Module["___pthread_tsd_run_dtors"] = function() {
          return (___pthread_tsd_run_dtors = Module["___pthread_tsd_run_dtors"] = Module["asm"]["tb"]).apply(null, arguments);
        };
        var stackSave = Module["stackSave"] = function() {
          return (stackSave = Module["stackSave"] = Module["asm"]["ub"]).apply(null, arguments);
        };
        var stackRestore = Module["stackRestore"] = function() {
          return (stackRestore = Module["stackRestore"] = Module["asm"]["vb"]).apply(null, arguments);
        };
        var stackAlloc = Module["stackAlloc"] = function() {
          return (stackAlloc = Module["stackAlloc"] = Module["asm"]["wb"]).apply(null, arguments);
        };
        var _emscripten_stack_set_limits = Module["_emscripten_stack_set_limits"] = function() {
          return (_emscripten_stack_set_limits = Module["_emscripten_stack_set_limits"] = Module["asm"]["xb"]).apply(null, arguments);
        };
        var _setThrew = Module["_setThrew"] = function() {
          return (_setThrew = Module["_setThrew"] = Module["asm"]["yb"]).apply(null, arguments);
        };
        var ___cxa_can_catch = Module["___cxa_can_catch"] = function() {
          return (___cxa_can_catch = Module["___cxa_can_catch"] = Module["asm"]["zb"]).apply(null, arguments);
        };
        var ___cxa_is_pointer_type = Module["___cxa_is_pointer_type"] = function() {
          return (___cxa_is_pointer_type = Module["___cxa_is_pointer_type"] = Module["asm"]["Ab"]).apply(null, arguments);
        };
        var _memalign = Module["_memalign"] = function() {
          return (_memalign = Module["_memalign"] = Module["asm"]["Bb"]).apply(null, arguments);
        };
        Module["dynCall_jiji"] = function() {
          return (Module["dynCall_jiji"] = Module["asm"]["Cb"]).apply(null, arguments);
        };
        var dynCall_j = Module["dynCall_j"] = function() {
          return (dynCall_j = Module["dynCall_j"] = Module["asm"]["Db"]).apply(null, arguments);
        };
        Module["dynCall_viijii"] = function() {
          return (Module["dynCall_viijii"] = Module["asm"]["Eb"]).apply(null, arguments);
        };
        Module["dynCall_iiiiij"] = function() {
          return (Module["dynCall_iiiiij"] = Module["asm"]["Fb"]).apply(null, arguments);
        };
        Module["dynCall_iiiiijj"] = function() {
          return (Module["dynCall_iiiiijj"] = Module["asm"]["Gb"]).apply(null, arguments);
        };
        Module["dynCall_iiiiiijj"] = function() {
          return (Module["dynCall_iiiiiijj"] = Module["asm"]["Hb"]).apply(null, arguments);
        };
        var __emscripten_allow_main_runtime_queued_calls = Module["__emscripten_allow_main_runtime_queued_calls"] = 56672;
        var __emscripten_main_thread_futex = Module["__emscripten_main_thread_futex"] = 60132;
        function invoke_ii(index, a1) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vi(index, a1) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_v(index) {
          var sp = stackSave();
          try {
            wasmTable.get(index)();
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viii(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiii(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iii(index, a1, a2) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vii(index, a1, a2) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiii(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_diii(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_i(index) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)();
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiii(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iid(index, a1, a2) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiidii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viffiid(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viddi(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiii(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viidd(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiid(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiid(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_j(index) {
          var sp = stackSave();
          try {
            return dynCall_j(index);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        Module["addRunDependency"] = addRunDependency;
        Module["removeRunDependency"] = removeRunDependency;
        Module["FS_createPath"] = FS.createPath;
        Module["FS_createDataFile"] = FS.createDataFile;
        Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
        Module["FS_createLazyFile"] = FS.createLazyFile;
        Module["FS_createDevice"] = FS.createDevice;
        Module["FS_unlink"] = FS.unlink;
        Module["keepRuntimeAlive"] = keepRuntimeAlive;
        Module["FS"] = FS;
        Module["PThread"] = PThread;
        Module["PThread"] = PThread;
        Module["wasmMemory"] = wasmMemory;
        Module["ExitStatus"] = ExitStatus;
        var calledRun;
        function ExitStatus(status) {
          this.name = "ExitStatus";
          this.message = "Program terminated with exit(" + status + ")";
          this.status = status;
        }
        dependenciesFulfilled = function runCaller() {
          if (!calledRun)
            run();
          if (!calledRun)
            dependenciesFulfilled = runCaller;
        };
        function callMain(args) {
          var entryFunction = Module["_main"];
          var argc = 0;
          var argv = 0;
          try {
            var ret = entryFunction(argc, argv);
            exit(ret, true);
          } catch (e) {
            if (e instanceof ExitStatus || e == "unwind") {
              return;
            }
            var toLog = e;
            if (e && typeof e === "object" && e.stack) {
              toLog = [e, e.stack];
            }
            err("exception thrown: " + toLog);
            quit_(1, e);
          } finally {
          }
        }
        function run(args) {
          if (runDependencies > 0) {
            return;
          }
          if (ENVIRONMENT_IS_PTHREAD) {
            readyPromiseResolve(Module);
            initRuntime();
            postMessage({ "cmd": "loaded" });
            return;
          }
          preRun();
          if (runDependencies > 0) {
            return;
          }
          function doRun() {
            if (calledRun)
              return;
            calledRun = true;
            Module["calledRun"] = true;
            if (ABORT)
              return;
            initRuntime();
            preMain();
            readyPromiseResolve(Module);
            if (Module["onRuntimeInitialized"])
              Module["onRuntimeInitialized"]();
            if (shouldRunNow)
              callMain();
            postRun();
          }
          if (Module["setStatus"]) {
            Module["setStatus"]("Running...");
            setTimeout(function() {
              setTimeout(function() {
                Module["setStatus"]("");
              }, 1);
              doRun();
            }, 1);
          } else {
            doRun();
          }
        }
        Module["run"] = run;
        function exit(status, implicit) {
          if (!implicit) {
            if (ENVIRONMENT_IS_PTHREAD) {
              postMessage({ "cmd": "exitProcess", "returnCode": status });
              throw new ExitStatus(status);
            }
          }
          if (keepRuntimeAlive()) ; else {
            PThread.terminateAllThreads();
            if (Module["onExit"])
              Module["onExit"](status);
            ABORT = true;
          }
          quit_(status, new ExitStatus(status));
        }
        if (Module["preInit"]) {
          if (typeof Module["preInit"] == "function")
            Module["preInit"] = [Module["preInit"]];
          while (Module["preInit"].length > 0) {
            Module["preInit"].pop()();
          }
        }
        var shouldRunNow = true;
        if (Module["noInitialRun"])
          shouldRunNow = false;
        if (ENVIRONMENT_IS_PTHREAD) {
          noExitRuntime = false;
          PThread.initWorker();
        }
        run();
        return WebIFCWasm3.ready;
      };
    }();
    if (typeof exports === "object" && typeof module === "object")
      module.exports = WebIFCWasm2;
    else if (typeof define === "function" && define["amd"])
      define([], function() {
        return WebIFCWasm2;
      });
    else if (typeof exports === "object")
      exports["WebIFCWasm"] = WebIFCWasm2;
  }
});

// dist/web-ifc.js
var require_web_ifc = __commonJS({
  "dist/web-ifc.js"(exports, module) {
    var WebIFCWasm2 = function() {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined")
        _scriptDir = _scriptDir || __filename;
      return function(WebIFCWasm3) {
        WebIFCWasm3 = WebIFCWasm3 || {};
        var Module = typeof WebIFCWasm3 !== "undefined" ? WebIFCWasm3 : {};
        var readyPromiseResolve, readyPromiseReject;
        Module["ready"] = new Promise(function(resolve, reject) {
          readyPromiseResolve = resolve;
          readyPromiseReject = reject;
        });
        var moduleOverrides = {};
        var key;
        for (key in Module) {
          if (Module.hasOwnProperty(key)) {
            moduleOverrides[key] = Module[key];
          }
        }
        var thisProgram = "./this.program";
        var quit_ = function(status, toThrow) {
          throw toThrow;
        };
        var ENVIRONMENT_IS_WEB = typeof window === "object";
        var ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
        var ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
        var scriptDirectory = "";
        function locateFile(path) {
          if (Module["locateFile"]) {
            return Module["locateFile"](path, scriptDirectory);
          }
          return scriptDirectory + path;
        }
        var read_, readAsync, readBinary;
        var nodeFS;
        var nodePath;
        if (ENVIRONMENT_IS_NODE) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = __require("path").dirname(scriptDirectory) + "/";
          } else {
            scriptDirectory = __dirname + "/";
          }
          read_ = function shell_read(filename, binary) {
            if (!nodeFS)
              nodeFS = __require("fs");
            if (!nodePath)
              nodePath = __require("path");
            filename = nodePath["normalize"](filename);
            return nodeFS["readFileSync"](filename, binary ? null : "utf8");
          };
          readBinary = function readBinary2(filename) {
            var ret = read_(filename, true);
            if (!ret.buffer) {
              ret = new Uint8Array(ret);
            }
            assert(ret.buffer);
            return ret;
          };
          readAsync = function readAsync2(filename, onload, onerror) {
            if (!nodeFS)
              nodeFS = __require("fs");
            if (!nodePath)
              nodePath = __require("path");
            filename = nodePath["normalize"](filename);
            nodeFS["readFile"](filename, function(err2, data) {
              if (err2)
                onerror(err2);
              else
                onload(data.buffer);
            });
          };
          if (process["argv"].length > 1) {
            thisProgram = process["argv"][1].replace(/\\/g, "/");
          }
          process["argv"].slice(2);
          process["on"]("uncaughtException", function(ex) {
            if (!(ex instanceof ExitStatus)) {
              throw ex;
            }
          });
          process["on"]("unhandledRejection", abort);
          quit_ = function(status, toThrow) {
            if (keepRuntimeAlive()) {
              process["exitCode"] = status;
              throw toThrow;
            }
            process["exit"](status);
          };
          Module["inspect"] = function() {
            return "[Emscripten Module object]";
          };
        } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = self.location.href;
          } else if (typeof document !== "undefined" && document.currentScript) {
            scriptDirectory = document.currentScript.src;
          }
          if (_scriptDir) {
            scriptDirectory = _scriptDir;
          }
          if (scriptDirectory.indexOf("blob:") !== 0) {
            scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
          } else {
            scriptDirectory = "";
          }
          {
            read_ = function(url) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.send(null);
              return xhr.responseText;
            };
            if (ENVIRONMENT_IS_WORKER) {
              readBinary = function(url) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                return new Uint8Array(xhr.response);
              };
            }
            readAsync = function(url, onload, onerror) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, true);
              xhr.responseType = "arraybuffer";
              xhr.onload = function() {
                if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                  onload(xhr.response);
                  return;
                }
                onerror();
              };
              xhr.onerror = onerror;
              xhr.send(null);
            };
          }
        } else ;
        var out = Module["print"] || console.log.bind(console);
        var err = Module["printErr"] || console.warn.bind(console);
        for (key in moduleOverrides) {
          if (moduleOverrides.hasOwnProperty(key)) {
            Module[key] = moduleOverrides[key];
          }
        }
        moduleOverrides = null;
        if (Module["arguments"])
          Module["arguments"];
        if (Module["thisProgram"])
          thisProgram = Module["thisProgram"];
        if (Module["quit"])
          quit_ = Module["quit"];
        var tempRet0 = 0;
        var setTempRet0 = function(value) {
          tempRet0 = value;
        };
        var getTempRet0 = function() {
          return tempRet0;
        };
        var wasmBinary;
        if (Module["wasmBinary"])
          wasmBinary = Module["wasmBinary"];
        var noExitRuntime = Module["noExitRuntime"] || true;
        if (typeof WebAssembly !== "object") {
          abort("no native wasm support detected");
        }
        var wasmMemory;
        var ABORT = false;
        function assert(condition, text) {
          if (!condition) {
            abort("Assertion failed: " + text);
          }
        }
        var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
        function UTF8ArrayToString(heap, idx, maxBytesToRead) {
          idx >>>= 0;
          var endIdx = idx + maxBytesToRead;
          var endPtr = idx;
          while (heap[endPtr >>> 0] && !(endPtr >= endIdx))
            ++endPtr;
          if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
            return UTF8Decoder.decode(heap.subarray(idx >>> 0, endPtr >>> 0));
          } else {
            var str = "";
            while (idx < endPtr) {
              var u0 = heap[idx++ >>> 0];
              if (!(u0 & 128)) {
                str += String.fromCharCode(u0);
                continue;
              }
              var u1 = heap[idx++ >>> 0] & 63;
              if ((u0 & 224) == 192) {
                str += String.fromCharCode((u0 & 31) << 6 | u1);
                continue;
              }
              var u2 = heap[idx++ >>> 0] & 63;
              if ((u0 & 240) == 224) {
                u0 = (u0 & 15) << 12 | u1 << 6 | u2;
              } else {
                u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++ >>> 0] & 63;
              }
              if (u0 < 65536) {
                str += String.fromCharCode(u0);
              } else {
                var ch = u0 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
              }
            }
          }
          return str;
        }
        function UTF8ToString(ptr, maxBytesToRead) {
          ptr >>>= 0;
          return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
        }
        function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
          outIdx >>>= 0;
          if (!(maxBytesToWrite > 0))
            return 0;
          var startIdx = outIdx;
          var endIdx = outIdx + maxBytesToWrite - 1;
          for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343) {
              var u1 = str.charCodeAt(++i);
              u = 65536 + ((u & 1023) << 10) | u1 & 1023;
            }
            if (u <= 127) {
              if (outIdx >= endIdx)
                break;
              heap[outIdx++ >>> 0] = u;
            } else if (u <= 2047) {
              if (outIdx + 1 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 192 | u >> 6;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            } else if (u <= 65535) {
              if (outIdx + 2 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 224 | u >> 12;
              heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            } else {
              if (outIdx + 3 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 240 | u >> 18;
              heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;
              heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            }
          }
          heap[outIdx >>> 0] = 0;
          return outIdx - startIdx;
        }
        function stringToUTF8(str, outPtr, maxBytesToWrite) {
          return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
        }
        function lengthBytesUTF8(str) {
          var len = 0;
          for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343)
              u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
            if (u <= 127)
              ++len;
            else if (u <= 2047)
              len += 2;
            else if (u <= 65535)
              len += 3;
            else
              len += 4;
          }
          return len;
        }
        var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
        function UTF16ToString(ptr, maxBytesToRead) {
          var endPtr = ptr;
          var idx = endPtr >> 1;
          var maxIdx = idx + maxBytesToRead / 2;
          while (!(idx >= maxIdx) && HEAPU16[idx >>> 0])
            ++idx;
          endPtr = idx << 1;
          if (endPtr - ptr > 32 && UTF16Decoder) {
            return UTF16Decoder.decode(HEAPU8.subarray(ptr >>> 0, endPtr >>> 0));
          } else {
            var str = "";
            for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
              var codeUnit = HEAP16[ptr + i * 2 >>> 1];
              if (codeUnit == 0)
                break;
              str += String.fromCharCode(codeUnit);
            }
            return str;
          }
        }
        function stringToUTF16(str, outPtr, maxBytesToWrite) {
          if (maxBytesToWrite === void 0) {
            maxBytesToWrite = 2147483647;
          }
          if (maxBytesToWrite < 2)
            return 0;
          maxBytesToWrite -= 2;
          var startPtr = outPtr;
          var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
          for (var i = 0; i < numCharsToWrite; ++i) {
            var codeUnit = str.charCodeAt(i);
            HEAP16[outPtr >>> 1] = codeUnit;
            outPtr += 2;
          }
          HEAP16[outPtr >>> 1] = 0;
          return outPtr - startPtr;
        }
        function lengthBytesUTF16(str) {
          return str.length * 2;
        }
        function UTF32ToString(ptr, maxBytesToRead) {
          var i = 0;
          var str = "";
          while (!(i >= maxBytesToRead / 4)) {
            var utf32 = HEAP32[ptr + i * 4 >>> 2];
            if (utf32 == 0)
              break;
            ++i;
            if (utf32 >= 65536) {
              var ch = utf32 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            } else {
              str += String.fromCharCode(utf32);
            }
          }
          return str;
        }
        function stringToUTF32(str, outPtr, maxBytesToWrite) {
          outPtr >>>= 0;
          if (maxBytesToWrite === void 0) {
            maxBytesToWrite = 2147483647;
          }
          if (maxBytesToWrite < 4)
            return 0;
          var startPtr = outPtr;
          var endPtr = startPtr + maxBytesToWrite - 4;
          for (var i = 0; i < str.length; ++i) {
            var codeUnit = str.charCodeAt(i);
            if (codeUnit >= 55296 && codeUnit <= 57343) {
              var trailSurrogate = str.charCodeAt(++i);
              codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
            }
            HEAP32[outPtr >>> 2] = codeUnit;
            outPtr += 4;
            if (outPtr + 4 > endPtr)
              break;
          }
          HEAP32[outPtr >>> 2] = 0;
          return outPtr - startPtr;
        }
        function lengthBytesUTF32(str) {
          var len = 0;
          for (var i = 0; i < str.length; ++i) {
            var codeUnit = str.charCodeAt(i);
            if (codeUnit >= 55296 && codeUnit <= 57343)
              ++i;
            len += 4;
          }
          return len;
        }
        function writeArrayToMemory(array, buffer2) {
          HEAP8.set(array, buffer2 >>> 0);
        }
        function writeAsciiToMemory(str, buffer2, dontAddNull) {
          for (var i = 0; i < str.length; ++i) {
            HEAP8[buffer2++ >>> 0] = str.charCodeAt(i);
          }
          if (!dontAddNull)
            HEAP8[buffer2 >>> 0] = 0;
        }
        function alignUp(x, multiple) {
          if (x % multiple > 0) {
            x += multiple - x % multiple;
          }
          return x;
        }
        var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
        function updateGlobalBufferAndViews(buf) {
          buffer = buf;
          Module["HEAP8"] = HEAP8 = new Int8Array(buf);
          Module["HEAP16"] = HEAP16 = new Int16Array(buf);
          Module["HEAP32"] = HEAP32 = new Int32Array(buf);
          Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
          Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
          Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
          Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
          Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
        }
        Module["INITIAL_MEMORY"] || 16777216;
        var wasmTable;
        var __ATPRERUN__ = [];
        var __ATINIT__ = [];
        var __ATMAIN__ = [];
        var __ATPOSTRUN__ = [];
        var runtimeKeepaliveCounter = 0;
        function keepRuntimeAlive() {
          return noExitRuntime || runtimeKeepaliveCounter > 0;
        }
        function preRun() {
          if (Module["preRun"]) {
            if (typeof Module["preRun"] == "function")
              Module["preRun"] = [Module["preRun"]];
            while (Module["preRun"].length) {
              addOnPreRun(Module["preRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPRERUN__);
        }
        function initRuntime() {
          if (!Module["noFSInit"] && !FS.init.initialized)
            FS.init();
          FS.ignorePermissions = false;
          callRuntimeCallbacks(__ATINIT__);
        }
        function preMain() {
          callRuntimeCallbacks(__ATMAIN__);
        }
        function postRun() {
          if (Module["postRun"]) {
            if (typeof Module["postRun"] == "function")
              Module["postRun"] = [Module["postRun"]];
            while (Module["postRun"].length) {
              addOnPostRun(Module["postRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPOSTRUN__);
        }
        function addOnPreRun(cb) {
          __ATPRERUN__.unshift(cb);
        }
        function addOnInit(cb) {
          __ATINIT__.unshift(cb);
        }
        function addOnPostRun(cb) {
          __ATPOSTRUN__.unshift(cb);
        }
        var runDependencies = 0;
        var dependenciesFulfilled = null;
        function getUniqueRunDependency(id) {
          return id;
        }
        function addRunDependency(id) {
          runDependencies++;
          if (Module["monitorRunDependencies"]) {
            Module["monitorRunDependencies"](runDependencies);
          }
        }
        function removeRunDependency(id) {
          runDependencies--;
          if (Module["monitorRunDependencies"]) {
            Module["monitorRunDependencies"](runDependencies);
          }
          if (runDependencies == 0) {
            if (dependenciesFulfilled) {
              var callback = dependenciesFulfilled;
              dependenciesFulfilled = null;
              callback();
            }
          }
        }
        Module["preloadedImages"] = {};
        Module["preloadedAudios"] = {};
        function abort(what) {
          if (Module["onAbort"]) {
            Module["onAbort"](what);
          }
          what += "";
          err(what);
          ABORT = true;
          what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
          var e = new WebAssembly.RuntimeError(what);
          readyPromiseReject(e);
          throw e;
        }
        var dataURIPrefix = "data:application/octet-stream;base64,";
        function isDataURI(filename) {
          return filename.startsWith(dataURIPrefix);
        }
        function isFileURI(filename) {
          return filename.startsWith("file://");
        }
        var wasmBinaryFile;
        wasmBinaryFile = "web-ifc.wasm";
        if (!isDataURI(wasmBinaryFile)) {
          wasmBinaryFile = locateFile(wasmBinaryFile);
        }
        function getBinary(file) {
          try {
            if (file == wasmBinaryFile && wasmBinary) {
              return new Uint8Array(wasmBinary);
            }
            if (readBinary) {
              return readBinary(file);
            } else {
              throw "both async and sync fetching of the wasm failed";
            }
          } catch (err2) {
            abort(err2);
          }
        }
        function getBinaryPromise() {
          if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
            if (typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
              return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                if (!response["ok"]) {
                  throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                }
                return response["arrayBuffer"]();
              }).catch(function() {
                return getBinary(wasmBinaryFile);
              });
            } else {
              if (readAsync) {
                return new Promise(function(resolve, reject) {
                  readAsync(wasmBinaryFile, function(response) {
                    resolve(new Uint8Array(response));
                  }, reject);
                });
              }
            }
          }
          return Promise.resolve().then(function() {
            return getBinary(wasmBinaryFile);
          });
        }
        function createWasm() {
          var info = { "a": asmLibraryArg };
          function receiveInstance(instance, module2) {
            var exports3 = instance.exports;
            Module["asm"] = exports3;
            wasmMemory = Module["asm"]["Na"];
            updateGlobalBufferAndViews(wasmMemory.buffer);
            wasmTable = Module["asm"]["Ra"];
            addOnInit(Module["asm"]["Oa"]);
            removeRunDependency();
          }
          addRunDependency();
          function receiveInstantiationResult(result) {
            receiveInstance(result["instance"]);
          }
          function instantiateArrayBuffer(receiver) {
            return getBinaryPromise().then(function(binary) {
              var result = WebAssembly.instantiate(binary, info);
              return result;
            }).then(receiver, function(reason) {
              err("failed to asynchronously prepare wasm: " + reason);
              abort(reason);
            });
          }
          function instantiateAsync() {
            if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
              return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                var result = WebAssembly.instantiateStreaming(response, info);
                return result.then(receiveInstantiationResult, function(reason) {
                  err("wasm streaming compile failed: " + reason);
                  err("falling back to ArrayBuffer instantiation");
                  return instantiateArrayBuffer(receiveInstantiationResult);
                });
              });
            } else {
              return instantiateArrayBuffer(receiveInstantiationResult);
            }
          }
          if (Module["instantiateWasm"]) {
            try {
              var exports2 = Module["instantiateWasm"](info, receiveInstance);
              return exports2;
            } catch (e) {
              err("Module.instantiateWasm callback failed with error: " + e);
              return false;
            }
          }
          instantiateAsync().catch(readyPromiseReject);
          return {};
        }
        var tempDouble;
        var tempI64;
        function callRuntimeCallbacks(callbacks) {
          while (callbacks.length > 0) {
            var callback = callbacks.shift();
            if (typeof callback == "function") {
              callback(Module);
              continue;
            }
            var func = callback.func;
            if (typeof func === "number") {
              if (callback.arg === void 0) {
                wasmTable.get(func)();
              } else {
                wasmTable.get(func)(callback.arg);
              }
            } else {
              func(callback.arg === void 0 ? null : callback.arg);
            }
          }
        }
        function ___assert_fail(condition, filename, line, func) {
          abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
        }
        function ___cxa_allocate_exception(size) {
          return _malloc(size + 16) + 16;
        }
        function ExceptionInfo(excPtr) {
          this.excPtr = excPtr;
          this.ptr = excPtr - 16;
          this.set_type = function(type) {
            HEAP32[this.ptr + 4 >>> 2] = type;
          };
          this.get_type = function() {
            return HEAP32[this.ptr + 4 >>> 2];
          };
          this.set_destructor = function(destructor) {
            HEAP32[this.ptr + 8 >>> 2] = destructor;
          };
          this.get_destructor = function() {
            return HEAP32[this.ptr + 8 >>> 2];
          };
          this.set_refcount = function(refcount) {
            HEAP32[this.ptr >>> 2] = refcount;
          };
          this.set_caught = function(caught) {
            caught = caught ? 1 : 0;
            HEAP8[this.ptr + 12 >>> 0] = caught;
          };
          this.get_caught = function() {
            return HEAP8[this.ptr + 12 >>> 0] != 0;
          };
          this.set_rethrown = function(rethrown) {
            rethrown = rethrown ? 1 : 0;
            HEAP8[this.ptr + 13 >>> 0] = rethrown;
          };
          this.get_rethrown = function() {
            return HEAP8[this.ptr + 13 >>> 0] != 0;
          };
          this.init = function(type, destructor) {
            this.set_type(type);
            this.set_destructor(destructor);
            this.set_refcount(0);
            this.set_caught(false);
            this.set_rethrown(false);
          };
          this.add_ref = function() {
            var value = HEAP32[this.ptr >>> 2];
            HEAP32[this.ptr >>> 2] = value + 1;
          };
          this.release_ref = function() {
            var prev = HEAP32[this.ptr >>> 2];
            HEAP32[this.ptr >>> 2] = prev - 1;
            return prev === 1;
          };
        }
        function CatchInfo(ptr) {
          this.free = function() {
            _free(this.ptr);
            this.ptr = 0;
          };
          this.set_base_ptr = function(basePtr) {
            HEAP32[this.ptr >>> 2] = basePtr;
          };
          this.get_base_ptr = function() {
            return HEAP32[this.ptr >>> 2];
          };
          this.set_adjusted_ptr = function(adjustedPtr) {
            HEAP32[this.ptr + 4 >>> 2] = adjustedPtr;
          };
          this.get_adjusted_ptr_addr = function() {
            return this.ptr + 4;
          };
          this.get_adjusted_ptr = function() {
            return HEAP32[this.ptr + 4 >>> 2];
          };
          this.get_exception_ptr = function() {
            var isPointer = ___cxa_is_pointer_type(this.get_exception_info().get_type());
            if (isPointer) {
              return HEAP32[this.get_base_ptr() >>> 2];
            }
            var adjusted = this.get_adjusted_ptr();
            if (adjusted !== 0)
              return adjusted;
            return this.get_base_ptr();
          };
          this.get_exception_info = function() {
            return new ExceptionInfo(this.get_base_ptr());
          };
          if (ptr === void 0) {
            this.ptr = _malloc(8);
            this.set_adjusted_ptr(0);
          } else {
            this.ptr = ptr;
          }
        }
        var exceptionCaught = [];
        function exception_addRef(info) {
          info.add_ref();
        }
        var uncaughtExceptionCount = 0;
        function ___cxa_begin_catch(ptr) {
          var catchInfo = new CatchInfo(ptr);
          var info = catchInfo.get_exception_info();
          if (!info.get_caught()) {
            info.set_caught(true);
            uncaughtExceptionCount--;
          }
          info.set_rethrown(false);
          exceptionCaught.push(catchInfo);
          exception_addRef(info);
          return catchInfo.get_exception_ptr();
        }
        var exceptionLast = 0;
        function ___cxa_free_exception(ptr) {
          return _free(new ExceptionInfo(ptr).ptr);
        }
        function exception_decRef(info) {
          if (info.release_ref() && !info.get_rethrown()) {
            var destructor = info.get_destructor();
            if (destructor) {
              wasmTable.get(destructor)(info.excPtr);
            }
            ___cxa_free_exception(info.excPtr);
          }
        }
        function ___cxa_end_catch() {
          _setThrew(0);
          var catchInfo = exceptionCaught.pop();
          exception_decRef(catchInfo.get_exception_info());
          catchInfo.free();
          exceptionLast = 0;
        }
        function ___resumeException(catchInfoPtr) {
          var catchInfo = new CatchInfo(catchInfoPtr);
          var ptr = catchInfo.get_base_ptr();
          if (!exceptionLast) {
            exceptionLast = ptr;
          }
          catchInfo.free();
          throw ptr;
        }
        function ___cxa_find_matching_catch_2() {
          var thrown = exceptionLast;
          if (!thrown) {
            setTempRet0(0);
            return 0 | 0;
          }
          var info = new ExceptionInfo(thrown);
          var thrownType = info.get_type();
          var catchInfo = new CatchInfo();
          catchInfo.set_base_ptr(thrown);
          catchInfo.set_adjusted_ptr(thrown);
          if (!thrownType) {
            setTempRet0(0);
            return catchInfo.ptr | 0;
          }
          var typeArray = Array.prototype.slice.call(arguments);
          for (var i = 0; i < typeArray.length; i++) {
            var caughtType = typeArray[i];
            if (caughtType === 0 || caughtType === thrownType) {
              break;
            }
            if (___cxa_can_catch(caughtType, thrownType, catchInfo.get_adjusted_ptr_addr())) {
              setTempRet0(caughtType);
              return catchInfo.ptr | 0;
            }
          }
          setTempRet0(thrownType);
          return catchInfo.ptr | 0;
        }
        function ___cxa_find_matching_catch_3() {
          var thrown = exceptionLast;
          if (!thrown) {
            setTempRet0(0);
            return 0 | 0;
          }
          var info = new ExceptionInfo(thrown);
          var thrownType = info.get_type();
          var catchInfo = new CatchInfo();
          catchInfo.set_base_ptr(thrown);
          catchInfo.set_adjusted_ptr(thrown);
          if (!thrownType) {
            setTempRet0(0);
            return catchInfo.ptr | 0;
          }
          var typeArray = Array.prototype.slice.call(arguments);
          for (var i = 0; i < typeArray.length; i++) {
            var caughtType = typeArray[i];
            if (caughtType === 0 || caughtType === thrownType) {
              break;
            }
            if (___cxa_can_catch(caughtType, thrownType, catchInfo.get_adjusted_ptr_addr())) {
              setTempRet0(caughtType);
              return catchInfo.ptr | 0;
            }
          }
          setTempRet0(thrownType);
          return catchInfo.ptr | 0;
        }
        function ___cxa_rethrow() {
          var catchInfo = exceptionCaught.pop();
          if (!catchInfo) {
            abort("no exception to throw");
          }
          var info = catchInfo.get_exception_info();
          var ptr = catchInfo.get_base_ptr();
          if (!info.get_rethrown()) {
            exceptionCaught.push(catchInfo);
            info.set_rethrown(true);
            info.set_caught(false);
            uncaughtExceptionCount++;
          } else {
            catchInfo.free();
          }
          exceptionLast = ptr;
          throw ptr;
        }
        function ___cxa_throw(ptr, type, destructor) {
          var info = new ExceptionInfo(ptr);
          info.init(type, destructor);
          exceptionLast = ptr;
          uncaughtExceptionCount++;
          throw ptr;
        }
        function ___cxa_uncaught_exceptions() {
          return uncaughtExceptionCount;
        }
        function setErrNo(value) {
          HEAP32[___errno_location() >>> 2] = value;
          return value;
        }
        var PATH = { splitPath: function(filename) {
          var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
          return splitPathRe.exec(filename).slice(1);
        }, normalizeArray: function(parts, allowAboveRoot) {
          var up = 0;
          for (var i = parts.length - 1; i >= 0; i--) {
            var last = parts[i];
            if (last === ".") {
              parts.splice(i, 1);
            } else if (last === "..") {
              parts.splice(i, 1);
              up++;
            } else if (up) {
              parts.splice(i, 1);
              up--;
            }
          }
          if (allowAboveRoot) {
            for (; up; up--) {
              parts.unshift("..");
            }
          }
          return parts;
        }, normalize: function(path) {
          var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/";
          path = PATH.normalizeArray(path.split("/").filter(function(p) {
            return !!p;
          }), !isAbsolute).join("/");
          if (!path && !isAbsolute) {
            path = ".";
          }
          if (path && trailingSlash) {
            path += "/";
          }
          return (isAbsolute ? "/" : "") + path;
        }, dirname: function(path) {
          var result = PATH.splitPath(path), root = result[0], dir = result[1];
          if (!root && !dir) {
            return ".";
          }
          if (dir) {
            dir = dir.substr(0, dir.length - 1);
          }
          return root + dir;
        }, basename: function(path) {
          if (path === "/")
            return "/";
          path = PATH.normalize(path);
          path = path.replace(/\/$/, "");
          var lastSlash = path.lastIndexOf("/");
          if (lastSlash === -1)
            return path;
          return path.substr(lastSlash + 1);
        }, extname: function(path) {
          return PATH.splitPath(path)[3];
        }, join: function() {
          var paths = Array.prototype.slice.call(arguments, 0);
          return PATH.normalize(paths.join("/"));
        }, join2: function(l, r) {
          return PATH.normalize(l + "/" + r);
        } };
        function getRandomDevice() {
          if (typeof crypto === "object" && typeof crypto["getRandomValues"] === "function") {
            var randomBuffer = new Uint8Array(1);
            return function() {
              crypto.getRandomValues(randomBuffer);
              return randomBuffer[0];
            };
          } else if (ENVIRONMENT_IS_NODE) {
            try {
              var crypto_module = require_crypto();
              return function() {
                return crypto_module["randomBytes"](1)[0];
              };
            } catch (e) {
            }
          }
          return function() {
            abort("randomDevice");
          };
        }
        var PATH_FS = { resolve: function() {
          var resolvedPath = "", resolvedAbsolute = false;
          for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path = i >= 0 ? arguments[i] : FS.cwd();
            if (typeof path !== "string") {
              throw new TypeError("Arguments to path.resolve must be strings");
            } else if (!path) {
              return "";
            }
            resolvedPath = path + "/" + resolvedPath;
            resolvedAbsolute = path.charAt(0) === "/";
          }
          resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(function(p) {
            return !!p;
          }), !resolvedAbsolute).join("/");
          return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
        }, relative: function(from, to) {
          from = PATH_FS.resolve(from).substr(1);
          to = PATH_FS.resolve(to).substr(1);
          function trim(arr) {
            var start = 0;
            for (; start < arr.length; start++) {
              if (arr[start] !== "")
                break;
            }
            var end = arr.length - 1;
            for (; end >= 0; end--) {
              if (arr[end] !== "")
                break;
            }
            if (start > end)
              return [];
            return arr.slice(start, end - start + 1);
          }
          var fromParts = trim(from.split("/"));
          var toParts = trim(to.split("/"));
          var length = Math.min(fromParts.length, toParts.length);
          var samePartsLength = length;
          for (var i = 0; i < length; i++) {
            if (fromParts[i] !== toParts[i]) {
              samePartsLength = i;
              break;
            }
          }
          var outputParts = [];
          for (var i = samePartsLength; i < fromParts.length; i++) {
            outputParts.push("..");
          }
          outputParts = outputParts.concat(toParts.slice(samePartsLength));
          return outputParts.join("/");
        } };
        var TTY = { ttys: [], init: function() {
        }, shutdown: function() {
        }, register: function(dev, ops) {
          TTY.ttys[dev] = { input: [], output: [], ops };
          FS.registerDevice(dev, TTY.stream_ops);
        }, stream_ops: { open: function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        }, close: function(stream) {
          stream.tty.ops.flush(stream.tty);
        }, flush: function(stream) {
          stream.tty.ops.flush(stream.tty);
        }, read: function(stream, buffer2, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer2[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        }, write: function(stream, buffer2, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer2[offset + i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        } }, default_tty_ops: { get_char: function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              var BUFSIZE = 256;
              var buf = Buffer.alloc(BUFSIZE);
              var bytesRead = 0;
              try {
                bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);
              } catch (e) {
                if (e.toString().includes("EOF"))
                  bytesRead = 0;
                else
                  throw e;
              }
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString("utf-8");
              } else {
                result = null;
              }
            } else if (typeof window != "undefined" && typeof window.prompt == "function") {
              result = window.prompt("Input: ");
              if (result !== null) {
                result += "\n";
              }
            } else if (typeof readline == "function") {
              result = readline();
              if (result !== null) {
                result += "\n";
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        }, put_char: function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0)
              tty.output.push(val);
          }
        }, flush: function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        } }, default_tty1_ops: { put_char: function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0)
              tty.output.push(val);
          }
        }, flush: function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        } } };
        function mmapAlloc(size) {
          abort();
        }
        var MEMFS = { ops_table: null, mount: function(mount) {
          return MEMFS.createNode(null, "/", 16384 | 511, 0);
        }, createNode: function(parent, name2, mode, dev) {
          if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
            throw new FS.ErrnoError(63);
          }
          if (!MEMFS.ops_table) {
            MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } };
          }
          var node = FS.createNode(parent, name2, mode, dev);
          if (FS.isDir(node.mode)) {
            node.node_ops = MEMFS.ops_table.dir.node;
            node.stream_ops = MEMFS.ops_table.dir.stream;
            node.contents = {};
          } else if (FS.isFile(node.mode)) {
            node.node_ops = MEMFS.ops_table.file.node;
            node.stream_ops = MEMFS.ops_table.file.stream;
            node.usedBytes = 0;
            node.contents = null;
          } else if (FS.isLink(node.mode)) {
            node.node_ops = MEMFS.ops_table.link.node;
            node.stream_ops = MEMFS.ops_table.link.stream;
          } else if (FS.isChrdev(node.mode)) {
            node.node_ops = MEMFS.ops_table.chrdev.node;
            node.stream_ops = MEMFS.ops_table.chrdev.stream;
          }
          node.timestamp = Date.now();
          if (parent) {
            parent.contents[name2] = node;
            parent.timestamp = node.timestamp;
          }
          return node;
        }, getFileDataAsTypedArray: function(node) {
          if (!node.contents)
            return new Uint8Array(0);
          if (node.contents.subarray)
            return node.contents.subarray(0, node.usedBytes);
          return new Uint8Array(node.contents);
        }, expandFileStorage: function(node, newCapacity) {
          newCapacity >>>= 0;
          var prevCapacity = node.contents ? node.contents.length : 0;
          if (prevCapacity >= newCapacity)
            return;
          var CAPACITY_DOUBLING_MAX = 1024 * 1024;
          newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
          if (prevCapacity != 0)
            newCapacity = Math.max(newCapacity, 256);
          var oldContents = node.contents;
          node.contents = new Uint8Array(newCapacity);
          if (node.usedBytes > 0)
            node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
        }, resizeFileStorage: function(node, newSize) {
          newSize >>>= 0;
          if (node.usedBytes == newSize)
            return;
          if (newSize == 0) {
            node.contents = null;
            node.usedBytes = 0;
          } else {
            var oldContents = node.contents;
            node.contents = new Uint8Array(newSize);
            if (oldContents) {
              node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
            }
            node.usedBytes = newSize;
          }
        }, node_ops: { getattr: function(node) {
          var attr = {};
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        }, setattr: function(node, attr) {
          if (attr.mode !== void 0) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== void 0) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        }, lookup: function(parent, name2) {
          throw FS.genericErrors[44];
        }, mknod: function(parent, name2, mode, dev) {
          return MEMFS.createNode(parent, name2, mode, dev);
        }, rename: function(old_node, new_dir, new_name) {
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now();
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        }, unlink: function(parent, name2) {
          delete parent.contents[name2];
          parent.timestamp = Date.now();
        }, rmdir: function(parent, name2) {
          var node = FS.lookupNode(parent, name2);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name2];
          parent.timestamp = Date.now();
        }, readdir: function(node) {
          var entries = [".", ".."];
          for (var key2 in node.contents) {
            if (!node.contents.hasOwnProperty(key2)) {
              continue;
            }
            entries.push(key2);
          }
          return entries;
        }, symlink: function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
          node.link = oldpath;
          return node;
        }, readlink: function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        } }, stream_ops: { read: function(stream, buffer2, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes)
            return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) {
            buffer2.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++)
              buffer2[offset + i] = contents[position + i];
          }
          return size;
        }, write: function(stream, buffer2, offset, length, position, canOwn) {
          if (buffer2.buffer === HEAP8.buffer) {
            canOwn = false;
          }
          if (!length)
            return 0;
          var node = stream.node;
          node.timestamp = Date.now();
          if (buffer2.subarray && (!node.contents || node.contents.subarray)) {
            if (canOwn) {
              node.contents = buffer2.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) {
              node.contents = buffer2.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) {
              node.contents.set(buffer2.subarray(offset, offset + length), position);
              return length;
            }
          }
          MEMFS.expandFileStorage(node, position + length);
          if (node.contents.subarray && buffer2.subarray) {
            node.contents.set(buffer2.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
              node.contents[position + i] = buffer2[offset + i];
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        }, llseek: function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        }, allocate: function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        }, mmap: function(stream, address, length, position, prot, flags) {
          if (address !== 0) {
            throw new FS.ErrnoError(28);
          }
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          if (!(flags & 2) && contents.buffer === buffer) {
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = mmapAlloc();
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            ptr >>>= 0;
            HEAP8.set(contents, ptr >>> 0);
          }
          return { ptr, allocated };
        }, msync: function(stream, buffer2, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            return 0;
          }
          MEMFS.stream_ops.write(stream, buffer2, 0, length, offset, false);
          return 0;
        } } };
        function asyncLoad(url, onload, onerror, noRunDep) {
          var dep = !noRunDep ? getUniqueRunDependency("al " + url) : "";
          readAsync(url, function(arrayBuffer) {
            assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
            onload(new Uint8Array(arrayBuffer));
            if (dep)
              removeRunDependency();
          }, function(event) {
            if (onerror) {
              onerror();
            } else {
              throw 'Loading data file "' + url + '" failed.';
            }
          });
          if (dep)
            addRunDependency();
        }
        var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, trackingDelegate: {}, tracking: { openFlags: { READ: 1, WRITE: 2 } }, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, lookupPath: function(path, opts) {
          path = PATH_FS.resolve(FS.cwd(), path);
          opts = opts || {};
          if (!path)
            return { path: "", node: null };
          var defaults = { follow_mount: true, recurse_count: 0 };
          for (var key2 in defaults) {
            if (opts[key2] === void 0) {
              opts[key2] = defaults[key2];
            }
          }
          if (opts.recurse_count > 8) {
            throw new FS.ErrnoError(32);
          }
          var parts = PATH.normalizeArray(path.split("/").filter(function(p) {
            return !!p;
          }), false);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            current = FS.lookupNode(current, parts[i]);
            current_path = PATH.join2(current_path, parts[i]);
            if (FS.isMountpoint(current)) {
              if (!islast || islast && opts.follow_mount) {
                current = current.mounted.root;
              }
            }
            if (!islast || opts.follow) {
              var count = 0;
              while (FS.isLink(current.mode)) {
                var link = FS.readlink(current_path);
                current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
                current = lookup.node;
                if (count++ > 40) {
                  throw new FS.ErrnoError(32);
                }
              }
            }
          }
          return { path: current_path, node: current };
        }, getPath: function(node) {
          var path;
          while (true) {
            if (FS.isRoot(node)) {
              var mount = node.mount.mountpoint;
              if (!path)
                return mount;
              return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
            }
            path = path ? node.name + "/" + path : node.name;
            node = node.parent;
          }
        }, hashName: function(parentid, name2) {
          var hash = 0;
          for (var i = 0; i < name2.length; i++) {
            hash = (hash << 5) - hash + name2.charCodeAt(i) | 0;
          }
          return (parentid + hash >>> 0) % FS.nameTable.length;
        }, hashAddNode: function(node) {
          var hash = FS.hashName(node.parent.id, node.name);
          node.name_next = FS.nameTable[hash];
          FS.nameTable[hash] = node;
        }, hashRemoveNode: function(node) {
          var hash = FS.hashName(node.parent.id, node.name);
          if (FS.nameTable[hash] === node) {
            FS.nameTable[hash] = node.name_next;
          } else {
            var current = FS.nameTable[hash];
            while (current) {
              if (current.name_next === node) {
                current.name_next = node.name_next;
                break;
              }
              current = current.name_next;
            }
          }
        }, lookupNode: function(parent, name2) {
          var errCode = FS.mayLookup(parent);
          if (errCode) {
            throw new FS.ErrnoError(errCode, parent);
          }
          var hash = FS.hashName(parent.id, name2);
          for (var node = FS.nameTable[hash]; node; node = node.name_next) {
            var nodeName = node.name;
            if (node.parent.id === parent.id && nodeName === name2) {
              return node;
            }
          }
          return FS.lookup(parent, name2);
        }, createNode: function(parent, name2, mode, rdev) {
          var node = new FS.FSNode(parent, name2, mode, rdev);
          FS.hashAddNode(node);
          return node;
        }, destroyNode: function(node) {
          FS.hashRemoveNode(node);
        }, isRoot: function(node) {
          return node === node.parent;
        }, isMountpoint: function(node) {
          return !!node.mounted;
        }, isFile: function(mode) {
          return (mode & 61440) === 32768;
        }, isDir: function(mode) {
          return (mode & 61440) === 16384;
        }, isLink: function(mode) {
          return (mode & 61440) === 40960;
        }, isChrdev: function(mode) {
          return (mode & 61440) === 8192;
        }, isBlkdev: function(mode) {
          return (mode & 61440) === 24576;
        }, isFIFO: function(mode) {
          return (mode & 61440) === 4096;
        }, isSocket: function(mode) {
          return (mode & 49152) === 49152;
        }, flagModes: { "r": 0, "r+": 2, "w": 577, "w+": 578, "a": 1089, "a+": 1090 }, modeStringToFlags: function(str) {
          var flags = FS.flagModes[str];
          if (typeof flags === "undefined") {
            throw new Error("Unknown file open mode: " + str);
          }
          return flags;
        }, flagsToPermissionString: function(flag) {
          var perms = ["r", "w", "rw"][flag & 3];
          if (flag & 512) {
            perms += "w";
          }
          return perms;
        }, nodePermissions: function(node, perms) {
          if (FS.ignorePermissions) {
            return 0;
          }
          if (perms.includes("r") && !(node.mode & 292)) {
            return 2;
          } else if (perms.includes("w") && !(node.mode & 146)) {
            return 2;
          } else if (perms.includes("x") && !(node.mode & 73)) {
            return 2;
          }
          return 0;
        }, mayLookup: function(dir) {
          var errCode = FS.nodePermissions(dir, "x");
          if (errCode)
            return errCode;
          if (!dir.node_ops.lookup)
            return 2;
          return 0;
        }, mayCreate: function(dir, name2) {
          try {
            var node = FS.lookupNode(dir, name2);
            return 20;
          } catch (e) {
          }
          return FS.nodePermissions(dir, "wx");
        }, mayDelete: function(dir, name2, isdir) {
          var node;
          try {
            node = FS.lookupNode(dir, name2);
          } catch (e) {
            return e.errno;
          }
          var errCode = FS.nodePermissions(dir, "wx");
          if (errCode) {
            return errCode;
          }
          if (isdir) {
            if (!FS.isDir(node.mode)) {
              return 54;
            }
            if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
              return 10;
            }
          } else {
            if (FS.isDir(node.mode)) {
              return 31;
            }
          }
          return 0;
        }, mayOpen: function(node, flags) {
          if (!node) {
            return 44;
          }
          if (FS.isLink(node.mode)) {
            return 32;
          } else if (FS.isDir(node.mode)) {
            if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
              return 31;
            }
          }
          return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
        }, MAX_OPEN_FDS: 4096, nextfd: function(fd_start, fd_end) {
          fd_start = fd_start || 0;
          fd_end = fd_end || FS.MAX_OPEN_FDS;
          for (var fd = fd_start; fd <= fd_end; fd++) {
            if (!FS.streams[fd]) {
              return fd;
            }
          }
          throw new FS.ErrnoError(33);
        }, getStream: function(fd) {
          return FS.streams[fd];
        }, createStream: function(stream, fd_start, fd_end) {
          if (!FS.FSStream) {
            FS.FSStream = function() {
            };
            FS.FSStream.prototype = { object: { get: function() {
              return this.node;
            }, set: function(val) {
              this.node = val;
            } }, isRead: { get: function() {
              return (this.flags & 2097155) !== 1;
            } }, isWrite: { get: function() {
              return (this.flags & 2097155) !== 0;
            } }, isAppend: { get: function() {
              return this.flags & 1024;
            } } };
          }
          var newStream = new FS.FSStream();
          for (var p in stream) {
            newStream[p] = stream[p];
          }
          stream = newStream;
          var fd = FS.nextfd(fd_start, fd_end);
          stream.fd = fd;
          FS.streams[fd] = stream;
          return stream;
        }, closeStream: function(fd) {
          FS.streams[fd] = null;
        }, chrdev_stream_ops: { open: function(stream) {
          var device = FS.getDevice(stream.node.rdev);
          stream.stream_ops = device.stream_ops;
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        }, llseek: function() {
          throw new FS.ErrnoError(70);
        } }, major: function(dev) {
          return dev >> 8;
        }, minor: function(dev) {
          return dev & 255;
        }, makedev: function(ma, mi) {
          return ma << 8 | mi;
        }, registerDevice: function(dev, ops) {
          FS.devices[dev] = { stream_ops: ops };
        }, getDevice: function(dev) {
          return FS.devices[dev];
        }, getMounts: function(mount) {
          var mounts = [];
          var check = [mount];
          while (check.length) {
            var m = check.pop();
            mounts.push(m);
            check.push.apply(check, m.mounts);
          }
          return mounts;
        }, syncfs: function(populate, callback) {
          if (typeof populate === "function") {
            callback = populate;
            populate = false;
          }
          FS.syncFSRequests++;
          if (FS.syncFSRequests > 1) {
            err("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
          }
          var mounts = FS.getMounts(FS.root.mount);
          var completed = 0;
          function doCallback(errCode) {
            FS.syncFSRequests--;
            return callback(errCode);
          }
          function done(errCode) {
            if (errCode) {
              if (!done.errored) {
                done.errored = true;
                return doCallback(errCode);
              }
              return;
            }
            if (++completed >= mounts.length) {
              doCallback(null);
            }
          }
          mounts.forEach(function(mount) {
            if (!mount.type.syncfs) {
              return done(null);
            }
            mount.type.syncfs(mount, populate, done);
          });
        }, mount: function(type, opts, mountpoint) {
          var root = mountpoint === "/";
          var pseudo = !mountpoint;
          var node;
          if (root && FS.root) {
            throw new FS.ErrnoError(10);
          } else if (!root && !pseudo) {
            var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
            mountpoint = lookup.path;
            node = lookup.node;
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            if (!FS.isDir(node.mode)) {
              throw new FS.ErrnoError(54);
            }
          }
          var mount = { type, opts, mountpoint, mounts: [] };
          var mountRoot = type.mount(mount);
          mountRoot.mount = mount;
          mount.root = mountRoot;
          if (root) {
            FS.root = mountRoot;
          } else if (node) {
            node.mounted = mount;
            if (node.mount) {
              node.mount.mounts.push(mount);
            }
          }
          return mountRoot;
        }, unmount: function(mountpoint) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
          if (!FS.isMountpoint(lookup.node)) {
            throw new FS.ErrnoError(28);
          }
          var node = lookup.node;
          var mount = node.mounted;
          var mounts = FS.getMounts(mount);
          Object.keys(FS.nameTable).forEach(function(hash) {
            var current = FS.nameTable[hash];
            while (current) {
              var next = current.name_next;
              if (mounts.includes(current.mount)) {
                FS.destroyNode(current);
              }
              current = next;
            }
          });
          node.mounted = null;
          var idx = node.mount.mounts.indexOf(mount);
          node.mount.mounts.splice(idx, 1);
        }, lookup: function(parent, name2) {
          return parent.node_ops.lookup(parent, name2);
        }, mknod: function(path, mode, dev) {
          var lookup = FS.lookupPath(path, { parent: true });
          var parent = lookup.node;
          var name2 = PATH.basename(path);
          if (!name2 || name2 === "." || name2 === "..") {
            throw new FS.ErrnoError(28);
          }
          var errCode = FS.mayCreate(parent, name2);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.mknod) {
            throw new FS.ErrnoError(63);
          }
          return parent.node_ops.mknod(parent, name2, mode, dev);
        }, create: function(path, mode) {
          mode = mode !== void 0 ? mode : 438;
          mode &= 4095;
          mode |= 32768;
          return FS.mknod(path, mode, 0);
        }, mkdir: function(path, mode) {
          mode = mode !== void 0 ? mode : 511;
          mode &= 511 | 512;
          mode |= 16384;
          return FS.mknod(path, mode, 0);
        }, mkdirTree: function(path, mode) {
          var dirs = path.split("/");
          var d = "";
          for (var i = 0; i < dirs.length; ++i) {
            if (!dirs[i])
              continue;
            d += "/" + dirs[i];
            try {
              FS.mkdir(d, mode);
            } catch (e) {
              if (e.errno != 20)
                throw e;
            }
          }
        }, mkdev: function(path, mode, dev) {
          if (typeof dev === "undefined") {
            dev = mode;
            mode = 438;
          }
          mode |= 8192;
          return FS.mknod(path, mode, dev);
        }, symlink: function(oldpath, newpath) {
          if (!PATH_FS.resolve(oldpath)) {
            throw new FS.ErrnoError(44);
          }
          var lookup = FS.lookupPath(newpath, { parent: true });
          var parent = lookup.node;
          if (!parent) {
            throw new FS.ErrnoError(44);
          }
          var newname = PATH.basename(newpath);
          var errCode = FS.mayCreate(parent, newname);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.symlink) {
            throw new FS.ErrnoError(63);
          }
          return parent.node_ops.symlink(parent, newname, oldpath);
        }, rename: function(old_path, new_path) {
          var old_dirname = PATH.dirname(old_path);
          var new_dirname = PATH.dirname(new_path);
          var old_name = PATH.basename(old_path);
          var new_name = PATH.basename(new_path);
          var lookup, old_dir, new_dir;
          lookup = FS.lookupPath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = FS.lookupPath(new_path, { parent: true });
          new_dir = lookup.node;
          if (!old_dir || !new_dir)
            throw new FS.ErrnoError(44);
          if (old_dir.mount !== new_dir.mount) {
            throw new FS.ErrnoError(75);
          }
          var old_node = FS.lookupNode(old_dir, old_name);
          var relative = PATH_FS.relative(old_path, new_dirname);
          if (relative.charAt(0) !== ".") {
            throw new FS.ErrnoError(28);
          }
          relative = PATH_FS.relative(new_path, old_dirname);
          if (relative.charAt(0) !== ".") {
            throw new FS.ErrnoError(55);
          }
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (old_node === new_node) {
            return;
          }
          var isdir = FS.isDir(old_node.mode);
          var errCode = FS.mayDelete(old_dir, old_name, isdir);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!old_dir.node_ops.rename) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
            throw new FS.ErrnoError(10);
          }
          if (new_dir !== old_dir) {
            errCode = FS.nodePermissions(old_dir, "w");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
          }
          try {
            if (FS.trackingDelegate["willMovePath"]) {
              FS.trackingDelegate["willMovePath"](old_path, new_path);
            }
          } catch (e) {
            err("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
          }
          FS.hashRemoveNode(old_node);
          try {
            old_dir.node_ops.rename(old_node, new_dir, new_name);
          } catch (e) {
            throw e;
          } finally {
            FS.hashAddNode(old_node);
          }
          try {
            if (FS.trackingDelegate["onMovePath"])
              FS.trackingDelegate["onMovePath"](old_path, new_path);
          } catch (e) {
            err("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
          }
        }, rmdir: function(path) {
          var lookup = FS.lookupPath(path, { parent: true });
          var parent = lookup.node;
          var name2 = PATH.basename(path);
          var node = FS.lookupNode(parent, name2);
          var errCode = FS.mayDelete(parent, name2, true);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.rmdir) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          try {
            if (FS.trackingDelegate["willDeletePath"]) {
              FS.trackingDelegate["willDeletePath"](path);
            }
          } catch (e) {
            err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
          }
          parent.node_ops.rmdir(parent, name2);
          FS.destroyNode(node);
          try {
            if (FS.trackingDelegate["onDeletePath"])
              FS.trackingDelegate["onDeletePath"](path);
          } catch (e) {
            err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
          }
        }, readdir: function(path) {
          var lookup = FS.lookupPath(path, { follow: true });
          var node = lookup.node;
          if (!node.node_ops.readdir) {
            throw new FS.ErrnoError(54);
          }
          return node.node_ops.readdir(node);
        }, unlink: function(path) {
          var lookup = FS.lookupPath(path, { parent: true });
          var parent = lookup.node;
          var name2 = PATH.basename(path);
          var node = FS.lookupNode(parent, name2);
          var errCode = FS.mayDelete(parent, name2, false);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.unlink) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          try {
            if (FS.trackingDelegate["willDeletePath"]) {
              FS.trackingDelegate["willDeletePath"](path);
            }
          } catch (e) {
            err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
          }
          parent.node_ops.unlink(parent, name2);
          FS.destroyNode(node);
          try {
            if (FS.trackingDelegate["onDeletePath"])
              FS.trackingDelegate["onDeletePath"](path);
          } catch (e) {
            err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
          }
        }, readlink: function(path) {
          var lookup = FS.lookupPath(path);
          var link = lookup.node;
          if (!link) {
            throw new FS.ErrnoError(44);
          }
          if (!link.node_ops.readlink) {
            throw new FS.ErrnoError(28);
          }
          return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
        }, stat: function(path, dontFollow) {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          var node = lookup.node;
          if (!node) {
            throw new FS.ErrnoError(44);
          }
          if (!node.node_ops.getattr) {
            throw new FS.ErrnoError(63);
          }
          return node.node_ops.getattr(node);
        }, lstat: function(path) {
          return FS.stat(path, true);
        }, chmod: function(path, mode, dontFollow) {
          var node;
          if (typeof path === "string") {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            node = lookup.node;
          } else {
            node = path;
          }
          if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(63);
          }
          node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now() });
        }, lchmod: function(path, mode) {
          FS.chmod(path, mode, true);
        }, fchmod: function(fd, mode) {
          var stream = FS.getStream(fd);
          if (!stream) {
            throw new FS.ErrnoError(8);
          }
          FS.chmod(stream.node, mode);
        }, chown: function(path, uid, gid, dontFollow) {
          var node;
          if (typeof path === "string") {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            node = lookup.node;
          } else {
            node = path;
          }
          if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(63);
          }
          node.node_ops.setattr(node, { timestamp: Date.now() });
        }, lchown: function(path, uid, gid) {
          FS.chown(path, uid, gid, true);
        }, fchown: function(fd, uid, gid) {
          var stream = FS.getStream(fd);
          if (!stream) {
            throw new FS.ErrnoError(8);
          }
          FS.chown(stream.node, uid, gid);
        }, truncate: function(path, len) {
          if (len < 0) {
            throw new FS.ErrnoError(28);
          }
          var node;
          if (typeof path === "string") {
            var lookup = FS.lookupPath(path, { follow: true });
            node = lookup.node;
          } else {
            node = path;
          }
          if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isDir(node.mode)) {
            throw new FS.ErrnoError(31);
          }
          if (!FS.isFile(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          var errCode = FS.nodePermissions(node, "w");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
        }, ftruncate: function(fd, len) {
          var stream = FS.getStream(fd);
          if (!stream) {
            throw new FS.ErrnoError(8);
          }
          if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(28);
          }
          FS.truncate(stream.node, len);
        }, utime: function(path, atime, mtime) {
          var lookup = FS.lookupPath(path, { follow: true });
          var node = lookup.node;
          node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
        }, open: function(path, flags, mode, fd_start, fd_end) {
          if (path === "") {
            throw new FS.ErrnoError(44);
          }
          flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
          mode = typeof mode === "undefined" ? 438 : mode;
          if (flags & 64) {
            mode = mode & 4095 | 32768;
          } else {
            mode = 0;
          }
          var node;
          if (typeof path === "object") {
            node = path;
          } else {
            path = PATH.normalize(path);
            try {
              var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
              node = lookup.node;
            } catch (e) {
            }
          }
          var created = false;
          if (flags & 64) {
            if (node) {
              if (flags & 128) {
                throw new FS.ErrnoError(20);
              }
            } else {
              node = FS.mknod(path, mode, 0);
              created = true;
            }
          }
          if (!node) {
            throw new FS.ErrnoError(44);
          }
          if (FS.isChrdev(node.mode)) {
            flags &= ~512;
          }
          if (flags & 65536 && !FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
          if (!created) {
            var errCode = FS.mayOpen(node, flags);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
          }
          if (flags & 512) {
            FS.truncate(node, 0);
          }
          flags &= ~(128 | 512 | 131072);
          var stream = FS.createStream({ node, path: FS.getPath(node), flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false }, fd_start, fd_end);
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
          if (Module["logReadFiles"] && !(flags & 1)) {
            if (!FS.readFiles)
              FS.readFiles = {};
            if (!(path in FS.readFiles)) {
              FS.readFiles[path] = 1;
              err("FS.trackingDelegate error on read file: " + path);
            }
          }
          try {
            if (FS.trackingDelegate["onOpenFile"]) {
              var trackingFlags = 0;
              if ((flags & 2097155) !== 1) {
                trackingFlags |= FS.tracking.openFlags.READ;
              }
              if ((flags & 2097155) !== 0) {
                trackingFlags |= FS.tracking.openFlags.WRITE;
              }
              FS.trackingDelegate["onOpenFile"](path, trackingFlags);
            }
          } catch (e) {
            err("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message);
          }
          return stream;
        }, close: function(stream) {
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if (stream.getdents)
            stream.getdents = null;
          try {
            if (stream.stream_ops.close) {
              stream.stream_ops.close(stream);
            }
          } catch (e) {
            throw e;
          } finally {
            FS.closeStream(stream.fd);
          }
          stream.fd = null;
        }, isClosed: function(stream) {
          return stream.fd === null;
        }, llseek: function(stream, offset, whence) {
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if (!stream.seekable || !stream.stream_ops.llseek) {
            throw new FS.ErrnoError(70);
          }
          if (whence != 0 && whence != 1 && whence != 2) {
            throw new FS.ErrnoError(28);
          }
          stream.position = stream.stream_ops.llseek(stream, offset, whence);
          stream.ungotten = [];
          return stream.position;
        }, read: function(stream, buffer2, offset, length, position) {
          offset >>>= 0;
          if (length < 0 || position < 0) {
            throw new FS.ErrnoError(28);
          }
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if ((stream.flags & 2097155) === 1) {
            throw new FS.ErrnoError(8);
          }
          if (FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(31);
          }
          if (!stream.stream_ops.read) {
            throw new FS.ErrnoError(28);
          }
          var seeking = typeof position !== "undefined";
          if (!seeking) {
            position = stream.position;
          } else if (!stream.seekable) {
            throw new FS.ErrnoError(70);
          }
          var bytesRead = stream.stream_ops.read(stream, buffer2, offset, length, position);
          if (!seeking)
            stream.position += bytesRead;
          return bytesRead;
        }, write: function(stream, buffer2, offset, length, position, canOwn) {
          offset >>>= 0;
          if (length < 0 || position < 0) {
            throw new FS.ErrnoError(28);
          }
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(8);
          }
          if (FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(31);
          }
          if (!stream.stream_ops.write) {
            throw new FS.ErrnoError(28);
          }
          if (stream.seekable && stream.flags & 1024) {
            FS.llseek(stream, 0, 2);
          }
          var seeking = typeof position !== "undefined";
          if (!seeking) {
            position = stream.position;
          } else if (!stream.seekable) {
            throw new FS.ErrnoError(70);
          }
          var bytesWritten = stream.stream_ops.write(stream, buffer2, offset, length, position, canOwn);
          if (!seeking)
            stream.position += bytesWritten;
          try {
            if (stream.path && FS.trackingDelegate["onWriteToFile"])
              FS.trackingDelegate["onWriteToFile"](stream.path);
          } catch (e) {
            err("FS.trackingDelegate['onWriteToFile']('" + stream.path + "') threw an exception: " + e.message);
          }
          return bytesWritten;
        }, allocate: function(stream, offset, length) {
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if (offset < 0 || length <= 0) {
            throw new FS.ErrnoError(28);
          }
          if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(8);
          }
          if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (!stream.stream_ops.allocate) {
            throw new FS.ErrnoError(138);
          }
          stream.stream_ops.allocate(stream, offset, length);
        }, mmap: function(stream, address, length, position, prot, flags) {
          address >>>= 0;
          if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
            throw new FS.ErrnoError(2);
          }
          if ((stream.flags & 2097155) === 1) {
            throw new FS.ErrnoError(2);
          }
          if (!stream.stream_ops.mmap) {
            throw new FS.ErrnoError(43);
          }
          return stream.stream_ops.mmap(stream, address, length, position, prot, flags);
        }, msync: function(stream, buffer2, offset, length, mmapFlags) {
          offset >>>= 0;
          if (!stream || !stream.stream_ops.msync) {
            return 0;
          }
          return stream.stream_ops.msync(stream, buffer2, offset, length, mmapFlags);
        }, munmap: function(stream) {
          return 0;
        }, ioctl: function(stream, cmd, arg) {
          if (!stream.stream_ops.ioctl) {
            throw new FS.ErrnoError(59);
          }
          return stream.stream_ops.ioctl(stream, cmd, arg);
        }, readFile: function(path, opts) {
          opts = opts || {};
          opts.flags = opts.flags || 0;
          opts.encoding = opts.encoding || "binary";
          if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
            throw new Error('Invalid encoding type "' + opts.encoding + '"');
          }
          var ret;
          var stream = FS.open(path, opts.flags);
          var stat = FS.stat(path);
          var length = stat.size;
          var buf = new Uint8Array(length);
          FS.read(stream, buf, 0, length, 0);
          if (opts.encoding === "utf8") {
            ret = UTF8ArrayToString(buf, 0);
          } else if (opts.encoding === "binary") {
            ret = buf;
          }
          FS.close(stream);
          return ret;
        }, writeFile: function(path, data, opts) {
          opts = opts || {};
          opts.flags = opts.flags || 577;
          var stream = FS.open(path, opts.flags, opts.mode);
          if (typeof data === "string") {
            var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
            var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
            FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
          } else if (ArrayBuffer.isView(data)) {
            FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
          } else {
            throw new Error("Unsupported data type");
          }
          FS.close(stream);
        }, cwd: function() {
          return FS.currentPath;
        }, chdir: function(path) {
          var lookup = FS.lookupPath(path, { follow: true });
          if (lookup.node === null) {
            throw new FS.ErrnoError(44);
          }
          if (!FS.isDir(lookup.node.mode)) {
            throw new FS.ErrnoError(54);
          }
          var errCode = FS.nodePermissions(lookup.node, "x");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          FS.currentPath = lookup.path;
        }, createDefaultDirectories: function() {
          FS.mkdir("/tmp");
          FS.mkdir("/home");
          FS.mkdir("/home/web_user");
        }, createDefaultDevices: function() {
          FS.mkdir("/dev");
          FS.registerDevice(FS.makedev(1, 3), { read: function() {
            return 0;
          }, write: function(stream, buffer2, offset, length, pos) {
            return length;
          } });
          FS.mkdev("/dev/null", FS.makedev(1, 3));
          TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
          TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
          FS.mkdev("/dev/tty", FS.makedev(5, 0));
          FS.mkdev("/dev/tty1", FS.makedev(6, 0));
          var random_device = getRandomDevice();
          FS.createDevice("/dev", "random", random_device);
          FS.createDevice("/dev", "urandom", random_device);
          FS.mkdir("/dev/shm");
          FS.mkdir("/dev/shm/tmp");
        }, createSpecialDirectories: function() {
          FS.mkdir("/proc");
          var proc_self = FS.mkdir("/proc/self");
          FS.mkdir("/proc/self/fd");
          FS.mount({ mount: function() {
            var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
            node.node_ops = { lookup: function(parent, name2) {
              var fd = +name2;
              var stream = FS.getStream(fd);
              if (!stream)
                throw new FS.ErrnoError(8);
              var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: function() {
                return stream.path;
              } } };
              ret.parent = ret;
              return ret;
            } };
            return node;
          } }, {}, "/proc/self/fd");
        }, createStandardStreams: function() {
          if (Module["stdin"]) {
            FS.createDevice("/dev", "stdin", Module["stdin"]);
          } else {
            FS.symlink("/dev/tty", "/dev/stdin");
          }
          if (Module["stdout"]) {
            FS.createDevice("/dev", "stdout", null, Module["stdout"]);
          } else {
            FS.symlink("/dev/tty", "/dev/stdout");
          }
          if (Module["stderr"]) {
            FS.createDevice("/dev", "stderr", null, Module["stderr"]);
          } else {
            FS.symlink("/dev/tty1", "/dev/stderr");
          }
          FS.open("/dev/stdin", 0);
          FS.open("/dev/stdout", 1);
          FS.open("/dev/stderr", 1);
        }, ensureErrnoError: function() {
          if (FS.ErrnoError)
            return;
          FS.ErrnoError = function ErrnoError(errno, node) {
            this.node = node;
            this.setErrno = function(errno2) {
              this.errno = errno2;
            };
            this.setErrno(errno);
            this.message = "FS error";
          };
          FS.ErrnoError.prototype = new Error();
          FS.ErrnoError.prototype.constructor = FS.ErrnoError;
          [44].forEach(function(code) {
            FS.genericErrors[code] = new FS.ErrnoError(code);
            FS.genericErrors[code].stack = "<generic error, no stack>";
          });
        }, staticInit: function() {
          FS.ensureErrnoError();
          FS.nameTable = new Array(4096);
          FS.mount(MEMFS, {}, "/");
          FS.createDefaultDirectories();
          FS.createDefaultDevices();
          FS.createSpecialDirectories();
          FS.filesystems = { "MEMFS": MEMFS };
        }, init: function(input, output, error) {
          FS.init.initialized = true;
          FS.ensureErrnoError();
          Module["stdin"] = input || Module["stdin"];
          Module["stdout"] = output || Module["stdout"];
          Module["stderr"] = error || Module["stderr"];
          FS.createStandardStreams();
        }, quit: function() {
          FS.init.initialized = false;
          var fflush = Module["_fflush"];
          if (fflush)
            fflush(0);
          for (var i = 0; i < FS.streams.length; i++) {
            var stream = FS.streams[i];
            if (!stream) {
              continue;
            }
            FS.close(stream);
          }
        }, getMode: function(canRead, canWrite) {
          var mode = 0;
          if (canRead)
            mode |= 292 | 73;
          if (canWrite)
            mode |= 146;
          return mode;
        }, findObject: function(path, dontResolveLastLink) {
          var ret = FS.analyzePath(path, dontResolveLastLink);
          if (ret.exists) {
            return ret.object;
          } else {
            return null;
          }
        }, analyzePath: function(path, dontResolveLastLink) {
          try {
            var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
            path = lookup.path;
          } catch (e) {
          }
          var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
          try {
            var lookup = FS.lookupPath(path, { parent: true });
            ret.parentExists = true;
            ret.parentPath = lookup.path;
            ret.parentObject = lookup.node;
            ret.name = PATH.basename(path);
            lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
            ret.exists = true;
            ret.path = lookup.path;
            ret.object = lookup.node;
            ret.name = lookup.node.name;
            ret.isRoot = lookup.path === "/";
          } catch (e) {
            ret.error = e.errno;
          }
          return ret;
        }, createPath: function(parent, path, canRead, canWrite) {
          parent = typeof parent === "string" ? parent : FS.getPath(parent);
          var parts = path.split("/").reverse();
          while (parts.length) {
            var part = parts.pop();
            if (!part)
              continue;
            var current = PATH.join2(parent, part);
            try {
              FS.mkdir(current);
            } catch (e) {
            }
            parent = current;
          }
          return current;
        }, createFile: function(parent, name2, properties, canRead, canWrite) {
          var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
          var mode = FS.getMode(canRead, canWrite);
          return FS.create(path, mode);
        }, createDataFile: function(parent, name2, data, canRead, canWrite, canOwn) {
          var path = name2 ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2) : parent;
          var mode = FS.getMode(canRead, canWrite);
          var node = FS.create(path, mode);
          if (data) {
            if (typeof data === "string") {
              var arr = new Array(data.length);
              for (var i = 0, len = data.length; i < len; ++i)
                arr[i] = data.charCodeAt(i);
              data = arr;
            }
            FS.chmod(node, mode | 146);
            var stream = FS.open(node, 577);
            FS.write(stream, data, 0, data.length, 0, canOwn);
            FS.close(stream);
            FS.chmod(node, mode);
          }
          return node;
        }, createDevice: function(parent, name2, input, output) {
          var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
          var mode = FS.getMode(!!input, !!output);
          if (!FS.createDevice.major)
            FS.createDevice.major = 64;
          var dev = FS.makedev(FS.createDevice.major++, 0);
          FS.registerDevice(dev, { open: function(stream) {
            stream.seekable = false;
          }, close: function(stream) {
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          }, read: function(stream, buffer2, offset, length, pos) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === void 0 && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === void 0)
                break;
              bytesRead++;
              buffer2[offset + i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          }, write: function(stream, buffer2, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer2[offset + i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          } });
          return FS.mkdev(path, mode, dev);
        }, forceLoadFile: function(obj) {
          if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
            return true;
          if (typeof XMLHttpRequest !== "undefined") {
            throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
          } else if (read_) {
            try {
              obj.contents = intArrayFromString(read_(obj.url), true);
              obj.usedBytes = obj.contents.length;
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          } else {
            throw new Error("Cannot load without read() or XMLHttpRequest.");
          }
        }, createLazyFile: function(parent, name2, url, canRead, canWrite) {
          function LazyUint8Array() {
            this.lengthKnown = false;
            this.chunks = [];
          }
          LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
            if (idx > this.length - 1 || idx < 0) {
              return void 0;
            }
            var chunkOffset = idx % this.chunkSize;
            var chunkNum = idx / this.chunkSize | 0;
            return this.getter(chunkNum)[chunkOffset];
          };
          LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
            this.getter = getter;
          };
          LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
            var xhr = new XMLHttpRequest();
            xhr.open("HEAD", url, false);
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
              throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            var datalength = Number(xhr.getResponseHeader("Content-length"));
            var header;
            var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
            var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
            var chunkSize = 1024 * 1024;
            if (!hasByteServing)
              chunkSize = datalength;
            var doXHR = function(from, to) {
              if (from > to)
                throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
              if (to > datalength - 1)
                throw new Error("only " + datalength + " bytes available! programmer error!");
              var xhr2 = new XMLHttpRequest();
              xhr2.open("GET", url, false);
              if (datalength !== chunkSize)
                xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
              if (typeof Uint8Array != "undefined")
                xhr2.responseType = "arraybuffer";
              if (xhr2.overrideMimeType) {
                xhr2.overrideMimeType("text/plain; charset=x-user-defined");
              }
              xhr2.send(null);
              if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
                throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
              if (xhr2.response !== void 0) {
                return new Uint8Array(xhr2.response || []);
              } else {
                return intArrayFromString(xhr2.responseText || "", true);
              }
            };
            var lazyArray2 = this;
            lazyArray2.setDataGetter(function(chunkNum) {
              var start = chunkNum * chunkSize;
              var end = (chunkNum + 1) * chunkSize - 1;
              end = Math.min(end, datalength - 1);
              if (typeof lazyArray2.chunks[chunkNum] === "undefined") {
                lazyArray2.chunks[chunkNum] = doXHR(start, end);
              }
              if (typeof lazyArray2.chunks[chunkNum] === "undefined")
                throw new Error("doXHR failed!");
              return lazyArray2.chunks[chunkNum];
            });
            if (usesGzip || !datalength) {
              chunkSize = datalength = 1;
              datalength = this.getter(0).length;
              chunkSize = datalength;
              out("LazyFiles on gzip forces download of the whole file when length is accessed");
            }
            this._length = datalength;
            this._chunkSize = chunkSize;
            this.lengthKnown = true;
          };
          if (typeof XMLHttpRequest !== "undefined") {
            if (!ENVIRONMENT_IS_WORKER)
              throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
            var lazyArray = new LazyUint8Array();
            Object.defineProperties(lazyArray, { length: { get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._length;
            } }, chunkSize: { get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._chunkSize;
            } } });
            var properties = { isDevice: false, contents: lazyArray };
          } else {
            var properties = { isDevice: false, url };
          }
          var node = FS.createFile(parent, name2, properties, canRead, canWrite);
          if (properties.contents) {
            node.contents = properties.contents;
          } else if (properties.url) {
            node.contents = null;
            node.url = properties.url;
          }
          Object.defineProperties(node, { usedBytes: { get: function() {
            return this.contents.length;
          } } });
          var stream_ops = {};
          var keys = Object.keys(node.stream_ops);
          keys.forEach(function(key2) {
            var fn = node.stream_ops[key2];
            stream_ops[key2] = function forceLoadLazyFile() {
              FS.forceLoadFile(node);
              return fn.apply(null, arguments);
            };
          });
          stream_ops.read = function stream_ops_read(stream, buffer2, offset, length, position) {
            FS.forceLoadFile(node);
            var contents = stream.node.contents;
            if (position >= contents.length)
              return 0;
            var size = Math.min(contents.length - position, length);
            if (contents.slice) {
              for (var i = 0; i < size; i++) {
                buffer2[offset + i] = contents[position + i];
              }
            } else {
              for (var i = 0; i < size; i++) {
                buffer2[offset + i] = contents.get(position + i);
              }
            }
            return size;
          };
          node.stream_ops = stream_ops;
          return node;
        }, createPreloadedFile: function(parent, name2, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
          Browser.init();
          var fullname = name2 ? PATH_FS.resolve(PATH.join2(parent, name2)) : parent;
          function processData(byteArray) {
            function finish(byteArray2) {
              if (preFinish)
                preFinish();
              if (!dontCreateFile) {
                FS.createDataFile(parent, name2, byteArray2, canRead, canWrite, canOwn);
              }
              if (onload)
                onload();
              removeRunDependency();
            }
            var handled = false;
            Module["preloadPlugins"].forEach(function(plugin) {
              if (handled)
                return;
              if (plugin["canHandle"](fullname)) {
                plugin["handle"](byteArray, fullname, finish, function() {
                  if (onerror)
                    onerror();
                  removeRunDependency();
                });
                handled = true;
              }
            });
            if (!handled)
              finish(byteArray);
          }
          addRunDependency();
          if (typeof url == "string") {
            asyncLoad(url, function(byteArray) {
              processData(byteArray);
            }, onerror);
          } else {
            processData(url);
          }
        }, indexedDB: function() {
          return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        }, DB_NAME: function() {
          return "EM_FS_" + window.location.pathname;
        }, DB_VERSION: 20, DB_STORE_NAME: "FILE_DATA", saveFilesToDB: function(paths, onload, onerror) {
          onload = onload || function() {
          };
          onerror = onerror || function() {
          };
          var indexedDB = FS.indexedDB();
          try {
            var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
          } catch (e) {
            return onerror(e);
          }
          openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
            out("creating db");
            var db = openRequest.result;
            db.createObjectStore(FS.DB_STORE_NAME);
          };
          openRequest.onsuccess = function openRequest_onsuccess() {
            var db = openRequest.result;
            var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
            var files = transaction.objectStore(FS.DB_STORE_NAME);
            var ok = 0, fail = 0, total = paths.length;
            function finish() {
              if (fail == 0)
                onload();
              else
                onerror();
            }
            paths.forEach(function(path) {
              var putRequest = files.put(FS.analyzePath(path).object.contents, path);
              putRequest.onsuccess = function putRequest_onsuccess() {
                ok++;
                if (ok + fail == total)
                  finish();
              };
              putRequest.onerror = function putRequest_onerror() {
                fail++;
                if (ok + fail == total)
                  finish();
              };
            });
            transaction.onerror = onerror;
          };
          openRequest.onerror = onerror;
        }, loadFilesFromDB: function(paths, onload, onerror) {
          onload = onload || function() {
          };
          onerror = onerror || function() {
          };
          var indexedDB = FS.indexedDB();
          try {
            var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
          } catch (e) {
            return onerror(e);
          }
          openRequest.onupgradeneeded = onerror;
          openRequest.onsuccess = function openRequest_onsuccess() {
            var db = openRequest.result;
            try {
              var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
            } catch (e) {
              onerror(e);
              return;
            }
            var files = transaction.objectStore(FS.DB_STORE_NAME);
            var ok = 0, fail = 0, total = paths.length;
            function finish() {
              if (fail == 0)
                onload();
              else
                onerror();
            }
            paths.forEach(function(path) {
              var getRequest = files.get(path);
              getRequest.onsuccess = function getRequest_onsuccess() {
                if (FS.analyzePath(path).exists) {
                  FS.unlink(path);
                }
                FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
                ok++;
                if (ok + fail == total)
                  finish();
              };
              getRequest.onerror = function getRequest_onerror() {
                fail++;
                if (ok + fail == total)
                  finish();
              };
            });
            transaction.onerror = onerror;
          };
          openRequest.onerror = onerror;
        } };
        var SYSCALLS = { mappings: {}, DEFAULT_POLLMASK: 5, umask: 511, calculateAt: function(dirfd, path, allowEmpty) {
          if (path[0] === "/") {
            return path;
          }
          var dir;
          if (dirfd === -100) {
            dir = FS.cwd();
          } else {
            var dirstream = FS.getStream(dirfd);
            if (!dirstream)
              throw new FS.ErrnoError(8);
            dir = dirstream.path;
          }
          if (path.length == 0) {
            if (!allowEmpty) {
              throw new FS.ErrnoError(44);
            }
            return dir;
          }
          return PATH.join2(dir, path);
        }, doStat: function(func, path, buf) {
          try {
            var stat = func(path);
          } catch (e) {
            if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
              return -54;
            }
            throw e;
          }
          HEAP32[buf >>> 2] = stat.dev;
          HEAP32[buf + 4 >>> 2] = 0;
          HEAP32[buf + 8 >>> 2] = stat.ino;
          HEAP32[buf + 12 >>> 2] = stat.mode;
          HEAP32[buf + 16 >>> 2] = stat.nlink;
          HEAP32[buf + 20 >>> 2] = stat.uid;
          HEAP32[buf + 24 >>> 2] = stat.gid;
          HEAP32[buf + 28 >>> 2] = stat.rdev;
          HEAP32[buf + 32 >>> 2] = 0;
          tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >>> 2] = tempI64[0], HEAP32[buf + 44 >>> 2] = tempI64[1];
          HEAP32[buf + 48 >>> 2] = 4096;
          HEAP32[buf + 52 >>> 2] = stat.blocks;
          HEAP32[buf + 56 >>> 2] = stat.atime.getTime() / 1e3 | 0;
          HEAP32[buf + 60 >>> 2] = 0;
          HEAP32[buf + 64 >>> 2] = stat.mtime.getTime() / 1e3 | 0;
          HEAP32[buf + 68 >>> 2] = 0;
          HEAP32[buf + 72 >>> 2] = stat.ctime.getTime() / 1e3 | 0;
          HEAP32[buf + 76 >>> 2] = 0;
          tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 80 >>> 2] = tempI64[0], HEAP32[buf + 84 >>> 2] = tempI64[1];
          return 0;
        }, doMsync: function(addr, stream, len, flags, offset) {
          var buffer2 = HEAPU8.slice(addr, addr + len);
          FS.msync(stream, buffer2, offset, len, flags);
        }, doMkdir: function(path, mode) {
          path = PATH.normalize(path);
          if (path[path.length - 1] === "/")
            path = path.substr(0, path.length - 1);
          FS.mkdir(path, mode, 0);
          return 0;
        }, doMknod: function(path, mode, dev) {
          switch (mode & 61440) {
            case 32768:
            case 8192:
            case 24576:
            case 4096:
            case 49152:
              break;
            default:
              return -28;
          }
          FS.mknod(path, mode, dev);
          return 0;
        }, doReadlink: function(path, buf, bufsize) {
          if (bufsize <= 0)
            return -28;
          var ret = FS.readlink(path);
          var len = Math.min(bufsize, lengthBytesUTF8(ret));
          var endChar = HEAP8[buf + len >>> 0];
          stringToUTF8(ret, buf, bufsize + 1);
          HEAP8[buf + len >>> 0] = endChar;
          return len;
        }, doAccess: function(path, amode) {
          if (amode & ~7) {
            return -28;
          }
          var node;
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
          if (!node) {
            return -44;
          }
          var perms = "";
          if (amode & 4)
            perms += "r";
          if (amode & 2)
            perms += "w";
          if (amode & 1)
            perms += "x";
          if (perms && FS.nodePermissions(node, perms)) {
            return -2;
          }
          return 0;
        }, doDup: function(path, flags, suggestFD) {
          var suggest = FS.getStream(suggestFD);
          if (suggest)
            FS.close(suggest);
          return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
        }, doReadv: function(stream, iov, iovcnt, offset) {
          var ret = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = HEAP32[iov + i * 8 >>> 2];
            var len = HEAP32[iov + (i * 8 + 4) >>> 2];
            var curr = FS.read(stream, HEAP8, ptr, len, offset);
            if (curr < 0)
              return -1;
            ret += curr;
            if (curr < len)
              break;
          }
          return ret;
        }, doWritev: function(stream, iov, iovcnt, offset) {
          var ret = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = HEAP32[iov + i * 8 >>> 2];
            var len = HEAP32[iov + (i * 8 + 4) >>> 2];
            var curr = FS.write(stream, HEAP8, ptr, len, offset);
            if (curr < 0)
              return -1;
            ret += curr;
          }
          return ret;
        }, varargs: void 0, get: function() {
          SYSCALLS.varargs += 4;
          var ret = HEAP32[SYSCALLS.varargs - 4 >>> 2];
          return ret;
        }, getStr: function(ptr) {
          var ret = UTF8ToString(ptr);
          return ret;
        }, getStreamFromFD: function(fd) {
          var stream = FS.getStream(fd);
          if (!stream)
            throw new FS.ErrnoError(8);
          return stream;
        }, get64: function(low, high) {
          return low;
        } };
        function ___sys_fcntl64(fd, cmd, varargs) {
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (cmd) {
              case 0: {
                var arg = SYSCALLS.get();
                if (arg < 0) {
                  return -28;
                }
                var newStream;
                newStream = FS.open(stream.path, stream.flags, 0, arg);
                return newStream.fd;
              }
              case 1:
              case 2:
                return 0;
              case 3:
                return stream.flags;
              case 4: {
                var arg = SYSCALLS.get();
                stream.flags |= arg;
                return 0;
              }
              case 12: {
                var arg = SYSCALLS.get();
                var offset = 0;
                HEAP16[arg + offset >>> 1] = 2;
                return 0;
              }
              case 13:
              case 14:
                return 0;
              case 16:
              case 8:
                return -28;
              case 9:
                setErrNo(28);
                return -1;
              default: {
                return -28;
              }
            }
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        function ___sys_ioctl(fd, op, varargs) {
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (op) {
              case 21509:
              case 21505: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21510:
              case 21511:
              case 21512:
              case 21506:
              case 21507:
              case 21508: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21519: {
                if (!stream.tty)
                  return -59;
                var argp = SYSCALLS.get();
                HEAP32[argp >>> 2] = 0;
                return 0;
              }
              case 21520: {
                if (!stream.tty)
                  return -59;
                return -28;
              }
              case 21531: {
                var argp = SYSCALLS.get();
                return FS.ioctl(stream, op, argp);
              }
              case 21523: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21524: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              default:
                abort("bad ioctl syscall " + op);
            }
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        function ___sys_open(path, flags, varargs) {
          SYSCALLS.varargs = varargs;
          try {
            var pathname = SYSCALLS.getStr(path);
            var mode = varargs ? SYSCALLS.get() : 0;
            var stream = FS.open(pathname, flags, mode);
            return stream.fd;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        var tupleRegistrations = {};
        function runDestructors(destructors) {
          while (destructors.length) {
            var ptr = destructors.pop();
            var del = destructors.pop();
            del(ptr);
          }
        }
        function simpleReadValueFromPointer(pointer) {
          return this["fromWireType"](HEAPU32[pointer >>> 2]);
        }
        var awaitingDependencies = {};
        var registeredTypes = {};
        var typeDependencies = {};
        var char_0 = 48;
        var char_9 = 57;
        function makeLegalFunctionName(name2) {
          if (name2 === void 0) {
            return "_unknown";
          }
          name2 = name2.replace(/[^a-zA-Z0-9_]/g, "$");
          var f = name2.charCodeAt(0);
          if (f >= char_0 && f <= char_9) {
            return "_" + name2;
          } else {
            return name2;
          }
        }
        function createNamedFunction(name2, body) {
          name2 = makeLegalFunctionName(name2);
          return new Function("body", "return function " + name2 + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(body);
        }
        function extendError(baseErrorType, errorName) {
          var errorClass = createNamedFunction(errorName, function(message) {
            this.name = errorName;
            this.message = message;
            var stack = new Error(message).stack;
            if (stack !== void 0) {
              this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
            }
          });
          errorClass.prototype = Object.create(baseErrorType.prototype);
          errorClass.prototype.constructor = errorClass;
          errorClass.prototype.toString = function() {
            if (this.message === void 0) {
              return this.name;
            } else {
              return this.name + ": " + this.message;
            }
          };
          return errorClass;
        }
        var InternalError = void 0;
        function throwInternalError(message) {
          throw new InternalError(message);
        }
        function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
          myTypes.forEach(function(type) {
            typeDependencies[type] = dependentTypes;
          });
          function onComplete(typeConverters2) {
            var myTypeConverters = getTypeConverters(typeConverters2);
            if (myTypeConverters.length !== myTypes.length) {
              throwInternalError("Mismatched type converter count");
            }
            for (var i = 0; i < myTypes.length; ++i) {
              registerType(myTypes[i], myTypeConverters[i]);
            }
          }
          var typeConverters = new Array(dependentTypes.length);
          var unregisteredTypes = [];
          var registered = 0;
          dependentTypes.forEach(function(dt, i) {
            if (registeredTypes.hasOwnProperty(dt)) {
              typeConverters[i] = registeredTypes[dt];
            } else {
              unregisteredTypes.push(dt);
              if (!awaitingDependencies.hasOwnProperty(dt)) {
                awaitingDependencies[dt] = [];
              }
              awaitingDependencies[dt].push(function() {
                typeConverters[i] = registeredTypes[dt];
                ++registered;
                if (registered === unregisteredTypes.length) {
                  onComplete(typeConverters);
                }
              });
            }
          });
          if (unregisteredTypes.length === 0) {
            onComplete(typeConverters);
          }
        }
        function __embind_finalize_value_array(rawTupleType) {
          var reg = tupleRegistrations[rawTupleType];
          delete tupleRegistrations[rawTupleType];
          var elements = reg.elements;
          var elementsLength = elements.length;
          var elementTypes = elements.map(function(elt) {
            return elt.getterReturnType;
          }).concat(elements.map(function(elt) {
            return elt.setterArgumentType;
          }));
          var rawConstructor = reg.rawConstructor;
          var rawDestructor = reg.rawDestructor;
          whenDependentTypesAreResolved([rawTupleType], elementTypes, function(elementTypes2) {
            elements.forEach(function(elt, i) {
              var getterReturnType = elementTypes2[i];
              var getter = elt.getter;
              var getterContext = elt.getterContext;
              var setterArgumentType = elementTypes2[i + elementsLength];
              var setter = elt.setter;
              var setterContext = elt.setterContext;
              elt.read = function(ptr) {
                return getterReturnType["fromWireType"](getter(getterContext, ptr));
              };
              elt.write = function(ptr, o) {
                var destructors = [];
                setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                runDestructors(destructors);
              };
            });
            return [{ name: reg.name, "fromWireType": function(ptr) {
              var rv = new Array(elementsLength);
              for (var i = 0; i < elementsLength; ++i) {
                rv[i] = elements[i].read(ptr);
              }
              rawDestructor(ptr);
              return rv;
            }, "toWireType": function(destructors, o) {
              if (elementsLength !== o.length) {
                throw new TypeError("Incorrect number of tuple elements for " + reg.name + ": expected=" + elementsLength + ", actual=" + o.length);
              }
              var ptr = rawConstructor();
              for (var i = 0; i < elementsLength; ++i) {
                elements[i].write(ptr, o[i]);
              }
              if (destructors !== null) {
                destructors.push(rawDestructor, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: rawDestructor }];
          });
        }
        var structRegistrations = {};
        function __embind_finalize_value_object(structType) {
          var reg = structRegistrations[structType];
          delete structRegistrations[structType];
          var rawConstructor = reg.rawConstructor;
          var rawDestructor = reg.rawDestructor;
          var fieldRecords = reg.fields;
          var fieldTypes = fieldRecords.map(function(field) {
            return field.getterReturnType;
          }).concat(fieldRecords.map(function(field) {
            return field.setterArgumentType;
          }));
          whenDependentTypesAreResolved([structType], fieldTypes, function(fieldTypes2) {
            var fields = {};
            fieldRecords.forEach(function(field, i) {
              var fieldName = field.fieldName;
              var getterReturnType = fieldTypes2[i];
              var getter = field.getter;
              var getterContext = field.getterContext;
              var setterArgumentType = fieldTypes2[i + fieldRecords.length];
              var setter = field.setter;
              var setterContext = field.setterContext;
              fields[fieldName] = { read: function(ptr) {
                return getterReturnType["fromWireType"](getter(getterContext, ptr));
              }, write: function(ptr, o) {
                var destructors = [];
                setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                runDestructors(destructors);
              } };
            });
            return [{ name: reg.name, "fromWireType": function(ptr) {
              var rv = {};
              for (var i in fields) {
                rv[i] = fields[i].read(ptr);
              }
              rawDestructor(ptr);
              return rv;
            }, "toWireType": function(destructors, o) {
              for (var fieldName in fields) {
                if (!(fieldName in o)) {
                  throw new TypeError('Missing field:  "' + fieldName + '"');
                }
              }
              var ptr = rawConstructor();
              for (fieldName in fields) {
                fields[fieldName].write(ptr, o[fieldName]);
              }
              if (destructors !== null) {
                destructors.push(rawDestructor, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: rawDestructor }];
          });
        }
        function __embind_register_bigint(primitiveType, name2, size, minRange, maxRange) {
        }
        function getShiftFromSize(size) {
          switch (size) {
            case 1:
              return 0;
            case 2:
              return 1;
            case 4:
              return 2;
            case 8:
              return 3;
            default:
              throw new TypeError("Unknown type size: " + size);
          }
        }
        function embind_init_charCodes() {
          var codes = new Array(256);
          for (var i = 0; i < 256; ++i) {
            codes[i] = String.fromCharCode(i);
          }
          embind_charCodes = codes;
        }
        var embind_charCodes = void 0;
        function readLatin1String(ptr) {
          var ret = "";
          var c = ptr;
          while (HEAPU8[c >>> 0]) {
            ret += embind_charCodes[HEAPU8[c++ >>> 0]];
          }
          return ret;
        }
        var BindingError = void 0;
        function throwBindingError(message) {
          throw new BindingError(message);
        }
        function registerType(rawType, registeredInstance, options) {
          options = options || {};
          if (!("argPackAdvance" in registeredInstance)) {
            throw new TypeError("registerType registeredInstance requires argPackAdvance");
          }
          var name2 = registeredInstance.name;
          if (!rawType) {
            throwBindingError('type "' + name2 + '" must have a positive integer typeid pointer');
          }
          if (registeredTypes.hasOwnProperty(rawType)) {
            if (options.ignoreDuplicateRegistrations) {
              return;
            } else {
              throwBindingError("Cannot register type '" + name2 + "' twice");
            }
          }
          registeredTypes[rawType] = registeredInstance;
          delete typeDependencies[rawType];
          if (awaitingDependencies.hasOwnProperty(rawType)) {
            var callbacks = awaitingDependencies[rawType];
            delete awaitingDependencies[rawType];
            callbacks.forEach(function(cb) {
              cb();
            });
          }
        }
        function __embind_register_bool(rawType, name2, size, trueValue, falseValue) {
          var shift = getShiftFromSize(size);
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": function(wt) {
            return !!wt;
          }, "toWireType": function(destructors, o) {
            return o ? trueValue : falseValue;
          }, "argPackAdvance": 8, "readValueFromPointer": function(pointer) {
            var heap;
            if (size === 1) {
              heap = HEAP8;
            } else if (size === 2) {
              heap = HEAP16;
            } else if (size === 4) {
              heap = HEAP32;
            } else {
              throw new TypeError("Unknown boolean type size: " + name2);
            }
            return this["fromWireType"](heap[pointer >>> shift]);
          }, destructorFunction: null });
        }
        function ClassHandle_isAliasOf(other) {
          if (!(this instanceof ClassHandle)) {
            return false;
          }
          if (!(other instanceof ClassHandle)) {
            return false;
          }
          var leftClass = this.$$.ptrType.registeredClass;
          var left = this.$$.ptr;
          var rightClass = other.$$.ptrType.registeredClass;
          var right = other.$$.ptr;
          while (leftClass.baseClass) {
            left = leftClass.upcast(left);
            leftClass = leftClass.baseClass;
          }
          while (rightClass.baseClass) {
            right = rightClass.upcast(right);
            rightClass = rightClass.baseClass;
          }
          return leftClass === rightClass && left === right;
        }
        function shallowCopyInternalPointer(o) {
          return { count: o.count, deleteScheduled: o.deleteScheduled, preservePointerOnDelete: o.preservePointerOnDelete, ptr: o.ptr, ptrType: o.ptrType, smartPtr: o.smartPtr, smartPtrType: o.smartPtrType };
        }
        function throwInstanceAlreadyDeleted(obj) {
          function getInstanceTypeName(handle) {
            return handle.$$.ptrType.registeredClass.name;
          }
          throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
        }
        var finalizationGroup = false;
        function detachFinalizer(handle) {
        }
        function runDestructor($$) {
          if ($$.smartPtr) {
            $$.smartPtrType.rawDestructor($$.smartPtr);
          } else {
            $$.ptrType.registeredClass.rawDestructor($$.ptr);
          }
        }
        function releaseClassHandle($$) {
          $$.count.value -= 1;
          var toDelete = $$.count.value === 0;
          if (toDelete) {
            runDestructor($$);
          }
        }
        function attachFinalizer(handle) {
          if (typeof FinalizationGroup === "undefined") {
            attachFinalizer = function(handle2) {
              return handle2;
            };
            return handle;
          }
          finalizationGroup = new FinalizationGroup(function(iter) {
            for (var result = iter.next(); !result.done; result = iter.next()) {
              var $$ = result.value;
              if (!$$.ptr) {
                console.warn("object already deleted: " + $$.ptr);
              } else {
                releaseClassHandle($$);
              }
            }
          });
          attachFinalizer = function(handle2) {
            finalizationGroup.register(handle2, handle2.$$, handle2.$$);
            return handle2;
          };
          detachFinalizer = function(handle2) {
            finalizationGroup.unregister(handle2.$$);
          };
          return attachFinalizer(handle);
        }
        function ClassHandle_clone() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.preservePointerOnDelete) {
            this.$$.count.value += 1;
            return this;
          } else {
            var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), { $$: { value: shallowCopyInternalPointer(this.$$) } }));
            clone.$$.count.value += 1;
            clone.$$.deleteScheduled = false;
            return clone;
          }
        }
        function ClassHandle_delete() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
            throwBindingError("Object already scheduled for deletion");
          }
          detachFinalizer(this);
          releaseClassHandle(this.$$);
          if (!this.$$.preservePointerOnDelete) {
            this.$$.smartPtr = void 0;
            this.$$.ptr = void 0;
          }
        }
        function ClassHandle_isDeleted() {
          return !this.$$.ptr;
        }
        var delayFunction = void 0;
        var deletionQueue = [];
        function flushPendingDeletes() {
          while (deletionQueue.length) {
            var obj = deletionQueue.pop();
            obj.$$.deleteScheduled = false;
            obj["delete"]();
          }
        }
        function ClassHandle_deleteLater() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
            throwBindingError("Object already scheduled for deletion");
          }
          deletionQueue.push(this);
          if (deletionQueue.length === 1 && delayFunction) {
            delayFunction(flushPendingDeletes);
          }
          this.$$.deleteScheduled = true;
          return this;
        }
        function init_ClassHandle() {
          ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;
          ClassHandle.prototype["clone"] = ClassHandle_clone;
          ClassHandle.prototype["delete"] = ClassHandle_delete;
          ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;
          ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
        }
        function ClassHandle() {
        }
        var registeredPointers = {};
        function ensureOverloadTable(proto, methodName, humanName) {
          if (proto[methodName].overloadTable === void 0) {
            var prevFunc = proto[methodName];
            proto[methodName] = function() {
              if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
              }
              return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
            };
            proto[methodName].overloadTable = [];
            proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
          }
        }
        function exposePublicSymbol(name2, value, numArguments) {
          if (Module.hasOwnProperty(name2)) {
            if (numArguments === void 0 || Module[name2].overloadTable !== void 0 && Module[name2].overloadTable[numArguments] !== void 0) {
              throwBindingError("Cannot register public name '" + name2 + "' twice");
            }
            ensureOverloadTable(Module, name2, name2);
            if (Module.hasOwnProperty(numArguments)) {
              throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
            }
            Module[name2].overloadTable[numArguments] = value;
          } else {
            Module[name2] = value;
            if (numArguments !== void 0) {
              Module[name2].numArguments = numArguments;
            }
          }
        }
        function RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
          this.name = name2;
          this.constructor = constructor;
          this.instancePrototype = instancePrototype;
          this.rawDestructor = rawDestructor;
          this.baseClass = baseClass;
          this.getActualType = getActualType;
          this.upcast = upcast;
          this.downcast = downcast;
          this.pureVirtualFunctions = [];
        }
        function upcastPointer(ptr, ptrClass, desiredClass) {
          while (ptrClass !== desiredClass) {
            if (!ptrClass.upcast) {
              throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
            }
            ptr = ptrClass.upcast(ptr);
            ptrClass = ptrClass.baseClass;
          }
          return ptr;
        }
        function constNoSmartPtrRawPointerToWireType(destructors, handle) {
          if (handle === null) {
            if (this.isReference) {
              throwBindingError("null is not a valid " + this.name);
            }
            return 0;
          }
          if (!handle.$$) {
            throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
          }
          if (!handle.$$.ptr) {
            throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          return ptr;
        }
        function genericPointerToWireType(destructors, handle) {
          var ptr;
          if (handle === null) {
            if (this.isReference) {
              throwBindingError("null is not a valid " + this.name);
            }
            if (this.isSmartPointer) {
              ptr = this.rawConstructor();
              if (destructors !== null) {
                destructors.push(this.rawDestructor, ptr);
              }
              return ptr;
            } else {
              return 0;
            }
          }
          if (!handle.$$) {
            throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
          }
          if (!handle.$$.ptr) {
            throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
          }
          if (!this.isConst && handle.$$.ptrType.isConst) {
            throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          if (this.isSmartPointer) {
            if (handle.$$.smartPtr === void 0) {
              throwBindingError("Passing raw pointer to smart pointer is illegal");
            }
            switch (this.sharingPolicy) {
              case 0:
                if (handle.$$.smartPtrType === this) {
                  ptr = handle.$$.smartPtr;
                } else {
                  throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
                }
                break;
              case 1:
                ptr = handle.$$.smartPtr;
                break;
              case 2:
                if (handle.$$.smartPtrType === this) {
                  ptr = handle.$$.smartPtr;
                } else {
                  var clonedHandle = handle["clone"]();
                  ptr = this.rawShare(ptr, __emval_register(function() {
                    clonedHandle["delete"]();
                  }));
                  if (destructors !== null) {
                    destructors.push(this.rawDestructor, ptr);
                  }
                }
                break;
              default:
                throwBindingError("Unsupporting sharing policy");
            }
          }
          return ptr;
        }
        function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
          if (handle === null) {
            if (this.isReference) {
              throwBindingError("null is not a valid " + this.name);
            }
            return 0;
          }
          if (!handle.$$) {
            throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
          }
          if (!handle.$$.ptr) {
            throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
          }
          if (handle.$$.ptrType.isConst) {
            throwBindingError("Cannot convert argument of type " + handle.$$.ptrType.name + " to parameter type " + this.name);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          return ptr;
        }
        function RegisteredPointer_getPointee(ptr) {
          if (this.rawGetPointee) {
            ptr = this.rawGetPointee(ptr);
          }
          return ptr;
        }
        function RegisteredPointer_destructor(ptr) {
          if (this.rawDestructor) {
            this.rawDestructor(ptr);
          }
        }
        function RegisteredPointer_deleteObject(handle) {
          if (handle !== null) {
            handle["delete"]();
          }
        }
        function downcastPointer(ptr, ptrClass, desiredClass) {
          if (ptrClass === desiredClass) {
            return ptr;
          }
          if (desiredClass.baseClass === void 0) {
            return null;
          }
          var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
          if (rv === null) {
            return null;
          }
          return desiredClass.downcast(rv);
        }
        function getInheritedInstanceCount() {
          return Object.keys(registeredInstances).length;
        }
        function getLiveInheritedInstances() {
          var rv = [];
          for (var k in registeredInstances) {
            if (registeredInstances.hasOwnProperty(k)) {
              rv.push(registeredInstances[k]);
            }
          }
          return rv;
        }
        function setDelayFunction(fn) {
          delayFunction = fn;
          if (deletionQueue.length && delayFunction) {
            delayFunction(flushPendingDeletes);
          }
        }
        function init_embind() {
          Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
          Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
          Module["flushPendingDeletes"] = flushPendingDeletes;
          Module["setDelayFunction"] = setDelayFunction;
        }
        var registeredInstances = {};
        function getBasestPointer(class_, ptr) {
          if (ptr === void 0) {
            throwBindingError("ptr should not be undefined");
          }
          while (class_.baseClass) {
            ptr = class_.upcast(ptr);
            class_ = class_.baseClass;
          }
          return ptr;
        }
        function getInheritedInstance(class_, ptr) {
          ptr = getBasestPointer(class_, ptr);
          return registeredInstances[ptr];
        }
        function makeClassHandle(prototype, record) {
          if (!record.ptrType || !record.ptr) {
            throwInternalError("makeClassHandle requires ptr and ptrType");
          }
          var hasSmartPtrType = !!record.smartPtrType;
          var hasSmartPtr = !!record.smartPtr;
          if (hasSmartPtrType !== hasSmartPtr) {
            throwInternalError("Both smartPtrType and smartPtr must be specified");
          }
          record.count = { value: 1 };
          return attachFinalizer(Object.create(prototype, { $$: { value: record } }));
        }
        function RegisteredPointer_fromWireType(ptr) {
          var rawPointer = this.getPointee(ptr);
          if (!rawPointer) {
            this.destructor(ptr);
            return null;
          }
          var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
          if (registeredInstance !== void 0) {
            if (registeredInstance.$$.count.value === 0) {
              registeredInstance.$$.ptr = rawPointer;
              registeredInstance.$$.smartPtr = ptr;
              return registeredInstance["clone"]();
            } else {
              var rv = registeredInstance["clone"]();
              this.destructor(ptr);
              return rv;
            }
          }
          function makeDefaultHandle() {
            if (this.isSmartPointer) {
              return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: rawPointer, smartPtrType: this, smartPtr: ptr });
            } else {
              return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this, ptr });
            }
          }
          var actualType = this.registeredClass.getActualType(rawPointer);
          var registeredPointerRecord = registeredPointers[actualType];
          if (!registeredPointerRecord) {
            return makeDefaultHandle.call(this);
          }
          var toType;
          if (this.isConst) {
            toType = registeredPointerRecord.constPointerType;
          } else {
            toType = registeredPointerRecord.pointerType;
          }
          var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
          if (dp === null) {
            return makeDefaultHandle.call(this);
          }
          if (this.isSmartPointer) {
            return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp, smartPtrType: this, smartPtr: ptr });
          } else {
            return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp });
          }
        }
        function init_RegisteredPointer() {
          RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
          RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
          RegisteredPointer.prototype["argPackAdvance"] = 8;
          RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;
          RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;
          RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
        }
        function RegisteredPointer(name2, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
          this.name = name2;
          this.registeredClass = registeredClass;
          this.isReference = isReference;
          this.isConst = isConst;
          this.isSmartPointer = isSmartPointer;
          this.pointeeType = pointeeType;
          this.sharingPolicy = sharingPolicy;
          this.rawGetPointee = rawGetPointee;
          this.rawConstructor = rawConstructor;
          this.rawShare = rawShare;
          this.rawDestructor = rawDestructor;
          if (!isSmartPointer && registeredClass.baseClass === void 0) {
            if (isConst) {
              this["toWireType"] = constNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            } else {
              this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            }
          } else {
            this["toWireType"] = genericPointerToWireType;
          }
        }
        function replacePublicSymbol(name2, value, numArguments) {
          if (!Module.hasOwnProperty(name2)) {
            throwInternalError("Replacing nonexistant public symbol");
          }
          if (Module[name2].overloadTable !== void 0 && numArguments !== void 0) {
            Module[name2].overloadTable[numArguments] = value;
          } else {
            Module[name2] = value;
            Module[name2].argCount = numArguments;
          }
        }
        function dynCallLegacy(sig, ptr, args) {
          var f = Module["dynCall_" + sig];
          return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);
        }
        function dynCall(sig, ptr, args) {
          if (sig.includes("j")) {
            return dynCallLegacy(sig, ptr, args);
          }
          return wasmTable.get(ptr).apply(null, args);
        }
        function getDynCaller(sig, ptr) {
          var argCache = [];
          return function() {
            argCache.length = arguments.length;
            for (var i = 0; i < arguments.length; i++) {
              argCache[i] = arguments[i];
            }
            return dynCall(sig, ptr, argCache);
          };
        }
        function embind__requireFunction(signature, rawFunction) {
          signature = readLatin1String(signature);
          function makeDynCaller() {
            if (signature.includes("j")) {
              return getDynCaller(signature, rawFunction);
            }
            return wasmTable.get(rawFunction);
          }
          var fp = makeDynCaller();
          if (typeof fp !== "function") {
            throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
          }
          return fp;
        }
        var UnboundTypeError = void 0;
        function getTypeName(type) {
          var ptr = ___getTypeName(type);
          var rv = readLatin1String(ptr);
          _free(ptr);
          return rv;
        }
        function throwUnboundTypeError(message, types) {
          var unboundTypes = [];
          var seen = {};
          function visit(type) {
            if (seen[type]) {
              return;
            }
            if (registeredTypes[type]) {
              return;
            }
            if (typeDependencies[type]) {
              typeDependencies[type].forEach(visit);
              return;
            }
            unboundTypes.push(type);
            seen[type] = true;
          }
          types.forEach(visit);
          throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([", "]));
        }
        function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name2, destructorSignature, rawDestructor) {
          name2 = readLatin1String(name2);
          getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
          if (upcast) {
            upcast = embind__requireFunction(upcastSignature, upcast);
          }
          if (downcast) {
            downcast = embind__requireFunction(downcastSignature, downcast);
          }
          rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
          var legalFunctionName = makeLegalFunctionName(name2);
          exposePublicSymbol(legalFunctionName, function() {
            throwUnboundTypeError("Cannot construct " + name2 + " due to unbound types", [baseClassRawType]);
          });
          whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function(base) {
            base = base[0];
            var baseClass;
            var basePrototype;
            if (baseClassRawType) {
              baseClass = base.registeredClass;
              basePrototype = baseClass.instancePrototype;
            } else {
              basePrototype = ClassHandle.prototype;
            }
            var constructor = createNamedFunction(legalFunctionName, function() {
              if (Object.getPrototypeOf(this) !== instancePrototype) {
                throw new BindingError("Use 'new' to construct " + name2);
              }
              if (registeredClass.constructor_body === void 0) {
                throw new BindingError(name2 + " has no accessible constructor");
              }
              var body = registeredClass.constructor_body[arguments.length];
              if (body === void 0) {
                throw new BindingError("Tried to invoke ctor of " + name2 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
              }
              return body.apply(this, arguments);
            });
            var instancePrototype = Object.create(basePrototype, { constructor: { value: constructor } });
            constructor.prototype = instancePrototype;
            var registeredClass = new RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
            var referenceConverter = new RegisteredPointer(name2, registeredClass, true, false, false);
            var pointerConverter = new RegisteredPointer(name2 + "*", registeredClass, false, false, false);
            var constPointerConverter = new RegisteredPointer(name2 + " const*", registeredClass, false, true, false);
            registeredPointers[rawType] = { pointerType: pointerConverter, constPointerType: constPointerConverter };
            replacePublicSymbol(legalFunctionName, constructor);
            return [referenceConverter, pointerConverter, constPointerConverter];
          });
        }
        function heap32VectorToArray(count, firstElement) {
          var array = [];
          for (var i = 0; i < count; i++) {
            array.push(HEAP32[(firstElement >> 2) + i >>> 0]);
          }
          return array;
        }
        function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
          assert(argCount > 0);
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          invoker = embind__requireFunction(invokerSignature, invoker);
          var args = [rawConstructor];
          var destructors = [];
          whenDependentTypesAreResolved([], [rawClassType], function(classType) {
            classType = classType[0];
            var humanName = "constructor " + classType.name;
            if (classType.registeredClass.constructor_body === void 0) {
              classType.registeredClass.constructor_body = [];
            }
            if (classType.registeredClass.constructor_body[argCount - 1] !== void 0) {
              throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount - 1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
            }
            classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {
              throwUnboundTypeError("Cannot construct " + classType.name + " due to unbound types", rawArgTypes);
            };
            whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
              classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {
                if (arguments.length !== argCount - 1) {
                  throwBindingError(humanName + " called with " + arguments.length + " arguments, expected " + (argCount - 1));
                }
                destructors.length = 0;
                args.length = argCount;
                for (var i = 1; i < argCount; ++i) {
                  args[i] = argTypes[i]["toWireType"](destructors, arguments[i - 1]);
                }
                var ptr = invoker.apply(null, args);
                runDestructors(destructors);
                return argTypes[0]["fromWireType"](ptr);
              };
              return [];
            });
            return [];
          });
        }
        function new_(constructor, argumentList) {
          if (!(constructor instanceof Function)) {
            throw new TypeError("new_ called with constructor type " + typeof constructor + " which is not a function");
          }
          var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {
          });
          dummy.prototype = constructor.prototype;
          var obj = new dummy();
          var r = constructor.apply(obj, argumentList);
          return r instanceof Object ? r : obj;
        }
        function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
          var argCount = argTypes.length;
          if (argCount < 2) {
            throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
          }
          var isClassMethodFunc = argTypes[1] !== null && classType !== null;
          var needsDestructorStack = false;
          for (var i = 1; i < argTypes.length; ++i) {
            if (argTypes[i] !== null && argTypes[i].destructorFunction === void 0) {
              needsDestructorStack = true;
              break;
            }
          }
          var returns = argTypes[0].name !== "void";
          var argsList = "";
          var argsListWired = "";
          for (var i = 0; i < argCount - 2; ++i) {
            argsList += (i !== 0 ? ", " : "") + "arg" + i;
            argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
          }
          var invokerFnBody = "return function " + makeLegalFunctionName(humanName) + "(" + argsList + ") {\nif (arguments.length !== " + (argCount - 2) + ") {\nthrowBindingError('function " + humanName + " called with ' + arguments.length + ' arguments, expected " + (argCount - 2) + " args!');\n}\n";
          if (needsDestructorStack) {
            invokerFnBody += "var destructors = [];\n";
          }
          var dtorStack = needsDestructorStack ? "destructors" : "null";
          var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
          var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
          if (isClassMethodFunc) {
            invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
          }
          for (var i = 0; i < argCount - 2; ++i) {
            invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
            args1.push("argType" + i);
            args2.push(argTypes[i + 2]);
          }
          if (isClassMethodFunc) {
            argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
          }
          invokerFnBody += (returns ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
          if (needsDestructorStack) {
            invokerFnBody += "runDestructors(destructors);\n";
          } else {
            for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
              var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
              if (argTypes[i].destructorFunction !== null) {
                invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
                args1.push(paramName + "_dtor");
                args2.push(argTypes[i].destructorFunction);
              }
            }
          }
          if (returns) {
            invokerFnBody += "var ret = retType.fromWireType(rv);\nreturn ret;\n";
          }
          invokerFnBody += "}\n";
          args1.push(invokerFnBody);
          var invokerFunction = new_(Function, args1).apply(null, args2);
          return invokerFunction;
        }
        function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          methodName = readLatin1String(methodName);
          rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
          whenDependentTypesAreResolved([], [rawClassType], function(classType) {
            classType = classType[0];
            var humanName = classType.name + "." + methodName;
            if (methodName.startsWith("@@")) {
              methodName = Symbol[methodName.substring(2)];
            }
            if (isPureVirtual) {
              classType.registeredClass.pureVirtualFunctions.push(methodName);
            }
            function unboundTypesHandler() {
              throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
            }
            var proto = classType.registeredClass.instancePrototype;
            var method = proto[methodName];
            if (method === void 0 || method.overloadTable === void 0 && method.className !== classType.name && method.argCount === argCount - 2) {
              unboundTypesHandler.argCount = argCount - 2;
              unboundTypesHandler.className = classType.name;
              proto[methodName] = unboundTypesHandler;
            } else {
              ensureOverloadTable(proto, methodName, humanName);
              proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
            }
            whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
              var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
              if (proto[methodName].overloadTable === void 0) {
                memberFunction.argCount = argCount - 2;
                proto[methodName] = memberFunction;
              } else {
                proto[methodName].overloadTable[argCount - 2] = memberFunction;
              }
              return [];
            });
            return [];
          });
        }
        var emval_free_list = [];
        var emval_handle_array = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];
        function __emval_decref(handle) {
          if (handle > 4 && --emval_handle_array[handle].refcount === 0) {
            emval_handle_array[handle] = void 0;
            emval_free_list.push(handle);
          }
        }
        function count_emval_handles() {
          var count = 0;
          for (var i = 5; i < emval_handle_array.length; ++i) {
            if (emval_handle_array[i] !== void 0) {
              ++count;
            }
          }
          return count;
        }
        function get_first_emval() {
          for (var i = 5; i < emval_handle_array.length; ++i) {
            if (emval_handle_array[i] !== void 0) {
              return emval_handle_array[i];
            }
          }
          return null;
        }
        function init_emval() {
          Module["count_emval_handles"] = count_emval_handles;
          Module["get_first_emval"] = get_first_emval;
        }
        function __emval_register(value) {
          switch (value) {
            case void 0: {
              return 1;
            }
            case null: {
              return 2;
            }
            case true: {
              return 3;
            }
            case false: {
              return 4;
            }
            default: {
              var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
              emval_handle_array[handle] = { refcount: 1, value };
              return handle;
            }
          }
        }
        function __embind_register_emval(rawType, name2) {
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": function(handle) {
            var rv = emval_handle_array[handle].value;
            __emval_decref(handle);
            return rv;
          }, "toWireType": function(destructors, value) {
            return __emval_register(value);
          }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: null });
        }
        function enumReadValueFromPointer(name2, shift, signed) {
          switch (shift) {
            case 0:
              return function(pointer) {
                var heap = signed ? HEAP8 : HEAPU8;
                return this["fromWireType"](heap[pointer >>> 0]);
              };
            case 1:
              return function(pointer) {
                var heap = signed ? HEAP16 : HEAPU16;
                return this["fromWireType"](heap[pointer >>> 1]);
              };
            case 2:
              return function(pointer) {
                var heap = signed ? HEAP32 : HEAPU32;
                return this["fromWireType"](heap[pointer >>> 2]);
              };
            default:
              throw new TypeError("Unknown integer type: " + name2);
          }
        }
        function __embind_register_enum(rawType, name2, size, isSigned) {
          var shift = getShiftFromSize(size);
          name2 = readLatin1String(name2);
          function ctor() {
          }
          ctor.values = {};
          registerType(rawType, { name: name2, constructor: ctor, "fromWireType": function(c) {
            return this.constructor.values[c];
          }, "toWireType": function(destructors, c) {
            return c.value;
          }, "argPackAdvance": 8, "readValueFromPointer": enumReadValueFromPointer(name2, shift, isSigned), destructorFunction: null });
          exposePublicSymbol(name2, ctor);
        }
        function requireRegisteredType(rawType, humanName) {
          var impl = registeredTypes[rawType];
          if (impl === void 0) {
            throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
          }
          return impl;
        }
        function __embind_register_enum_value(rawEnumType, name2, enumValue) {
          var enumType = requireRegisteredType(rawEnumType, "enum");
          name2 = readLatin1String(name2);
          var Enum = enumType.constructor;
          var Value2 = Object.create(enumType.constructor.prototype, { value: { value: enumValue }, constructor: { value: createNamedFunction(enumType.name + "_" + name2, function() {
          }) } });
          Enum.values[enumValue] = Value2;
          Enum[name2] = Value2;
        }
        function _embind_repr(v) {
          if (v === null) {
            return "null";
          }
          var t = typeof v;
          if (t === "object" || t === "array" || t === "function") {
            return v.toString();
          } else {
            return "" + v;
          }
        }
        function floatReadValueFromPointer(name2, shift) {
          switch (shift) {
            case 2:
              return function(pointer) {
                return this["fromWireType"](HEAPF32[pointer >>> 2]);
              };
            case 3:
              return function(pointer) {
                return this["fromWireType"](HEAPF64[pointer >>> 3]);
              };
            default:
              throw new TypeError("Unknown float type: " + name2);
          }
        }
        function __embind_register_float(rawType, name2, size) {
          var shift = getShiftFromSize(size);
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": function(value) {
            return value;
          }, "toWireType": function(destructors, value) {
            if (typeof value !== "number" && typeof value !== "boolean") {
              throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
            }
            return value;
          }, "argPackAdvance": 8, "readValueFromPointer": floatReadValueFromPointer(name2, shift), destructorFunction: null });
        }
        function __embind_register_function(name2, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {
          var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          name2 = readLatin1String(name2);
          rawInvoker = embind__requireFunction(signature, rawInvoker);
          exposePublicSymbol(name2, function() {
            throwUnboundTypeError("Cannot call " + name2 + " due to unbound types", argTypes);
          }, argCount - 1);
          whenDependentTypesAreResolved([], argTypes, function(argTypes2) {
            var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));
            replacePublicSymbol(name2, craftInvokerFunction(name2, invokerArgsArray, null, rawInvoker, fn), argCount - 1);
            return [];
          });
        }
        function integerReadValueFromPointer(name2, shift, signed) {
          switch (shift) {
            case 0:
              return signed ? function readS8FromPointer(pointer) {
                return HEAP8[pointer >>> 0];
              } : function readU8FromPointer(pointer) {
                return HEAPU8[pointer >>> 0];
              };
            case 1:
              return signed ? function readS16FromPointer(pointer) {
                return HEAP16[pointer >>> 1];
              } : function readU16FromPointer(pointer) {
                return HEAPU16[pointer >>> 1];
              };
            case 2:
              return signed ? function readS32FromPointer(pointer) {
                return HEAP32[pointer >>> 2];
              } : function readU32FromPointer(pointer) {
                return HEAPU32[pointer >>> 2];
              };
            default:
              throw new TypeError("Unknown integer type: " + name2);
          }
        }
        function __embind_register_integer(primitiveType, name2, size, minRange, maxRange) {
          name2 = readLatin1String(name2);
          if (maxRange === -1) {
            maxRange = 4294967295;
          }
          var shift = getShiftFromSize(size);
          var fromWireType = function(value) {
            return value;
          };
          if (minRange === 0) {
            var bitshift = 32 - 8 * size;
            fromWireType = function(value) {
              return value << bitshift >>> bitshift;
            };
          }
          var isUnsignedType = name2.includes("unsigned");
          registerType(primitiveType, { name: name2, "fromWireType": fromWireType, "toWireType": function(destructors, value) {
            if (typeof value !== "number" && typeof value !== "boolean") {
              throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
            }
            if (value < minRange || value > maxRange) {
              throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name2 + '", which is outside the valid range [' + minRange + ", " + maxRange + "]!");
            }
            return isUnsignedType ? value >>> 0 : value | 0;
          }, "argPackAdvance": 8, "readValueFromPointer": integerReadValueFromPointer(name2, shift, minRange !== 0), destructorFunction: null });
        }
        function __embind_register_memory_view(rawType, dataTypeIndex, name2) {
          var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
          var TA = typeMapping[dataTypeIndex];
          function decodeMemoryView(handle) {
            handle = handle >> 2;
            var heap = HEAPU32;
            var size = heap[handle >>> 0];
            var data = heap[handle + 1 >>> 0];
            return new TA(buffer, data, size);
          }
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": decodeMemoryView, "argPackAdvance": 8, "readValueFromPointer": decodeMemoryView }, { ignoreDuplicateRegistrations: true });
        }
        function __embind_register_std_string(rawType, name2) {
          name2 = readLatin1String(name2);
          var stdStringIsUTF8 = name2 === "std::string";
          registerType(rawType, { name: name2, "fromWireType": function(value) {
            var length = HEAPU32[value >>> 2];
            var str;
            if (stdStringIsUTF8) {
              var decodeStartPtr = value + 4;
              for (var i = 0; i <= length; ++i) {
                var currentBytePtr = value + 4 + i;
                if (i == length || HEAPU8[currentBytePtr >>> 0] == 0) {
                  var maxRead = currentBytePtr - decodeStartPtr;
                  var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                  if (str === void 0) {
                    str = stringSegment;
                  } else {
                    str += String.fromCharCode(0);
                    str += stringSegment;
                  }
                  decodeStartPtr = currentBytePtr + 1;
                }
              }
            } else {
              var a = new Array(length);
              for (var i = 0; i < length; ++i) {
                a[i] = String.fromCharCode(HEAPU8[value + 4 + i >>> 0]);
              }
              str = a.join("");
            }
            _free(value);
            return str;
          }, "toWireType": function(destructors, value) {
            if (value instanceof ArrayBuffer) {
              value = new Uint8Array(value);
            }
            var getLength;
            var valueIsOfTypeString = typeof value === "string";
            if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
              throwBindingError("Cannot pass non-string to std::string");
            }
            if (stdStringIsUTF8 && valueIsOfTypeString) {
              getLength = function() {
                return lengthBytesUTF8(value);
              };
            } else {
              getLength = function() {
                return value.length;
              };
            }
            var length = getLength();
            var ptr = _malloc(4 + length + 1);
            ptr >>>= 0;
            HEAPU32[ptr >>> 2] = length;
            if (stdStringIsUTF8 && valueIsOfTypeString) {
              stringToUTF8(value, ptr + 4, length + 1);
            } else {
              if (valueIsOfTypeString) {
                for (var i = 0; i < length; ++i) {
                  var charCode = value.charCodeAt(i);
                  if (charCode > 255) {
                    _free(ptr);
                    throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
                  }
                  HEAPU8[ptr + 4 + i >>> 0] = charCode;
                }
              } else {
                for (var i = 0; i < length; ++i) {
                  HEAPU8[ptr + 4 + i >>> 0] = value[i];
                }
              }
            }
            if (destructors !== null) {
              destructors.push(_free, ptr);
            }
            return ptr;
          }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
            _free(ptr);
          } });
        }
        function __embind_register_std_wstring(rawType, charSize, name2) {
          name2 = readLatin1String(name2);
          var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
          if (charSize === 2) {
            decodeString = UTF16ToString;
            encodeString = stringToUTF16;
            lengthBytesUTF = lengthBytesUTF16;
            getHeap = function() {
              return HEAPU16;
            };
            shift = 1;
          } else if (charSize === 4) {
            decodeString = UTF32ToString;
            encodeString = stringToUTF32;
            lengthBytesUTF = lengthBytesUTF32;
            getHeap = function() {
              return HEAPU32;
            };
            shift = 2;
          }
          registerType(rawType, { name: name2, "fromWireType": function(value) {
            var length = HEAPU32[value >>> 2];
            var HEAP = getHeap();
            var str;
            var decodeStartPtr = value + 4;
            for (var i = 0; i <= length; ++i) {
              var currentBytePtr = value + 4 + i * charSize;
              if (i == length || HEAP[currentBytePtr >>> shift] == 0) {
                var maxReadBytes = currentBytePtr - decodeStartPtr;
                var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
                if (str === void 0) {
                  str = stringSegment;
                } else {
                  str += String.fromCharCode(0);
                  str += stringSegment;
                }
                decodeStartPtr = currentBytePtr + charSize;
              }
            }
            _free(value);
            return str;
          }, "toWireType": function(destructors, value) {
            if (!(typeof value === "string")) {
              throwBindingError("Cannot pass non-string to C++ string type " + name2);
            }
            var length = lengthBytesUTF(value);
            var ptr = _malloc(4 + length + charSize);
            ptr >>>= 0;
            HEAPU32[ptr >>> 2] = length >> shift;
            encodeString(value, ptr + 4, length + charSize);
            if (destructors !== null) {
              destructors.push(_free, ptr);
            }
            return ptr;
          }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
            _free(ptr);
          } });
        }
        function __embind_register_value_array(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
          tupleRegistrations[rawType] = { name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), elements: [] };
        }
        function __embind_register_value_array_element(rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
          tupleRegistrations[rawTupleType].elements.push({ getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
        }
        function __embind_register_value_object(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
          structRegistrations[rawType] = { name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), fields: [] };
        }
        function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
          structRegistrations[structType].fields.push({ fieldName: readLatin1String(fieldName), getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
        }
        function __embind_register_void(rawType, name2) {
          name2 = readLatin1String(name2);
          registerType(rawType, { isVoid: true, name: name2, "argPackAdvance": 0, "fromWireType": function() {
            return void 0;
          }, "toWireType": function(destructors, o) {
            return void 0;
          } });
        }
        function requireHandle(handle) {
          if (!handle) {
            throwBindingError("Cannot use deleted val. handle = " + handle);
          }
          return emval_handle_array[handle].value;
        }
        function __emval_as(handle, returnType, destructorsRef) {
          handle = requireHandle(handle);
          returnType = requireRegisteredType(returnType, "emval::as");
          var destructors = [];
          var rd = __emval_register(destructors);
          HEAP32[destructorsRef >>> 2] = rd;
          return returnType["toWireType"](destructors, handle);
        }
        function __emval_lookupTypes(argCount, argTypes) {
          var a = new Array(argCount);
          for (var i = 0; i < argCount; ++i) {
            a[i] = requireRegisteredType(HEAP32[(argTypes >> 2) + i >>> 0], "parameter " + i);
          }
          return a;
        }
        function __emval_call(handle, argCount, argTypes, argv) {
          handle = requireHandle(handle);
          var types = __emval_lookupTypes(argCount, argTypes);
          var args = new Array(argCount);
          for (var i = 0; i < argCount; ++i) {
            var type = types[i];
            args[i] = type["readValueFromPointer"](argv);
            argv += type["argPackAdvance"];
          }
          var rv = handle.apply(void 0, args);
          return __emval_register(rv);
        }
        var emval_symbols = {};
        function getStringOrSymbol(address) {
          var symbol = emval_symbols[address];
          if (symbol === void 0) {
            return readLatin1String(address);
          } else {
            return symbol;
          }
        }
        function emval_get_global() {
          if (typeof globalThis === "object") {
            return globalThis;
          }
          return function() {
            return Function;
          }()("return this")();
        }
        function __emval_get_global(name2) {
          if (name2 === 0) {
            return __emval_register(emval_get_global());
          } else {
            name2 = getStringOrSymbol(name2);
            return __emval_register(emval_get_global()[name2]);
          }
        }
        function __emval_get_property(handle, key2) {
          handle = requireHandle(handle);
          key2 = requireHandle(key2);
          return __emval_register(handle[key2]);
        }
        function __emval_incref(handle) {
          if (handle > 4) {
            emval_handle_array[handle].refcount += 1;
          }
        }
        function __emval_instanceof(object, constructor) {
          object = requireHandle(object);
          constructor = requireHandle(constructor);
          return object instanceof constructor;
        }
        function __emval_is_number(handle) {
          handle = requireHandle(handle);
          return typeof handle === "number";
        }
        function __emval_new_array() {
          return __emval_register([]);
        }
        function __emval_new_cstring(v) {
          return __emval_register(getStringOrSymbol(v));
        }
        function __emval_new_object() {
          return __emval_register({});
        }
        function __emval_run_destructors(handle) {
          var destructors = emval_handle_array[handle].value;
          runDestructors(destructors);
          __emval_decref(handle);
        }
        function __emval_set_property(handle, key2, value) {
          handle = requireHandle(handle);
          key2 = requireHandle(key2);
          value = requireHandle(value);
          handle[key2] = value;
        }
        function __emval_take_value(type, argv) {
          type = requireRegisteredType(type, "_emval_take_value");
          var v = type["readValueFromPointer"](argv);
          return __emval_register(v);
        }
        function _abort() {
          abort();
        }
        var _emscripten_get_now;
        if (ENVIRONMENT_IS_NODE) {
          _emscripten_get_now = function() {
            var t = process["hrtime"]();
            return t[0] * 1e3 + t[1] / 1e6;
          };
        } else
          _emscripten_get_now = function() {
            return performance.now();
          };
        var _emscripten_get_now_is_monotonic = true;
        function _clock_gettime(clk_id, tp) {
          var now;
          if (clk_id === 0) {
            now = Date.now();
          } else if ((clk_id === 1 || clk_id === 4) && _emscripten_get_now_is_monotonic) {
            now = _emscripten_get_now();
          } else {
            setErrNo(28);
            return -1;
          }
          HEAP32[tp >>> 2] = now / 1e3 | 0;
          HEAP32[tp + 4 >>> 2] = now % 1e3 * 1e3 * 1e3 | 0;
          return 0;
        }
        function _emscripten_memcpy_big(dest, src, num) {
          HEAPU8.copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);
        }
        function emscripten_realloc_buffer(size) {
          try {
            wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
            updateGlobalBufferAndViews(wasmMemory.buffer);
            return 1;
          } catch (e) {
          }
        }
        function _emscripten_resize_heap(requestedSize) {
          var oldSize = HEAPU8.length;
          requestedSize = requestedSize >>> 0;
          var maxHeapSize = 4294901760;
          if (requestedSize > maxHeapSize) {
            return false;
          }
          for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
            var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
            overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
            var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
            var replacement = emscripten_realloc_buffer(newSize);
            if (replacement) {
              return true;
            }
          }
          return false;
        }
        var ENV = {};
        function getExecutableName() {
          return thisProgram || "./this.program";
        }
        function getEnvStrings() {
          if (!getEnvStrings.strings) {
            var lang = (typeof navigator === "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
            var env = { "USER": "web_user", "LOGNAME": "web_user", "PATH": "/", "PWD": "/", "HOME": "/home/web_user", "LANG": lang, "_": getExecutableName() };
            for (var x in ENV) {
              if (ENV[x] === void 0)
                delete env[x];
              else
                env[x] = ENV[x];
            }
            var strings = [];
            for (var x in env) {
              strings.push(x + "=" + env[x]);
            }
            getEnvStrings.strings = strings;
          }
          return getEnvStrings.strings;
        }
        function _environ_get(__environ, environ_buf) {
          try {
            var bufSize = 0;
            getEnvStrings().forEach(function(string, i) {
              var ptr = environ_buf + bufSize;
              HEAP32[__environ + i * 4 >>> 2] = ptr;
              writeAsciiToMemory(string, ptr);
              bufSize += string.length + 1;
            });
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _environ_sizes_get(penviron_count, penviron_buf_size) {
          try {
            var strings = getEnvStrings();
            HEAP32[penviron_count >>> 2] = strings.length;
            var bufSize = 0;
            strings.forEach(function(string) {
              bufSize += string.length + 1;
            });
            HEAP32[penviron_buf_size >>> 2] = bufSize;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _fd_close(fd) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.close(stream);
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _fd_read(fd, iov, iovcnt, pnum) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = SYSCALLS.doReadv(stream, iov, iovcnt);
            HEAP32[pnum >>> 2] = num;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var HIGH_OFFSET = 4294967296;
            var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
            var DOUBLE_LIMIT = 9007199254740992;
            if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
              return -61;
            }
            FS.llseek(stream, offset, whence);
            tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >>> 2] = tempI64[0], HEAP32[newOffset + 4 >>> 2] = tempI64[1];
            if (stream.getdents && offset === 0 && whence === 0)
              stream.getdents = null;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _fd_write(fd, iov, iovcnt, pnum) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = SYSCALLS.doWritev(stream, iov, iovcnt);
            HEAP32[pnum >>> 2] = num;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _getTempRet0() {
          return getTempRet0();
        }
        function _llvm_eh_typeid_for(type) {
          return type;
        }
        function _setTempRet0(val) {
          setTempRet0(val);
        }
        function __isLeapYear(year) {
          return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
        }
        function __arraySum(array, index) {
          var sum = 0;
          for (var i = 0; i <= index; sum += array[i++]) {
          }
          return sum;
        }
        var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        function __addDays(date, days) {
          var newDate = new Date(date.getTime());
          while (days > 0) {
            var leap = __isLeapYear(newDate.getFullYear());
            var currentMonth = newDate.getMonth();
            var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];
            if (days > daysInCurrentMonth - newDate.getDate()) {
              days -= daysInCurrentMonth - newDate.getDate() + 1;
              newDate.setDate(1);
              if (currentMonth < 11) {
                newDate.setMonth(currentMonth + 1);
              } else {
                newDate.setMonth(0);
                newDate.setFullYear(newDate.getFullYear() + 1);
              }
            } else {
              newDate.setDate(newDate.getDate() + days);
              return newDate;
            }
          }
          return newDate;
        }
        function _strftime(s, maxsize, format, tm) {
          var tm_zone = HEAP32[tm + 40 >>> 2];
          var date = { tm_sec: HEAP32[tm >>> 2], tm_min: HEAP32[tm + 4 >>> 2], tm_hour: HEAP32[tm + 8 >>> 2], tm_mday: HEAP32[tm + 12 >>> 2], tm_mon: HEAP32[tm + 16 >>> 2], tm_year: HEAP32[tm + 20 >>> 2], tm_wday: HEAP32[tm + 24 >>> 2], tm_yday: HEAP32[tm + 28 >>> 2], tm_isdst: HEAP32[tm + 32 >>> 2], tm_gmtoff: HEAP32[tm + 36 >>> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : "" };
          var pattern = UTF8ToString(format);
          var EXPANSION_RULES_1 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
          for (var rule in EXPANSION_RULES_1) {
            pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
          }
          var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
          var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
          function leadingSomething(value, digits, character) {
            var str = typeof value === "number" ? value.toString() : value || "";
            while (str.length < digits) {
              str = character[0] + str;
            }
            return str;
          }
          function leadingNulls(value, digits) {
            return leadingSomething(value, digits, "0");
          }
          function compareByDay(date1, date2) {
            function sgn(value) {
              return value < 0 ? -1 : value > 0 ? 1 : 0;
            }
            var compare;
            if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
              if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
                compare = sgn(date1.getDate() - date2.getDate());
              }
            }
            return compare;
          }
          function getFirstWeekStartDate(janFourth) {
            switch (janFourth.getDay()) {
              case 0:
                return new Date(janFourth.getFullYear() - 1, 11, 29);
              case 1:
                return janFourth;
              case 2:
                return new Date(janFourth.getFullYear(), 0, 3);
              case 3:
                return new Date(janFourth.getFullYear(), 0, 2);
              case 4:
                return new Date(janFourth.getFullYear(), 0, 1);
              case 5:
                return new Date(janFourth.getFullYear() - 1, 11, 31);
              case 6:
                return new Date(janFourth.getFullYear() - 1, 11, 30);
            }
          }
          function getWeekBasedYear(date2) {
            var thisDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
            var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
            var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
            var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
            var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
            if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
              if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
                return thisDate.getFullYear() + 1;
              } else {
                return thisDate.getFullYear();
              }
            } else {
              return thisDate.getFullYear() - 1;
            }
          }
          var EXPANSION_RULES_2 = { "%a": function(date2) {
            return WEEKDAYS[date2.tm_wday].substring(0, 3);
          }, "%A": function(date2) {
            return WEEKDAYS[date2.tm_wday];
          }, "%b": function(date2) {
            return MONTHS[date2.tm_mon].substring(0, 3);
          }, "%B": function(date2) {
            return MONTHS[date2.tm_mon];
          }, "%C": function(date2) {
            var year = date2.tm_year + 1900;
            return leadingNulls(year / 100 | 0, 2);
          }, "%d": function(date2) {
            return leadingNulls(date2.tm_mday, 2);
          }, "%e": function(date2) {
            return leadingSomething(date2.tm_mday, 2, " ");
          }, "%g": function(date2) {
            return getWeekBasedYear(date2).toString().substring(2);
          }, "%G": function(date2) {
            return getWeekBasedYear(date2);
          }, "%H": function(date2) {
            return leadingNulls(date2.tm_hour, 2);
          }, "%I": function(date2) {
            var twelveHour = date2.tm_hour;
            if (twelveHour == 0)
              twelveHour = 12;
            else if (twelveHour > 12)
              twelveHour -= 12;
            return leadingNulls(twelveHour, 2);
          }, "%j": function(date2) {
            return leadingNulls(date2.tm_mday + __arraySum(__isLeapYear(date2.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3);
          }, "%m": function(date2) {
            return leadingNulls(date2.tm_mon + 1, 2);
          }, "%M": function(date2) {
            return leadingNulls(date2.tm_min, 2);
          }, "%n": function() {
            return "\n";
          }, "%p": function(date2) {
            if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
              return "AM";
            } else {
              return "PM";
            }
          }, "%S": function(date2) {
            return leadingNulls(date2.tm_sec, 2);
          }, "%t": function() {
            return "	";
          }, "%u": function(date2) {
            return date2.tm_wday || 7;
          }, "%U": function(date2) {
            var janFirst = new Date(date2.tm_year + 1900, 0, 1);
            var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());
            var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
            if (compareByDay(firstSunday, endDate) < 0) {
              var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
              var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();
              var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
              return leadingNulls(Math.ceil(days / 7), 2);
            }
            return compareByDay(firstSunday, janFirst) === 0 ? "01" : "00";
          }, "%V": function(date2) {
            var janFourthThisYear = new Date(date2.tm_year + 1900, 0, 4);
            var janFourthNextYear = new Date(date2.tm_year + 1901, 0, 4);
            var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
            var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
            var endDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
            if (compareByDay(endDate, firstWeekStartThisYear) < 0) {
              return "53";
            }
            if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {
              return "01";
            }
            var daysDifference;
            if (firstWeekStartThisYear.getFullYear() < date2.tm_year + 1900) {
              daysDifference = date2.tm_yday + 32 - firstWeekStartThisYear.getDate();
            } else {
              daysDifference = date2.tm_yday + 1 - firstWeekStartThisYear.getDate();
            }
            return leadingNulls(Math.ceil(daysDifference / 7), 2);
          }, "%w": function(date2) {
            return date2.tm_wday;
          }, "%W": function(date2) {
            var janFirst = new Date(date2.tm_year, 0, 1);
            var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);
            var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
            if (compareByDay(firstMonday, endDate) < 0) {
              var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
              var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();
              var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
              return leadingNulls(Math.ceil(days / 7), 2);
            }
            return compareByDay(firstMonday, janFirst) === 0 ? "01" : "00";
          }, "%y": function(date2) {
            return (date2.tm_year + 1900).toString().substring(2);
          }, "%Y": function(date2) {
            return date2.tm_year + 1900;
          }, "%z": function(date2) {
            var off = date2.tm_gmtoff;
            var ahead = off >= 0;
            off = Math.abs(off) / 60;
            off = off / 60 * 100 + off % 60;
            return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
          }, "%Z": function(date2) {
            return date2.tm_zone;
          }, "%%": function() {
            return "%";
          } };
          for (var rule in EXPANSION_RULES_2) {
            if (pattern.includes(rule)) {
              pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
            }
          }
          var bytes = intArrayFromString(pattern, false);
          if (bytes.length > maxsize) {
            return 0;
          }
          writeArrayToMemory(bytes, s);
          return bytes.length - 1;
        }
        function _strftime_l(s, maxsize, format, tm) {
          return _strftime(s, maxsize, format, tm);
        }
        var FSNode = function(parent, name2, mode, rdev) {
          if (!parent) {
            parent = this;
          }
          this.parent = parent;
          this.mount = parent.mount;
          this.mounted = null;
          this.id = FS.nextInode++;
          this.name = name2;
          this.mode = mode;
          this.node_ops = {};
          this.stream_ops = {};
          this.rdev = rdev;
        };
        var readMode = 292 | 73;
        var writeMode = 146;
        Object.defineProperties(FSNode.prototype, { read: { get: function() {
          return (this.mode & readMode) === readMode;
        }, set: function(val) {
          val ? this.mode |= readMode : this.mode &= ~readMode;
        } }, write: { get: function() {
          return (this.mode & writeMode) === writeMode;
        }, set: function(val) {
          val ? this.mode |= writeMode : this.mode &= ~writeMode;
        } }, isFolder: { get: function() {
          return FS.isDir(this.mode);
        } }, isDevice: { get: function() {
          return FS.isChrdev(this.mode);
        } } });
        FS.FSNode = FSNode;
        FS.staticInit();
        Module["FS_createPath"] = FS.createPath;
        Module["FS_createDataFile"] = FS.createDataFile;
        Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
        Module["FS_createLazyFile"] = FS.createLazyFile;
        Module["FS_createDevice"] = FS.createDevice;
        Module["FS_unlink"] = FS.unlink;
        InternalError = Module["InternalError"] = extendError(Error, "InternalError");
        embind_init_charCodes();
        BindingError = Module["BindingError"] = extendError(Error, "BindingError");
        init_ClassHandle();
        init_RegisteredPointer();
        init_embind();
        UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
        init_emval();
        function intArrayFromString(stringy, dontAddNull, length) {
          var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
          var u8array = new Array(len);
          var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
          if (dontAddNull)
            u8array.length = numBytesWritten;
          return u8array;
        }
        var asmLibraryArg = { "ga": ___assert_fail, "m": ___cxa_allocate_exception, "u": ___cxa_begin_catch, "x": ___cxa_end_catch, "b": ___cxa_find_matching_catch_2, "l": ___cxa_find_matching_catch_3, "A": ___cxa_free_exception, "$": ___cxa_rethrow, "n": ___cxa_throw, "pa": ___cxa_uncaught_exceptions, "h": ___resumeException, "ba": ___sys_fcntl64, "qa": ___sys_ioctl, "ra": ___sys_open, "Ca": __embind_finalize_value_array, "Fa": __embind_finalize_value_object, "ka": __embind_register_bigint, "ya": __embind_register_bool, "K": __embind_register_class, "J": __embind_register_class_constructor, "p": __embind_register_class_function, "xa": __embind_register_emval, "Aa": __embind_register_enum, "Q": __embind_register_enum_value, "ea": __embind_register_float, "s": __embind_register_function, "z": __embind_register_integer, "w": __embind_register_memory_view, "fa": __embind_register_std_string, "U": __embind_register_std_wstring, "Da": __embind_register_value_array, "Ba": __embind_register_value_array_element, "I": __embind_register_value_object, "Ea": __embind_register_value_object_field, "za": __embind_register_void, "R": __emval_as, "ha": __emval_call, "na": __emval_decref, "Ma": __emval_get_global, "Ia": __emval_get_property, "_": __emval_incref, "la": __emval_instanceof, "La": __emval_is_number, "Ka": __emval_new_array, "V": __emval_new_cstring, "Ja": __emval_new_object, "Ha": __emval_run_destructors, "Ga": __emval_set_property, "B": __emval_take_value, "da": _abort, "aa": _clock_gettime, "oa": _emscripten_memcpy_big, "T": _emscripten_resize_heap, "ta": _environ_get, "ua": _environ_sizes_get, "ca": _fd_close, "wa": _fd_read, "ja": _fd_seek, "va": _fd_write, "a": _getTempRet0, "G": invoke_diii, "C": invoke_i, "c": invoke_ii, "O": invoke_iid, "i": invoke_iii, "j": invoke_iiii, "P": invoke_iiiii, "X": invoke_iiiiid, "E": invoke_iiiiii, "y": invoke_iiiiiii, "Y": invoke_iiiiiiii, "N": invoke_iiiiiiiii, "M": invoke_iiiiiiiiiiii, "ia": invoke_j, "f": invoke_v, "e": invoke_vi, "H": invoke_viddi, "F": invoke_viffiid, "g": invoke_vii, "r": invoke_viidd, "d": invoke_viii, "k": invoke_viiii, "Z": invoke_viiiid, "S": invoke_viiiidii, "D": invoke_viiiii, "v": invoke_viiiiii, "q": invoke_viiiiiii, "t": invoke_viiiiiiiii, "o": invoke_viiiiiiiiii, "L": invoke_viiiiiiiiiiiiiii, "ma": _llvm_eh_typeid_for, "W": _setTempRet0, "sa": _strftime_l };
        createWasm();
        Module["___wasm_call_ctors"] = function() {
          return (Module["___wasm_call_ctors"] = Module["asm"]["Oa"]).apply(null, arguments);
        };
        Module["_main"] = function() {
          return (Module["_main"] = Module["asm"]["Pa"]).apply(null, arguments);
        };
        var _malloc = Module["_malloc"] = function() {
          return (_malloc = Module["_malloc"] = Module["asm"]["Qa"]).apply(null, arguments);
        };
        var _free = Module["_free"] = function() {
          return (_free = Module["_free"] = Module["asm"]["Sa"]).apply(null, arguments);
        };
        var ___getTypeName = Module["___getTypeName"] = function() {
          return (___getTypeName = Module["___getTypeName"] = Module["asm"]["Ta"]).apply(null, arguments);
        };
        Module["___embind_register_native_and_builtin_types"] = function() {
          return (Module["___embind_register_native_and_builtin_types"] = Module["asm"]["Ua"]).apply(null, arguments);
        };
        var ___errno_location = Module["___errno_location"] = function() {
          return (___errno_location = Module["___errno_location"] = Module["asm"]["Va"]).apply(null, arguments);
        };
        var stackSave = Module["stackSave"] = function() {
          return (stackSave = Module["stackSave"] = Module["asm"]["Wa"]).apply(null, arguments);
        };
        var stackRestore = Module["stackRestore"] = function() {
          return (stackRestore = Module["stackRestore"] = Module["asm"]["Xa"]).apply(null, arguments);
        };
        var _setThrew = Module["_setThrew"] = function() {
          return (_setThrew = Module["_setThrew"] = Module["asm"]["Ya"]).apply(null, arguments);
        };
        var ___cxa_can_catch = Module["___cxa_can_catch"] = function() {
          return (___cxa_can_catch = Module["___cxa_can_catch"] = Module["asm"]["Za"]).apply(null, arguments);
        };
        var ___cxa_is_pointer_type = Module["___cxa_is_pointer_type"] = function() {
          return (___cxa_is_pointer_type = Module["___cxa_is_pointer_type"] = Module["asm"]["_a"]).apply(null, arguments);
        };
        Module["dynCall_jiji"] = function() {
          return (Module["dynCall_jiji"] = Module["asm"]["$a"]).apply(null, arguments);
        };
        var dynCall_j = Module["dynCall_j"] = function() {
          return (dynCall_j = Module["dynCall_j"] = Module["asm"]["ab"]).apply(null, arguments);
        };
        Module["dynCall_viijii"] = function() {
          return (Module["dynCall_viijii"] = Module["asm"]["bb"]).apply(null, arguments);
        };
        Module["dynCall_iiiiij"] = function() {
          return (Module["dynCall_iiiiij"] = Module["asm"]["cb"]).apply(null, arguments);
        };
        Module["dynCall_iiiiijj"] = function() {
          return (Module["dynCall_iiiiijj"] = Module["asm"]["db"]).apply(null, arguments);
        };
        Module["dynCall_iiiiiijj"] = function() {
          return (Module["dynCall_iiiiiijj"] = Module["asm"]["eb"]).apply(null, arguments);
        };
        function invoke_ii(index, a1) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vi(index, a1) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_v(index) {
          var sp = stackSave();
          try {
            wasmTable.get(index)();
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viii(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiii(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iii(index, a1, a2) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_vii(index, a1, a2) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiii(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_diii(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_i(index) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)();
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiii(index, a1, a2, a3) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iid(index, a1, a2) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiidii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viffiid(index, a1, a2, a3, a4, a5, a6) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viddi(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiii(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viidd(index, a1, a2, a3, a4) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiid(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7, a8);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_viiiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
          var sp = stackSave();
          try {
            wasmTable.get(index)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_iiiiid(index, a1, a2, a3, a4, a5) {
          var sp = stackSave();
          try {
            return wasmTable.get(index)(a1, a2, a3, a4, a5);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        function invoke_j(index) {
          var sp = stackSave();
          try {
            return dynCall_j(index);
          } catch (e) {
            stackRestore(sp);
            if (e !== e + 0 && e !== "longjmp")
              throw e;
            _setThrew(1, 0);
          }
        }
        Module["addRunDependency"] = addRunDependency;
        Module["removeRunDependency"] = removeRunDependency;
        Module["FS_createPath"] = FS.createPath;
        Module["FS_createDataFile"] = FS.createDataFile;
        Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
        Module["FS_createLazyFile"] = FS.createLazyFile;
        Module["FS_createDevice"] = FS.createDevice;
        Module["FS_unlink"] = FS.unlink;
        Module["FS"] = FS;
        var calledRun;
        function ExitStatus(status) {
          this.name = "ExitStatus";
          this.message = "Program terminated with exit(" + status + ")";
          this.status = status;
        }
        dependenciesFulfilled = function runCaller() {
          if (!calledRun)
            run();
          if (!calledRun)
            dependenciesFulfilled = runCaller;
        };
        function callMain(args) {
          var entryFunction = Module["_main"];
          var argc = 0;
          var argv = 0;
          try {
            var ret = entryFunction(argc, argv);
            exit(ret, true);
          } catch (e) {
            if (e instanceof ExitStatus || e == "unwind") {
              return;
            }
            var toLog = e;
            if (e && typeof e === "object" && e.stack) {
              toLog = [e, e.stack];
            }
            err("exception thrown: " + toLog);
            quit_(1, e);
          } finally {
          }
        }
        function run(args) {
          if (runDependencies > 0) {
            return;
          }
          preRun();
          if (runDependencies > 0) {
            return;
          }
          function doRun() {
            if (calledRun)
              return;
            calledRun = true;
            Module["calledRun"] = true;
            if (ABORT)
              return;
            initRuntime();
            preMain();
            readyPromiseResolve(Module);
            if (Module["onRuntimeInitialized"])
              Module["onRuntimeInitialized"]();
            if (shouldRunNow)
              callMain();
            postRun();
          }
          if (Module["setStatus"]) {
            Module["setStatus"]("Running...");
            setTimeout(function() {
              setTimeout(function() {
                Module["setStatus"]("");
              }, 1);
              doRun();
            }, 1);
          } else {
            doRun();
          }
        }
        Module["run"] = run;
        function exit(status, implicit) {
          if (keepRuntimeAlive()) ; else {
            if (Module["onExit"])
              Module["onExit"](status);
            ABORT = true;
          }
          quit_(status, new ExitStatus(status));
        }
        if (Module["preInit"]) {
          if (typeof Module["preInit"] == "function")
            Module["preInit"] = [Module["preInit"]];
          while (Module["preInit"].length > 0) {
            Module["preInit"].pop()();
          }
        }
        var shouldRunNow = true;
        if (Module["noInitialRun"])
          shouldRunNow = false;
        run();
        return WebIFCWasm3.ready;
      };
    }();
    if (typeof exports === "object" && typeof module === "object")
      module.exports = WebIFCWasm2;
    else if (typeof define === "function" && define["amd"])
      define([], function() {
        return WebIFCWasm2;
      });
    else if (typeof exports === "object")
      exports["WebIFCWasm"] = WebIFCWasm2;
  }
});

// dist/ifc2x4.ts
var IFCACTIONREQUEST = 3821786052;
var IFCACTOR = 2296667514;
var IFCACTORROLE = 3630933823;
var IFCACTUATOR = 4288193352;
var IFCACTUATORTYPE = 2874132201;
var IFCADDRESS = 618182010;
var IFCADVANCEDBREP = 1635779807;
var IFCADVANCEDBREPWITHVOIDS = 2603310189;
var IFCADVANCEDFACE = 3406155212;
var IFCAIRTERMINAL = 1634111441;
var IFCAIRTERMINALBOX = 177149247;
var IFCAIRTERMINALBOXTYPE = 1411407467;
var IFCAIRTERMINALTYPE = 3352864051;
var IFCAIRTOAIRHEATRECOVERY = 2056796094;
var IFCAIRTOAIRHEATRECOVERYTYPE = 1871374353;
var IFCALARM = 3087945054;
var IFCALARMTYPE = 3001207471;
var IFCALIGNMENT = 325726236;
var IFCALIGNMENT2DHORIZONTAL = 749761778;
var IFCALIGNMENT2DHORIZONTALSEGMENT = 3199563722;
var IFCALIGNMENT2DSEGMENT = 2483840362;
var IFCALIGNMENT2DVERSEGCIRCULARARC = 3379348081;
var IFCALIGNMENT2DVERSEGLINE = 3239324667;
var IFCALIGNMENT2DVERSEGPARABOLICARC = 4263986512;
var IFCALIGNMENT2DVERTICAL = 53199957;
var IFCALIGNMENT2DVERTICALSEGMENT = 2029264950;
var IFCALIGNMENTCURVE = 3512275521;
var IFCANNOTATION = 1674181508;
var IFCANNOTATIONFILLAREA = 669184980;
var IFCAPPLICATION = 639542469;
var IFCAPPLIEDVALUE = 411424972;
var IFCAPPROVAL = 130549933;
var IFCAPPROVALRELATIONSHIP = 3869604511;
var IFCARBITRARYCLOSEDPROFILEDEF = 3798115385;
var IFCARBITRARYOPENPROFILEDEF = 1310608509;
var IFCARBITRARYPROFILEDEFWITHVOIDS = 2705031697;
var IFCASSET = 3460190687;
var IFCASYMMETRICISHAPEPROFILEDEF = 3207858831;
var IFCAUDIOVISUALAPPLIANCE = 277319702;
var IFCAUDIOVISUALAPPLIANCETYPE = 1532957894;
var IFCAXIS1PLACEMENT = 4261334040;
var IFCAXIS2PLACEMENT2D = 3125803723;
var IFCAXIS2PLACEMENT3D = 2740243338;
var IFCBSPLINECURVE = 1967976161;
var IFCBSPLINECURVEWITHKNOTS = 2461110595;
var IFCBSPLINESURFACE = 2887950389;
var IFCBSPLINESURFACEWITHKNOTS = 167062518;
var IFCBEAM = 753842376;
var IFCBEAMSTANDARDCASE = 2906023776;
var IFCBEAMTYPE = 819618141;
var IFCBEARING = 4196446775;
var IFCBEARINGTYPE = 3649138523;
var IFCBLOBTEXTURE = 616511568;
var IFCBLOCK = 1334484129;
var IFCBOILER = 32344328;
var IFCBOILERTYPE = 231477066;
var IFCBOOLEANCLIPPINGRESULT = 3649129432;
var IFCBOOLEANRESULT = 2736907675;
var IFCBOUNDARYCONDITION = 4037036970;
var IFCBOUNDARYCURVE = 1136057603;
var IFCBOUNDARYEDGECONDITION = 1560379544;
var IFCBOUNDARYFACECONDITION = 3367102660;
var IFCBOUNDARYNODECONDITION = 1387855156;
var IFCBOUNDARYNODECONDITIONWARPING = 2069777674;
var IFCBOUNDEDCURVE = 1260505505;
var IFCBOUNDEDSURFACE = 4182860854;
var IFCBOUNDINGBOX = 2581212453;
var IFCBOXEDHALFSPACE = 2713105998;
var IFCBRIDGE = 644574406;
var IFCBRIDGEPART = 963979645;
var IFCBUILDING = 4031249490;
var IFCBUILDINGELEMENT = 3299480353;
var IFCBUILDINGELEMENTPART = 2979338954;
var IFCBUILDINGELEMENTPARTTYPE = 39481116;
var IFCBUILDINGELEMENTPROXY = 1095909175;
var IFCBUILDINGELEMENTPROXYTYPE = 1909888760;
var IFCBUILDINGELEMENTTYPE = 1950629157;
var IFCBUILDINGSTOREY = 3124254112;
var IFCBUILDINGSYSTEM = 1177604601;
var IFCBURNER = 2938176219;
var IFCBURNERTYPE = 2188180465;
var IFCCSHAPEPROFILEDEF = 2898889636;
var IFCCABLECARRIERFITTING = 635142910;
var IFCCABLECARRIERFITTINGTYPE = 395041908;
var IFCCABLECARRIERSEGMENT = 3758799889;
var IFCCABLECARRIERSEGMENTTYPE = 3293546465;
var IFCCABLEFITTING = 1051757585;
var IFCCABLEFITTINGTYPE = 2674252688;
var IFCCABLESEGMENT = 4217484030;
var IFCCABLESEGMENTTYPE = 1285652485;
var IFCCAISSONFOUNDATION = 3999819293;
var IFCCAISSONFOUNDATIONTYPE = 3203706013;
var IFCCARTESIANPOINT = 1123145078;
var IFCCARTESIANPOINTLIST = 574549367;
var IFCCARTESIANPOINTLIST2D = 1675464909;
var IFCCARTESIANPOINTLIST3D = 2059837836;
var IFCCARTESIANTRANSFORMATIONOPERATOR = 59481748;
var IFCCARTESIANTRANSFORMATIONOPERATOR2D = 3749851601;
var IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM = 3486308946;
var IFCCARTESIANTRANSFORMATIONOPERATOR3D = 3331915920;
var IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM = 1416205885;
var IFCCENTERLINEPROFILEDEF = 3150382593;
var IFCCHILLER = 3902619387;
var IFCCHILLERTYPE = 2951183804;
var IFCCHIMNEY = 3296154744;
var IFCCHIMNEYTYPE = 2197970202;
var IFCCIRCLE = 2611217952;
var IFCCIRCLEHOLLOWPROFILEDEF = 2937912522;
var IFCCIRCLEPROFILEDEF = 1383045692;
var IFCCIRCULARARCSEGMENT2D = 1062206242;
var IFCCIVILELEMENT = 1677625105;
var IFCCIVILELEMENTTYPE = 3893394355;
var IFCCLASSIFICATION = 747523909;
var IFCCLASSIFICATIONREFERENCE = 647927063;
var IFCCLOSEDSHELL = 2205249479;
var IFCCOIL = 639361253;
var IFCCOILTYPE = 2301859152;
var IFCCOLOURRGB = 776857604;
var IFCCOLOURRGBLIST = 3285139300;
var IFCCOLOURSPECIFICATION = 3264961684;
var IFCCOLUMN = 843113511;
var IFCCOLUMNSTANDARDCASE = 905975707;
var IFCCOLUMNTYPE = 300633059;
var IFCCOMMUNICATIONSAPPLIANCE = 3221913625;
var IFCCOMMUNICATIONSAPPLIANCETYPE = 400855858;
var IFCCOMPLEXPROPERTY = 2542286263;
var IFCCOMPLEXPROPERTYTEMPLATE = 3875453745;
var IFCCOMPOSITECURVE = 3732776249;
var IFCCOMPOSITECURVEONSURFACE = 15328376;
var IFCCOMPOSITECURVESEGMENT = 2485617015;
var IFCCOMPOSITEPROFILEDEF = 1485152156;
var IFCCOMPRESSOR = 3571504051;
var IFCCOMPRESSORTYPE = 3850581409;
var IFCCONDENSER = 2272882330;
var IFCCONDENSERTYPE = 2816379211;
var IFCCONIC = 2510884976;
var IFCCONNECTEDFACESET = 370225590;
var IFCCONNECTIONCURVEGEOMETRY = 1981873012;
var IFCCONNECTIONGEOMETRY = 2859738748;
var IFCCONNECTIONPOINTECCENTRICITY = 45288368;
var IFCCONNECTIONPOINTGEOMETRY = 2614616156;
var IFCCONNECTIONSURFACEGEOMETRY = 2732653382;
var IFCCONNECTIONVOLUMEGEOMETRY = 775493141;
var IFCCONSTRAINT = 1959218052;
var IFCCONSTRUCTIONEQUIPMENTRESOURCE = 3898045240;
var IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE = 2185764099;
var IFCCONSTRUCTIONMATERIALRESOURCE = 1060000209;
var IFCCONSTRUCTIONMATERIALRESOURCETYPE = 4105962743;
var IFCCONSTRUCTIONPRODUCTRESOURCE = 488727124;
var IFCCONSTRUCTIONPRODUCTRESOURCETYPE = 1525564444;
var IFCCONSTRUCTIONRESOURCE = 2559216714;
var IFCCONSTRUCTIONRESOURCETYPE = 2574617495;
var IFCCONTEXT = 3419103109;
var IFCCONTEXTDEPENDENTUNIT = 3050246964;
var IFCCONTROL = 3293443760;
var IFCCONTROLLER = 25142252;
var IFCCONTROLLERTYPE = 578613899;
var IFCCONVERSIONBASEDUNIT = 2889183280;
var IFCCONVERSIONBASEDUNITWITHOFFSET = 2713554722;
var IFCCOOLEDBEAM = 4136498852;
var IFCCOOLEDBEAMTYPE = 335055490;
var IFCCOOLINGTOWER = 3640358203;
var IFCCOOLINGTOWERTYPE = 2954562838;
var IFCCOORDINATEOPERATION = 1785450214;
var IFCCOORDINATEREFERENCESYSTEM = 1466758467;
var IFCCOSTITEM = 3895139033;
var IFCCOSTSCHEDULE = 1419761937;
var IFCCOSTVALUE = 602808272;
var IFCCOVERING = 1973544240;
var IFCCOVERINGTYPE = 1916426348;
var IFCCREWRESOURCE = 3295246426;
var IFCCREWRESOURCETYPE = 1815067380;
var IFCCSGPRIMITIVE3D = 2506170314;
var IFCCSGSOLID = 2147822146;
var IFCCURRENCYRELATIONSHIP = 539742890;
var IFCCURTAINWALL = 3495092785;
var IFCCURTAINWALLTYPE = 1457835157;
var IFCCURVE = 2601014836;
var IFCCURVEBOUNDEDPLANE = 2827736869;
var IFCCURVEBOUNDEDSURFACE = 2629017746;
var IFCCURVESEGMENT2D = 1186437898;
var IFCCURVESTYLE = 3800577675;
var IFCCURVESTYLEFONT = 1105321065;
var IFCCURVESTYLEFONTANDSCALING = 2367409068;
var IFCCURVESTYLEFONTPATTERN = 3510044353;
var IFCCYLINDRICALSURFACE = 1213902940;
var IFCDAMPER = 4074379575;
var IFCDAMPERTYPE = 3961806047;
var IFCDEEPFOUNDATION = 3426335179;
var IFCDEEPFOUNDATIONTYPE = 1306400036;
var IFCDERIVEDPROFILEDEF = 3632507154;
var IFCDERIVEDUNIT = 1765591967;
var IFCDERIVEDUNITELEMENT = 1045800335;
var IFCDIMENSIONALEXPONENTS = 2949456006;
var IFCDIRECTION = 32440307;
var IFCDISCRETEACCESSORY = 1335981549;
var IFCDISCRETEACCESSORYTYPE = 2635815018;
var IFCDISTANCEEXPRESSION = 1945343521;
var IFCDISTRIBUTIONCHAMBERELEMENT = 1052013943;
var IFCDISTRIBUTIONCHAMBERELEMENTTYPE = 1599208980;
var IFCDISTRIBUTIONCIRCUIT = 562808652;
var IFCDISTRIBUTIONCONTROLELEMENT = 1062813311;
var IFCDISTRIBUTIONCONTROLELEMENTTYPE = 2063403501;
var IFCDISTRIBUTIONELEMENT = 1945004755;
var IFCDISTRIBUTIONELEMENTTYPE = 3256556792;
var IFCDISTRIBUTIONFLOWELEMENT = 3040386961;
var IFCDISTRIBUTIONFLOWELEMENTTYPE = 3849074793;
var IFCDISTRIBUTIONPORT = 3041715199;
var IFCDISTRIBUTIONSYSTEM = 3205830791;
var IFCDOCUMENTINFORMATION = 1154170062;
var IFCDOCUMENTINFORMATIONRELATIONSHIP = 770865208;
var IFCDOCUMENTREFERENCE = 3732053477;
var IFCDOOR = 395920057;
var IFCDOORLININGPROPERTIES = 2963535650;
var IFCDOORPANELPROPERTIES = 1714330368;
var IFCDOORSTANDARDCASE = 3242481149;
var IFCDOORSTYLE = 526551008;
var IFCDOORTYPE = 2323601079;
var IFCDRAUGHTINGPREDEFINEDCOLOUR = 445594917;
var IFCDRAUGHTINGPREDEFINEDCURVEFONT = 4006246654;
var IFCDUCTFITTING = 342316401;
var IFCDUCTFITTINGTYPE = 869906466;
var IFCDUCTSEGMENT = 3518393246;
var IFCDUCTSEGMENTTYPE = 3760055223;
var IFCDUCTSILENCER = 1360408905;
var IFCDUCTSILENCERTYPE = 2030761528;
var IFCEDGE = 3900360178;
var IFCEDGECURVE = 476780140;
var IFCEDGELOOP = 1472233963;
var IFCELECTRICAPPLIANCE = 1904799276;
var IFCELECTRICAPPLIANCETYPE = 663422040;
var IFCELECTRICDISTRIBUTIONBOARD = 862014818;
var IFCELECTRICDISTRIBUTIONBOARDTYPE = 2417008758;
var IFCELECTRICFLOWSTORAGEDEVICE = 3310460725;
var IFCELECTRICFLOWSTORAGEDEVICETYPE = 3277789161;
var IFCELECTRICGENERATOR = 264262732;
var IFCELECTRICGENERATORTYPE = 1534661035;
var IFCELECTRICMOTOR = 402227799;
var IFCELECTRICMOTORTYPE = 1217240411;
var IFCELECTRICTIMECONTROL = 1003880860;
var IFCELECTRICTIMECONTROLTYPE = 712377611;
var IFCELEMENT = 1758889154;
var IFCELEMENTASSEMBLY = 4123344466;
var IFCELEMENTASSEMBLYTYPE = 2397081782;
var IFCELEMENTCOMPONENT = 1623761950;
var IFCELEMENTCOMPONENTTYPE = 2590856083;
var IFCELEMENTQUANTITY = 1883228015;
var IFCELEMENTTYPE = 339256511;
var IFCELEMENTARYSURFACE = 2777663545;
var IFCELLIPSE = 1704287377;
var IFCELLIPSEPROFILEDEF = 2835456948;
var IFCENERGYCONVERSIONDEVICE = 1658829314;
var IFCENERGYCONVERSIONDEVICETYPE = 2107101300;
var IFCENGINE = 2814081492;
var IFCENGINETYPE = 132023988;
var IFCEVAPORATIVECOOLER = 3747195512;
var IFCEVAPORATIVECOOLERTYPE = 3174744832;
var IFCEVAPORATOR = 484807127;
var IFCEVAPORATORTYPE = 3390157468;
var IFCEVENT = 4148101412;
var IFCEVENTTIME = 211053100;
var IFCEVENTTYPE = 4024345920;
var IFCEXTENDEDPROPERTIES = 297599258;
var IFCEXTERNALINFORMATION = 4294318154;
var IFCEXTERNALREFERENCE = 3200245327;
var IFCEXTERNALREFERENCERELATIONSHIP = 1437805879;
var IFCEXTERNALSPATIALELEMENT = 1209101575;
var IFCEXTERNALSPATIALSTRUCTUREELEMENT = 2853485674;
var IFCEXTERNALLYDEFINEDHATCHSTYLE = 2242383968;
var IFCEXTERNALLYDEFINEDSURFACESTYLE = 1040185647;
var IFCEXTERNALLYDEFINEDTEXTFONT = 3548104201;
var IFCEXTRUDEDAREASOLID = 477187591;
var IFCEXTRUDEDAREASOLIDTAPERED = 2804161546;
var IFCFACE = 2556980723;
var IFCFACEBASEDSURFACEMODEL = 2047409740;
var IFCFACEBOUND = 1809719519;
var IFCFACEOUTERBOUND = 803316827;
var IFCFACESURFACE = 3008276851;
var IFCFACETEDBREP = 807026263;
var IFCFACETEDBREPWITHVOIDS = 3737207727;
var IFCFACILITY = 24185140;
var IFCFACILITYPART = 1310830890;
var IFCFAILURECONNECTIONCONDITION = 4219587988;
var IFCFAN = 3415622556;
var IFCFANTYPE = 346874300;
var IFCFASTENER = 647756555;
var IFCFASTENERTYPE = 2489546625;
var IFCFEATUREELEMENT = 2827207264;
var IFCFEATUREELEMENTADDITION = 2143335405;
var IFCFEATUREELEMENTSUBTRACTION = 1287392070;
var IFCFILLAREASTYLE = 738692330;
var IFCFILLAREASTYLEHATCHING = 374418227;
var IFCFILLAREASTYLETILES = 315944413;
var IFCFILTER = 819412036;
var IFCFILTERTYPE = 1810631287;
var IFCFIRESUPPRESSIONTERMINAL = 1426591983;
var IFCFIRESUPPRESSIONTERMINALTYPE = 4222183408;
var IFCFIXEDREFERENCESWEPTAREASOLID = 2652556860;
var IFCFLOWCONTROLLER = 2058353004;
var IFCFLOWCONTROLLERTYPE = 3907093117;
var IFCFLOWFITTING = 4278956645;
var IFCFLOWFITTINGTYPE = 3198132628;
var IFCFLOWINSTRUMENT = 182646315;
var IFCFLOWINSTRUMENTTYPE = 4037862832;
var IFCFLOWMETER = 2188021234;
var IFCFLOWMETERTYPE = 3815607619;
var IFCFLOWMOVINGDEVICE = 3132237377;
var IFCFLOWMOVINGDEVICETYPE = 1482959167;
var IFCFLOWSEGMENT = 987401354;
var IFCFLOWSEGMENTTYPE = 1834744321;
var IFCFLOWSTORAGEDEVICE = 707683696;
var IFCFLOWSTORAGEDEVICETYPE = 1339347760;
var IFCFLOWTERMINAL = 2223149337;
var IFCFLOWTERMINALTYPE = 2297155007;
var IFCFLOWTREATMENTDEVICE = 3508470533;
var IFCFLOWTREATMENTDEVICETYPE = 3009222698;
var IFCFOOTING = 900683007;
var IFCFOOTINGTYPE = 1893162501;
var IFCFURNISHINGELEMENT = 263784265;
var IFCFURNISHINGELEMENTTYPE = 4238390223;
var IFCFURNITURE = 1509553395;
var IFCFURNITURETYPE = 1268542332;
var IFCGEOGRAPHICELEMENT = 3493046030;
var IFCGEOGRAPHICELEMENTTYPE = 4095422895;
var IFCGEOMETRICCURVESET = 987898635;
var IFCGEOMETRICREPRESENTATIONCONTEXT = 3448662350;
var IFCGEOMETRICREPRESENTATIONITEM = 2453401579;
var IFCGEOMETRICREPRESENTATIONSUBCONTEXT = 4142052618;
var IFCGEOMETRICSET = 3590301190;
var IFCGRID = 3009204131;
var IFCGRIDAXIS = 852622518;
var IFCGRIDPLACEMENT = 178086475;
var IFCGROUP = 2706460486;
var IFCHALFSPACESOLID = 812098782;
var IFCHEATEXCHANGER = 3319311131;
var IFCHEATEXCHANGERTYPE = 1251058090;
var IFCHUMIDIFIER = 2068733104;
var IFCHUMIDIFIERTYPE = 1806887404;
var IFCISHAPEPROFILEDEF = 1484403080;
var IFCIMAGETEXTURE = 3905492369;
var IFCINDEXEDCOLOURMAP = 3570813810;
var IFCINDEXEDPOLYCURVE = 2571569899;
var IFCINDEXEDPOLYGONALFACE = 178912537;
var IFCINDEXEDPOLYGONALFACEWITHVOIDS = 2294589976;
var IFCINDEXEDTEXTUREMAP = 1437953363;
var IFCINDEXEDTRIANGLETEXTUREMAP = 2133299955;
var IFCINTERCEPTOR = 4175244083;
var IFCINTERCEPTORTYPE = 3946677679;
var IFCINTERSECTIONCURVE = 3113134337;
var IFCINVENTORY = 2391368822;
var IFCIRREGULARTIMESERIES = 3741457305;
var IFCIRREGULARTIMESERIESVALUE = 3020489413;
var IFCJUNCTIONBOX = 2176052936;
var IFCJUNCTIONBOXTYPE = 4288270099;
var IFCLSHAPEPROFILEDEF = 572779678;
var IFCLABORRESOURCE = 3827777499;
var IFCLABORRESOURCETYPE = 428585644;
var IFCLAGTIME = 1585845231;
var IFCLAMP = 76236018;
var IFCLAMPTYPE = 1051575348;
var IFCLIBRARYINFORMATION = 2655187982;
var IFCLIBRARYREFERENCE = 3452421091;
var IFCLIGHTDISTRIBUTIONDATA = 4162380809;
var IFCLIGHTFIXTURE = 629592764;
var IFCLIGHTFIXTURETYPE = 1161773419;
var IFCLIGHTINTENSITYDISTRIBUTION = 1566485204;
var IFCLIGHTSOURCE = 1402838566;
var IFCLIGHTSOURCEAMBIENT = 125510826;
var IFCLIGHTSOURCEDIRECTIONAL = 2604431987;
var IFCLIGHTSOURCEGONIOMETRIC = 4266656042;
var IFCLIGHTSOURCEPOSITIONAL = 1520743889;
var IFCLIGHTSOURCESPOT = 3422422726;
var IFCLINE = 1281925730;
var IFCLINESEGMENT2D = 3092502836;
var IFCLINEARPLACEMENT = 388784114;
var IFCLINEARPOSITIONINGELEMENT = 1154579445;
var IFCLOCALPLACEMENT = 2624227202;
var IFCLOOP = 1008929658;
var IFCMANIFOLDSOLIDBREP = 1425443689;
var IFCMAPCONVERSION = 3057273783;
var IFCMAPPEDITEM = 2347385850;
var IFCMATERIAL = 1838606355;
var IFCMATERIALCLASSIFICATIONRELATIONSHIP = 1847130766;
var IFCMATERIALCONSTITUENT = 3708119e3;
var IFCMATERIALCONSTITUENTSET = 2852063980;
var IFCMATERIALDEFINITION = 760658860;
var IFCMATERIALDEFINITIONREPRESENTATION = 2022407955;
var IFCMATERIALLAYER = 248100487;
var IFCMATERIALLAYERSET = 3303938423;
var IFCMATERIALLAYERSETUSAGE = 1303795690;
var IFCMATERIALLAYERWITHOFFSETS = 1847252529;
var IFCMATERIALLIST = 2199411900;
var IFCMATERIALPROFILE = 2235152071;
var IFCMATERIALPROFILESET = 164193824;
var IFCMATERIALPROFILESETUSAGE = 3079605661;
var IFCMATERIALPROFILESETUSAGETAPERING = 3404854881;
var IFCMATERIALPROFILEWITHOFFSETS = 552965576;
var IFCMATERIALPROPERTIES = 3265635763;
var IFCMATERIALRELATIONSHIP = 853536259;
var IFCMATERIALUSAGEDEFINITION = 1507914824;
var IFCMEASUREWITHUNIT = 2597039031;
var IFCMECHANICALFASTENER = 377706215;
var IFCMECHANICALFASTENERTYPE = 2108223431;
var IFCMEDICALDEVICE = 1437502449;
var IFCMEDICALDEVICETYPE = 1114901282;
var IFCMEMBER = 1073191201;
var IFCMEMBERSTANDARDCASE = 1911478936;
var IFCMEMBERTYPE = 3181161470;
var IFCMETRIC = 3368373690;
var IFCMIRROREDPROFILEDEF = 2998442950;
var IFCMONETARYUNIT = 2706619895;
var IFCMOTORCONNECTION = 2474470126;
var IFCMOTORCONNECTIONTYPE = 977012517;
var IFCNAMEDUNIT = 1918398963;
var IFCOBJECT = 3888040117;
var IFCOBJECTDEFINITION = 219451334;
var IFCOBJECTPLACEMENT = 3701648758;
var IFCOBJECTIVE = 2251480897;
var IFCOCCUPANT = 4143007308;
var IFCOFFSETCURVE = 590820931;
var IFCOFFSETCURVE2D = 3388369263;
var IFCOFFSETCURVE3D = 3505215534;
var IFCOFFSETCURVEBYDISTANCES = 2485787929;
var IFCOPENSHELL = 2665983363;
var IFCOPENINGELEMENT = 3588315303;
var IFCOPENINGSTANDARDCASE = 3079942009;
var IFCORGANIZATION = 4251960020;
var IFCORGANIZATIONRELATIONSHIP = 1411181986;
var IFCORIENTATIONEXPRESSION = 643959842;
var IFCORIENTEDEDGE = 1029017970;
var IFCOUTERBOUNDARYCURVE = 144952367;
var IFCOUTLET = 3694346114;
var IFCOUTLETTYPE = 2837617999;
var IFCOWNERHISTORY = 1207048766;
var IFCPARAMETERIZEDPROFILEDEF = 2529465313;
var IFCPATH = 2519244187;
var IFCPCURVE = 1682466193;
var IFCPERFORMANCEHISTORY = 2382730787;
var IFCPERMEABLECOVERINGPROPERTIES = 3566463478;
var IFCPERMIT = 3327091369;
var IFCPERSON = 2077209135;
var IFCPERSONANDORGANIZATION = 101040310;
var IFCPHYSICALCOMPLEXQUANTITY = 3021840470;
var IFCPHYSICALQUANTITY = 2483315170;
var IFCPHYSICALSIMPLEQUANTITY = 2226359599;
var IFCPILE = 1687234759;
var IFCPILETYPE = 1158309216;
var IFCPIPEFITTING = 310824031;
var IFCPIPEFITTINGTYPE = 804291784;
var IFCPIPESEGMENT = 3612865200;
var IFCPIPESEGMENTTYPE = 4231323485;
var IFCPIXELTEXTURE = 597895409;
var IFCPLACEMENT = 2004835150;
var IFCPLANARBOX = 603570806;
var IFCPLANAREXTENT = 1663979128;
var IFCPLANE = 220341763;
var IFCPLATE = 3171933400;
var IFCPLATESTANDARDCASE = 1156407060;
var IFCPLATETYPE = 4017108033;
var IFCPOINT = 2067069095;
var IFCPOINTONCURVE = 4022376103;
var IFCPOINTONSURFACE = 1423911732;
var IFCPOLYLOOP = 2924175390;
var IFCPOLYGONALBOUNDEDHALFSPACE = 2775532180;
var IFCPOLYGONALFACESET = 2839578677;
var IFCPOLYLINE = 3724593414;
var IFCPORT = 3740093272;
var IFCPOSITIONINGELEMENT = 1946335990;
var IFCPOSTALADDRESS = 3355820592;
var IFCPREDEFINEDCOLOUR = 759155922;
var IFCPREDEFINEDCURVEFONT = 2559016684;
var IFCPREDEFINEDITEM = 3727388367;
var IFCPREDEFINEDPROPERTIES = 3778827333;
var IFCPREDEFINEDPROPERTYSET = 3967405729;
var IFCPREDEFINEDTEXTFONT = 1775413392;
var IFCPRESENTATIONITEM = 677532197;
var IFCPRESENTATIONLAYERASSIGNMENT = 2022622350;
var IFCPRESENTATIONLAYERWITHSTYLE = 1304840413;
var IFCPRESENTATIONSTYLE = 3119450353;
var IFCPRESENTATIONSTYLEASSIGNMENT = 2417041796;
var IFCPROCEDURE = 2744685151;
var IFCPROCEDURETYPE = 569719735;
var IFCPROCESS = 2945172077;
var IFCPRODUCT = 4208778838;
var IFCPRODUCTDEFINITIONSHAPE = 673634403;
var IFCPRODUCTREPRESENTATION = 2095639259;
var IFCPROFILEDEF = 3958567839;
var IFCPROFILEPROPERTIES = 2802850158;
var IFCPROJECT = 103090709;
var IFCPROJECTLIBRARY = 653396225;
var IFCPROJECTORDER = 2904328755;
var IFCPROJECTEDCRS = 3843373140;
var IFCPROJECTIONELEMENT = 3651124850;
var IFCPROPERTY = 2598011224;
var IFCPROPERTYABSTRACTION = 986844984;
var IFCPROPERTYBOUNDEDVALUE = 871118103;
var IFCPROPERTYDEFINITION = 1680319473;
var IFCPROPERTYDEPENDENCYRELATIONSHIP = 148025276;
var IFCPROPERTYENUMERATEDVALUE = 4166981789;
var IFCPROPERTYENUMERATION = 3710013099;
var IFCPROPERTYLISTVALUE = 2752243245;
var IFCPROPERTYREFERENCEVALUE = 941946838;
var IFCPROPERTYSET = 1451395588;
var IFCPROPERTYSETDEFINITION = 3357820518;
var IFCPROPERTYSETTEMPLATE = 492091185;
var IFCPROPERTYSINGLEVALUE = 3650150729;
var IFCPROPERTYTABLEVALUE = 110355661;
var IFCPROPERTYTEMPLATE = 3521284610;
var IFCPROPERTYTEMPLATEDEFINITION = 1482703590;
var IFCPROTECTIVEDEVICE = 738039164;
var IFCPROTECTIVEDEVICETRIPPINGUNIT = 2295281155;
var IFCPROTECTIVEDEVICETRIPPINGUNITTYPE = 655969474;
var IFCPROTECTIVEDEVICETYPE = 1842657554;
var IFCPROXY = 3219374653;
var IFCPUMP = 90941305;
var IFCPUMPTYPE = 2250791053;
var IFCQUANTITYAREA = 2044713172;
var IFCQUANTITYCOUNT = 2093928680;
var IFCQUANTITYLENGTH = 931644368;
var IFCQUANTITYSET = 2090586900;
var IFCQUANTITYTIME = 3252649465;
var IFCQUANTITYVOLUME = 2405470396;
var IFCQUANTITYWEIGHT = 825690147;
var IFCRAILING = 2262370178;
var IFCRAILINGTYPE = 2893384427;
var IFCRAMP = 3024970846;
var IFCRAMPFLIGHT = 3283111854;
var IFCRAMPFLIGHTTYPE = 2324767716;
var IFCRAMPTYPE = 1469900589;
var IFCRATIONALBSPLINECURVEWITHKNOTS = 1232101972;
var IFCRATIONALBSPLINESURFACEWITHKNOTS = 683857671;
var IFCRECTANGLEHOLLOWPROFILEDEF = 2770003689;
var IFCRECTANGLEPROFILEDEF = 3615266464;
var IFCRECTANGULARPYRAMID = 2798486643;
var IFCRECTANGULARTRIMMEDSURFACE = 3454111270;
var IFCRECURRENCEPATTERN = 3915482550;
var IFCREFERENCE = 2433181523;
var IFCREFERENT = 4021432810;
var IFCREGULARTIMESERIES = 3413951693;
var IFCREINFORCEMENTBARPROPERTIES = 1580146022;
var IFCREINFORCEMENTDEFINITIONPROPERTIES = 3765753017;
var IFCREINFORCINGBAR = 979691226;
var IFCREINFORCINGBARTYPE = 2572171363;
var IFCREINFORCINGELEMENT = 3027567501;
var IFCREINFORCINGELEMENTTYPE = 964333572;
var IFCREINFORCINGMESH = 2320036040;
var IFCREINFORCINGMESHTYPE = 2310774935;
var IFCRELAGGREGATES = 160246688;
var IFCRELASSIGNS = 3939117080;
var IFCRELASSIGNSTOACTOR = 1683148259;
var IFCRELASSIGNSTOCONTROL = 2495723537;
var IFCRELASSIGNSTOGROUP = 1307041759;
var IFCRELASSIGNSTOGROUPBYFACTOR = 1027710054;
var IFCRELASSIGNSTOPROCESS = 4278684876;
var IFCRELASSIGNSTOPRODUCT = 2857406711;
var IFCRELASSIGNSTORESOURCE = 205026976;
var IFCRELASSOCIATES = 1865459582;
var IFCRELASSOCIATESAPPROVAL = 4095574036;
var IFCRELASSOCIATESCLASSIFICATION = 919958153;
var IFCRELASSOCIATESCONSTRAINT = 2728634034;
var IFCRELASSOCIATESDOCUMENT = 982818633;
var IFCRELASSOCIATESLIBRARY = 3840914261;
var IFCRELASSOCIATESMATERIAL = 2655215786;
var IFCRELCONNECTS = 826625072;
var IFCRELCONNECTSELEMENTS = 1204542856;
var IFCRELCONNECTSPATHELEMENTS = 3945020480;
var IFCRELCONNECTSPORTTOELEMENT = 4201705270;
var IFCRELCONNECTSPORTS = 3190031847;
var IFCRELCONNECTSSTRUCTURALACTIVITY = 2127690289;
var IFCRELCONNECTSSTRUCTURALMEMBER = 1638771189;
var IFCRELCONNECTSWITHECCENTRICITY = 504942748;
var IFCRELCONNECTSWITHREALIZINGELEMENTS = 3678494232;
var IFCRELCONTAINEDINSPATIALSTRUCTURE = 3242617779;
var IFCRELCOVERSBLDGELEMENTS = 886880790;
var IFCRELCOVERSSPACES = 2802773753;
var IFCRELDECLARES = 2565941209;
var IFCRELDECOMPOSES = 2551354335;
var IFCRELDEFINES = 693640335;
var IFCRELDEFINESBYOBJECT = 1462361463;
var IFCRELDEFINESBYPROPERTIES = 4186316022;
var IFCRELDEFINESBYTEMPLATE = 307848117;
var IFCRELDEFINESBYTYPE = 781010003;
var IFCRELFILLSELEMENT = 3940055652;
var IFCRELFLOWCONTROLELEMENTS = 279856033;
var IFCRELINTERFERESELEMENTS = 427948657;
var IFCRELNESTS = 3268803585;
var IFCRELPOSITIONS = 1441486842;
var IFCRELPROJECTSELEMENT = 750771296;
var IFCRELREFERENCEDINSPATIALSTRUCTURE = 1245217292;
var IFCRELSEQUENCE = 4122056220;
var IFCRELSERVICESBUILDINGS = 366585022;
var IFCRELSPACEBOUNDARY = 3451746338;
var IFCRELSPACEBOUNDARY1STLEVEL = 3523091289;
var IFCRELSPACEBOUNDARY2NDLEVEL = 1521410863;
var IFCRELVOIDSELEMENT = 1401173127;
var IFCRELATIONSHIP = 478536968;
var IFCREPARAMETRISEDCOMPOSITECURVESEGMENT = 816062949;
var IFCREPRESENTATION = 1076942058;
var IFCREPRESENTATIONCONTEXT = 3377609919;
var IFCREPRESENTATIONITEM = 3008791417;
var IFCREPRESENTATIONMAP = 1660063152;
var IFCRESOURCE = 2914609552;
var IFCRESOURCEAPPROVALRELATIONSHIP = 2943643501;
var IFCRESOURCECONSTRAINTRELATIONSHIP = 1608871552;
var IFCRESOURCELEVELRELATIONSHIP = 2439245199;
var IFCRESOURCETIME = 1042787934;
var IFCREVOLVEDAREASOLID = 1856042241;
var IFCREVOLVEDAREASOLIDTAPERED = 3243963512;
var IFCRIGHTCIRCULARCONE = 4158566097;
var IFCRIGHTCIRCULARCYLINDER = 3626867408;
var IFCROOF = 2016517767;
var IFCROOFTYPE = 2781568857;
var IFCROOT = 2341007311;
var IFCROUNDEDRECTANGLEPROFILEDEF = 2778083089;
var IFCSIUNIT = 448429030;
var IFCSANITARYTERMINAL = 3053780830;
var IFCSANITARYTERMINALTYPE = 1768891740;
var IFCSCHEDULINGTIME = 1054537805;
var IFCSEAMCURVE = 2157484638;
var IFCSECTIONPROPERTIES = 2042790032;
var IFCSECTIONREINFORCEMENTPROPERTIES = 4165799628;
var IFCSECTIONEDSOLID = 1862484736;
var IFCSECTIONEDSOLIDHORIZONTAL = 1290935644;
var IFCSECTIONEDSPINE = 1509187699;
var IFCSENSOR = 4086658281;
var IFCSENSORTYPE = 1783015770;
var IFCSHADINGDEVICE = 1329646415;
var IFCSHADINGDEVICETYPE = 4074543187;
var IFCSHAPEASPECT = 867548509;
var IFCSHAPEMODEL = 3982875396;
var IFCSHAPEREPRESENTATION = 4240577450;
var IFCSHELLBASEDSURFACEMODEL = 4124623270;
var IFCSIMPLEPROPERTY = 3692461612;
var IFCSIMPLEPROPERTYTEMPLATE = 3663146110;
var IFCSITE = 4097777520;
var IFCSLAB = 1529196076;
var IFCSLABELEMENTEDCASE = 3127900445;
var IFCSLABSTANDARDCASE = 3027962421;
var IFCSLABTYPE = 2533589738;
var IFCSLIPPAGECONNECTIONCONDITION = 2609359061;
var IFCSOLARDEVICE = 3420628829;
var IFCSOLARDEVICETYPE = 1072016465;
var IFCSOLIDMODEL = 723233188;
var IFCSPACE = 3856911033;
var IFCSPACEHEATER = 1999602285;
var IFCSPACEHEATERTYPE = 1305183839;
var IFCSPACETYPE = 3812236995;
var IFCSPATIALELEMENT = 1412071761;
var IFCSPATIALELEMENTTYPE = 710998568;
var IFCSPATIALSTRUCTUREELEMENT = 2706606064;
var IFCSPATIALSTRUCTUREELEMENTTYPE = 3893378262;
var IFCSPATIALZONE = 463610769;
var IFCSPATIALZONETYPE = 2481509218;
var IFCSPHERE = 451544542;
var IFCSPHERICALSURFACE = 4015995234;
var IFCSTACKTERMINAL = 1404847402;
var IFCSTACKTERMINALTYPE = 3112655638;
var IFCSTAIR = 331165859;
var IFCSTAIRFLIGHT = 4252922144;
var IFCSTAIRFLIGHTTYPE = 1039846685;
var IFCSTAIRTYPE = 338393293;
var IFCSTRUCTURALACTION = 682877961;
var IFCSTRUCTURALACTIVITY = 3544373492;
var IFCSTRUCTURALANALYSISMODEL = 2515109513;
var IFCSTRUCTURALCONNECTION = 1179482911;
var IFCSTRUCTURALCONNECTIONCONDITION = 2273995522;
var IFCSTRUCTURALCURVEACTION = 1004757350;
var IFCSTRUCTURALCURVECONNECTION = 4243806635;
var IFCSTRUCTURALCURVEMEMBER = 214636428;
var IFCSTRUCTURALCURVEMEMBERVARYING = 2445595289;
var IFCSTRUCTURALCURVEREACTION = 2757150158;
var IFCSTRUCTURALITEM = 3136571912;
var IFCSTRUCTURALLINEARACTION = 1807405624;
var IFCSTRUCTURALLOAD = 2162789131;
var IFCSTRUCTURALLOADCASE = 385403989;
var IFCSTRUCTURALLOADCONFIGURATION = 3478079324;
var IFCSTRUCTURALLOADGROUP = 1252848954;
var IFCSTRUCTURALLOADLINEARFORCE = 1595516126;
var IFCSTRUCTURALLOADORRESULT = 609421318;
var IFCSTRUCTURALLOADPLANARFORCE = 2668620305;
var IFCSTRUCTURALLOADSINGLEDISPLACEMENT = 2473145415;
var IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION = 1973038258;
var IFCSTRUCTURALLOADSINGLEFORCE = 1597423693;
var IFCSTRUCTURALLOADSINGLEFORCEWARPING = 1190533807;
var IFCSTRUCTURALLOADSTATIC = 2525727697;
var IFCSTRUCTURALLOADTEMPERATURE = 3408363356;
var IFCSTRUCTURALMEMBER = 530289379;
var IFCSTRUCTURALPLANARACTION = 1621171031;
var IFCSTRUCTURALPOINTACTION = 2082059205;
var IFCSTRUCTURALPOINTCONNECTION = 734778138;
var IFCSTRUCTURALPOINTREACTION = 1235345126;
var IFCSTRUCTURALREACTION = 3689010777;
var IFCSTRUCTURALRESULTGROUP = 2986769608;
var IFCSTRUCTURALSURFACEACTION = 3657597509;
var IFCSTRUCTURALSURFACECONNECTION = 1975003073;
var IFCSTRUCTURALSURFACEMEMBER = 3979015343;
var IFCSTRUCTURALSURFACEMEMBERVARYING = 2218152070;
var IFCSTRUCTURALSURFACEREACTION = 603775116;
var IFCSTYLEMODEL = 2830218821;
var IFCSTYLEDITEM = 3958052878;
var IFCSTYLEDREPRESENTATION = 3049322572;
var IFCSUBCONTRACTRESOURCE = 148013059;
var IFCSUBCONTRACTRESOURCETYPE = 4095615324;
var IFCSUBEDGE = 2233826070;
var IFCSURFACE = 2513912981;
var IFCSURFACECURVE = 699246055;
var IFCSURFACECURVESWEPTAREASOLID = 2028607225;
var IFCSURFACEFEATURE = 3101698114;
var IFCSURFACEOFLINEAREXTRUSION = 2809605785;
var IFCSURFACEOFREVOLUTION = 4124788165;
var IFCSURFACEREINFORCEMENTAREA = 2934153892;
var IFCSURFACESTYLE = 1300840506;
var IFCSURFACESTYLELIGHTING = 3303107099;
var IFCSURFACESTYLEREFRACTION = 1607154358;
var IFCSURFACESTYLERENDERING = 1878645084;
var IFCSURFACESTYLESHADING = 846575682;
var IFCSURFACESTYLEWITHTEXTURES = 1351298697;
var IFCSURFACETEXTURE = 626085974;
var IFCSWEPTAREASOLID = 2247615214;
var IFCSWEPTDISKSOLID = 1260650574;
var IFCSWEPTDISKSOLIDPOLYGONAL = 1096409881;
var IFCSWEPTSURFACE = 230924584;
var IFCSWITCHINGDEVICE = 1162798199;
var IFCSWITCHINGDEVICETYPE = 2315554128;
var IFCSYSTEM = 2254336722;
var IFCSYSTEMFURNITUREELEMENT = 413509423;
var IFCSYSTEMFURNITUREELEMENTTYPE = 1580310250;
var IFCTSHAPEPROFILEDEF = 3071757647;
var IFCTABLE = 985171141;
var IFCTABLECOLUMN = 2043862942;
var IFCTABLEROW = 531007025;
var IFCTANK = 812556717;
var IFCTANKTYPE = 5716631;
var IFCTASK = 3473067441;
var IFCTASKTIME = 1549132990;
var IFCTASKTIMERECURRING = 2771591690;
var IFCTASKTYPE = 3206491090;
var IFCTELECOMADDRESS = 912023232;
var IFCTENDON = 3824725483;
var IFCTENDONANCHOR = 2347447852;
var IFCTENDONANCHORTYPE = 3081323446;
var IFCTENDONCONDUIT = 3663046924;
var IFCTENDONCONDUITTYPE = 2281632017;
var IFCTENDONTYPE = 2415094496;
var IFCTESSELLATEDFACESET = 2387106220;
var IFCTESSELLATEDITEM = 901063453;
var IFCTEXTLITERAL = 4282788508;
var IFCTEXTLITERALWITHEXTENT = 3124975700;
var IFCTEXTSTYLE = 1447204868;
var IFCTEXTSTYLEFONTMODEL = 1983826977;
var IFCTEXTSTYLEFORDEFINEDFONT = 2636378356;
var IFCTEXTSTYLETEXTMODEL = 1640371178;
var IFCTEXTURECOORDINATE = 280115917;
var IFCTEXTURECOORDINATEGENERATOR = 1742049831;
var IFCTEXTUREMAP = 2552916305;
var IFCTEXTUREVERTEX = 1210645708;
var IFCTEXTUREVERTEXLIST = 3611470254;
var IFCTIMEPERIOD = 1199560280;
var IFCTIMESERIES = 3101149627;
var IFCTIMESERIESVALUE = 581633288;
var IFCTOPOLOGICALREPRESENTATIONITEM = 1377556343;
var IFCTOPOLOGYREPRESENTATION = 1735638870;
var IFCTOROIDALSURFACE = 1935646853;
var IFCTRANSFORMER = 3825984169;
var IFCTRANSFORMERTYPE = 1692211062;
var IFCTRANSITIONCURVESEGMENT2D = 2595432518;
var IFCTRANSPORTELEMENT = 1620046519;
var IFCTRANSPORTELEMENTTYPE = 2097647324;
var IFCTRAPEZIUMPROFILEDEF = 2715220739;
var IFCTRIANGULATEDFACESET = 2916149573;
var IFCTRIANGULATEDIRREGULARNETWORK = 1229763772;
var IFCTRIMMEDCURVE = 3593883385;
var IFCTUBEBUNDLE = 3026737570;
var IFCTUBEBUNDLETYPE = 1600972822;
var IFCTYPEOBJECT = 1628702193;
var IFCTYPEPROCESS = 3736923433;
var IFCTYPEPRODUCT = 2347495698;
var IFCTYPERESOURCE = 3698973494;
var IFCUSHAPEPROFILEDEF = 427810014;
var IFCUNITASSIGNMENT = 180925521;
var IFCUNITARYCONTROLELEMENT = 630975310;
var IFCUNITARYCONTROLELEMENTTYPE = 3179687236;
var IFCUNITARYEQUIPMENT = 4292641817;
var IFCUNITARYEQUIPMENTTYPE = 1911125066;
var IFCVALVE = 4207607924;
var IFCVALVETYPE = 728799441;
var IFCVECTOR = 1417489154;
var IFCVERTEX = 2799835756;
var IFCVERTEXLOOP = 2759199220;
var IFCVERTEXPOINT = 1907098498;
var IFCVIBRATIONDAMPER = 1530820697;
var IFCVIBRATIONDAMPERTYPE = 3956297820;
var IFCVIBRATIONISOLATOR = 2391383451;
var IFCVIBRATIONISOLATORTYPE = 3313531582;
var IFCVIRTUALELEMENT = 2769231204;
var IFCVIRTUALGRIDINTERSECTION = 891718957;
var IFCVOIDINGFEATURE = 926996030;
var IFCWALL = 2391406946;
var IFCWALLELEMENTEDCASE = 4156078855;
var IFCWALLSTANDARDCASE = 3512223829;
var IFCWALLTYPE = 1898987631;
var IFCWASTETERMINAL = 4237592921;
var IFCWASTETERMINALTYPE = 1133259667;
var IFCWINDOW = 3304561284;
var IFCWINDOWLININGPROPERTIES = 336235671;
var IFCWINDOWPANELPROPERTIES = 512836454;
var IFCWINDOWSTANDARDCASE = 486154966;
var IFCWINDOWSTYLE = 1299126871;
var IFCWINDOWTYPE = 4009809668;
var IFCWORKCALENDAR = 4088093105;
var IFCWORKCONTROL = 1028945134;
var IFCWORKPLAN = 4218914973;
var IFCWORKSCHEDULE = 3342526732;
var IFCWORKTIME = 1236880293;
var IFCZSHAPEPROFILEDEF = 2543172580;
var IFCZONE = 1033361043;
var IfcElements$1 = [
  IFCACTUATOR,
  IFCAIRTERMINAL,
  IFCAIRTERMINALBOX,
  IFCAIRTOAIRHEATRECOVERY,
  IFCALARM,
  IFCALIGNMENT,
  IFCANNOTATION,
  IFCAUDIOVISUALAPPLIANCE,
  IFCBEAM,
  IFCBEAMSTANDARDCASE,
  IFCBEARING,
  IFCBOILER,
  IFCBRIDGE,
  IFCBRIDGEPART,
  IFCBUILDING,
  IFCBUILDINGELEMENT,
  IFCBUILDINGELEMENTPART,
  IFCBUILDINGELEMENTPROXY,
  IFCBUILDINGSTOREY,
  IFCBURNER,
  IFCCABLECARRIERFITTING,
  IFCCABLECARRIERSEGMENT,
  IFCCABLEFITTING,
  IFCCABLESEGMENT,
  IFCCAISSONFOUNDATION,
  IFCCHILLER,
  IFCCHIMNEY,
  IFCCIVILELEMENT,
  IFCCOIL,
  IFCCOLUMN,
  IFCCOLUMNSTANDARDCASE,
  IFCCOMMUNICATIONSAPPLIANCE,
  IFCCOMPRESSOR,
  IFCCONDENSER,
  IFCCONTROLLER,
  IFCCOOLEDBEAM,
  IFCCOOLINGTOWER,
  IFCCOVERING,
  IFCCURTAINWALL,
  IFCDAMPER,
  IFCDEEPFOUNDATION,
  IFCDISCRETEACCESSORY,
  IFCDISTRIBUTIONCHAMBERELEMENT,
  IFCDISTRIBUTIONCONTROLELEMENT,
  IFCDISTRIBUTIONELEMENT,
  IFCDISTRIBUTIONFLOWELEMENT,
  IFCDISTRIBUTIONPORT,
  IFCDOOR,
  IFCDOORSTANDARDCASE,
  IFCDUCTFITTING,
  IFCDUCTSEGMENT,
  IFCDUCTSILENCER,
  IFCELECTRICAPPLIANCE,
  IFCELECTRICDISTRIBUTIONBOARD,
  IFCELECTRICFLOWSTORAGEDEVICE,
  IFCELECTRICGENERATOR,
  IFCELECTRICMOTOR,
  IFCELECTRICTIMECONTROL,
  IFCELEMENT,
  IFCELEMENTASSEMBLY,
  IFCELEMENTCOMPONENT,
  IFCENERGYCONVERSIONDEVICE,
  IFCENGINE,
  IFCEVAPORATIVECOOLER,
  IFCEVAPORATOR,
  IFCEXTERNALSPATIALELEMENT,
  IFCEXTERNALSPATIALSTRUCTUREELEMENT,
  IFCFACILITY,
  IFCFACILITYPART,
  IFCFAN,
  IFCFASTENER,
  IFCFEATUREELEMENT,
  IFCFEATUREELEMENTADDITION,
  IFCFEATUREELEMENTSUBTRACTION,
  IFCFILTER,
  IFCFIRESUPPRESSIONTERMINAL,
  IFCFLOWCONTROLLER,
  IFCFLOWFITTING,
  IFCFLOWINSTRUMENT,
  IFCFLOWMETER,
  IFCFLOWMOVINGDEVICE,
  IFCFLOWSEGMENT,
  IFCFLOWSTORAGEDEVICE,
  IFCFLOWTERMINAL,
  IFCFLOWTREATMENTDEVICE,
  IFCFOOTING,
  IFCFURNISHINGELEMENT,
  IFCFURNITURE,
  IFCGEOGRAPHICELEMENT,
  IFCGRID,
  IFCHEATEXCHANGER,
  IFCHUMIDIFIER,
  IFCINTERCEPTOR,
  IFCJUNCTIONBOX,
  IFCLAMP,
  IFCLIGHTFIXTURE,
  IFCLINEARPOSITIONINGELEMENT,
  IFCMECHANICALFASTENER,
  IFCMEDICALDEVICE,
  IFCMEMBER,
  IFCMEMBERSTANDARDCASE,
  IFCMOTORCONNECTION,
  IFCOPENINGELEMENT,
  IFCOPENINGSTANDARDCASE,
  IFCOUTLET,
  IFCPILE,
  IFCPIPEFITTING,
  IFCPIPESEGMENT,
  IFCPLATE,
  IFCPLATESTANDARDCASE,
  IFCPORT,
  IFCPOSITIONINGELEMENT,
  IFCPROJECTIONELEMENT,
  IFCPROTECTIVEDEVICE,
  IFCPROTECTIVEDEVICETRIPPINGUNIT,
  IFCPROXY,
  IFCPUMP,
  IFCRAILING,
  IFCRAMP,
  IFCRAMPFLIGHT,
  IFCREFERENT,
  IFCREINFORCINGBAR,
  IFCREINFORCINGELEMENT,
  IFCREINFORCINGMESH,
  IFCROOF,
  IFCSANITARYTERMINAL,
  IFCSENSOR,
  IFCSHADINGDEVICE,
  IFCSITE,
  IFCSLAB,
  IFCSLABELEMENTEDCASE,
  IFCSLABSTANDARDCASE,
  IFCSOLARDEVICE,
  IFCSPACE,
  IFCSPACEHEATER,
  IFCSPATIALELEMENT,
  IFCSPATIALSTRUCTUREELEMENT,
  IFCSPATIALZONE,
  IFCSTACKTERMINAL,
  IFCSTAIR,
  IFCSTAIRFLIGHT,
  IFCSTRUCTURALACTION,
  IFCSTRUCTURALACTIVITY,
  IFCSTRUCTURALCONNECTION,
  IFCSTRUCTURALCURVEACTION,
  IFCSTRUCTURALCURVECONNECTION,
  IFCSTRUCTURALCURVEMEMBER,
  IFCSTRUCTURALCURVEMEMBERVARYING,
  IFCSTRUCTURALCURVEREACTION,
  IFCSTRUCTURALITEM,
  IFCSTRUCTURALLINEARACTION,
  IFCSTRUCTURALMEMBER,
  IFCSTRUCTURALPLANARACTION,
  IFCSTRUCTURALPOINTACTION,
  IFCSTRUCTURALPOINTCONNECTION,
  IFCSTRUCTURALPOINTREACTION,
  IFCSTRUCTURALREACTION,
  IFCSTRUCTURALSURFACEACTION,
  IFCSTRUCTURALSURFACECONNECTION,
  IFCSTRUCTURALSURFACEMEMBER,
  IFCSTRUCTURALSURFACEMEMBERVARYING,
  IFCSTRUCTURALSURFACEREACTION,
  IFCSURFACEFEATURE,
  IFCSWITCHINGDEVICE,
  IFCSYSTEMFURNITUREELEMENT,
  IFCTANK,
  IFCTENDON,
  IFCTENDONANCHOR,
  IFCTENDONCONDUIT,
  IFCTRANSFORMER,
  IFCTRANSPORTELEMENT,
  IFCTUBEBUNDLE,
  IFCUNITARYCONTROLELEMENT,
  IFCUNITARYEQUIPMENT,
  IFCVALVE,
  IFCVIBRATIONDAMPER,
  IFCVIBRATIONISOLATOR,
  IFCVIRTUALELEMENT,
  IFCVOIDINGFEATURE,
  IFCWALL,
  IFCWALLELEMENTEDCASE,
  IFCWALLSTANDARDCASE,
  IFCWASTETERMINAL,
  IFCWINDOW,
  IFCWINDOWSTANDARDCASE
];

// dist/ifc2x4_helper.ts
var FromRawLineData = {};
FromRawLineData[IFCACTIONREQUEST] = (d) => {
  return IfcActionRequest.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCACTOR] = (d) => {
  return IfcActor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCACTORROLE] = (d) => {
  return IfcActorRole.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCACTUATOR] = (d) => {
  return IfcActuator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCACTUATORTYPE] = (d) => {
  return IfcActuatorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCADDRESS] = (d) => {
  return IfcAddress.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCADVANCEDBREP] = (d) => {
  return IfcAdvancedBrep.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCADVANCEDBREPWITHVOIDS] = (d) => {
  return IfcAdvancedBrepWithVoids.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCADVANCEDFACE] = (d) => {
  return IfcAdvancedFace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTERMINAL] = (d) => {
  return IfcAirTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTERMINALBOX] = (d) => {
  return IfcAirTerminalBox.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTERMINALBOXTYPE] = (d) => {
  return IfcAirTerminalBoxType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTERMINALTYPE] = (d) => {
  return IfcAirTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTOAIRHEATRECOVERY] = (d) => {
  return IfcAirToAirHeatRecovery.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTOAIRHEATRECOVERYTYPE] = (d) => {
  return IfcAirToAirHeatRecoveryType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALARM] = (d) => {
  return IfcAlarm.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALARMTYPE] = (d) => {
  return IfcAlarmType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT] = (d) => {
  return IfcAlignment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DHORIZONTAL] = (d) => {
  return IfcAlignment2DHorizontal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DHORIZONTALSEGMENT] = (d) => {
  return IfcAlignment2DHorizontalSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DSEGMENT] = (d) => {
  return IfcAlignment2DSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DVERSEGCIRCULARARC] = (d) => {
  return IfcAlignment2DVerSegCircularArc.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DVERSEGLINE] = (d) => {
  return IfcAlignment2DVerSegLine.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DVERSEGPARABOLICARC] = (d) => {
  return IfcAlignment2DVerSegParabolicArc.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DVERTICAL] = (d) => {
  return IfcAlignment2DVertical.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DVERTICALSEGMENT] = (d) => {
  return IfcAlignment2DVerticalSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENTCURVE] = (d) => {
  return IfcAlignmentCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCANNOTATION] = (d) => {
  return IfcAnnotation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCANNOTATIONFILLAREA] = (d) => {
  return IfcAnnotationFillArea.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAPPLICATION] = (d) => {
  return IfcApplication.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAPPLIEDVALUE] = (d) => {
  return IfcAppliedValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAPPROVAL] = (d) => {
  return IfcApproval.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAPPROVALRELATIONSHIP] = (d) => {
  return IfcApprovalRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCARBITRARYCLOSEDPROFILEDEF] = (d) => {
  return IfcArbitraryClosedProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCARBITRARYOPENPROFILEDEF] = (d) => {
  return IfcArbitraryOpenProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCARBITRARYPROFILEDEFWITHVOIDS] = (d) => {
  return IfcArbitraryProfileDefWithVoids.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCASSET] = (d) => {
  return IfcAsset.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCASYMMETRICISHAPEPROFILEDEF] = (d) => {
  return IfcAsymmetricIShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAUDIOVISUALAPPLIANCE] = (d) => {
  return IfcAudioVisualAppliance.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAUDIOVISUALAPPLIANCETYPE] = (d) => {
  return IfcAudioVisualApplianceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAXIS1PLACEMENT] = (d) => {
  return IfcAxis1Placement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAXIS2PLACEMENT2D] = (d) => {
  return IfcAxis2Placement2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAXIS2PLACEMENT3D] = (d) => {
  return IfcAxis2Placement3D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBSPLINECURVE] = (d) => {
  return IfcBSplineCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBSPLINECURVEWITHKNOTS] = (d) => {
  return IfcBSplineCurveWithKnots.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBSPLINESURFACE] = (d) => {
  return IfcBSplineSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBSPLINESURFACEWITHKNOTS] = (d) => {
  return IfcBSplineSurfaceWithKnots.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBEAM] = (d) => {
  return IfcBeam.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBEAMSTANDARDCASE] = (d) => {
  return IfcBeamStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBEAMTYPE] = (d) => {
  return IfcBeamType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBEARING] = (d) => {
  return IfcBearing.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBEARINGTYPE] = (d) => {
  return IfcBearingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBLOBTEXTURE] = (d) => {
  return IfcBlobTexture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBLOCK] = (d) => {
  return IfcBlock.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOILER] = (d) => {
  return IfcBoiler.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOILERTYPE] = (d) => {
  return IfcBoilerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOOLEANCLIPPINGRESULT] = (d) => {
  return IfcBooleanClippingResult.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOOLEANRESULT] = (d) => {
  return IfcBooleanResult.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYCONDITION] = (d) => {
  return IfcBoundaryCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYCURVE] = (d) => {
  return IfcBoundaryCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYEDGECONDITION] = (d) => {
  return IfcBoundaryEdgeCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYFACECONDITION] = (d) => {
  return IfcBoundaryFaceCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYNODECONDITION] = (d) => {
  return IfcBoundaryNodeCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYNODECONDITIONWARPING] = (d) => {
  return IfcBoundaryNodeConditionWarping.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDEDCURVE] = (d) => {
  return IfcBoundedCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDEDSURFACE] = (d) => {
  return IfcBoundedSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDINGBOX] = (d) => {
  return IfcBoundingBox.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOXEDHALFSPACE] = (d) => {
  return IfcBoxedHalfSpace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBRIDGE] = (d) => {
  return IfcBridge.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBRIDGEPART] = (d) => {
  return IfcBridgePart.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDING] = (d) => {
  return IfcBuilding.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENT] = (d) => {
  return IfcBuildingElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENTPART] = (d) => {
  return IfcBuildingElementPart.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENTPARTTYPE] = (d) => {
  return IfcBuildingElementPartType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENTPROXY] = (d) => {
  return IfcBuildingElementProxy.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENTPROXYTYPE] = (d) => {
  return IfcBuildingElementProxyType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENTTYPE] = (d) => {
  return IfcBuildingElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGSTOREY] = (d) => {
  return IfcBuildingStorey.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGSYSTEM] = (d) => {
  return IfcBuildingSystem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBURNER] = (d) => {
  return IfcBurner.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBURNERTYPE] = (d) => {
  return IfcBurnerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCSHAPEPROFILEDEF] = (d) => {
  return IfcCShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLECARRIERFITTING] = (d) => {
  return IfcCableCarrierFitting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLECARRIERFITTINGTYPE] = (d) => {
  return IfcCableCarrierFittingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLECARRIERSEGMENT] = (d) => {
  return IfcCableCarrierSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLECARRIERSEGMENTTYPE] = (d) => {
  return IfcCableCarrierSegmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLEFITTING] = (d) => {
  return IfcCableFitting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLEFITTINGTYPE] = (d) => {
  return IfcCableFittingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLESEGMENT] = (d) => {
  return IfcCableSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLESEGMENTTYPE] = (d) => {
  return IfcCableSegmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCAISSONFOUNDATION] = (d) => {
  return IfcCaissonFoundation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCAISSONFOUNDATIONTYPE] = (d) => {
  return IfcCaissonFoundationType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANPOINT] = (d) => {
  return IfcCartesianPoint.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANPOINTLIST] = (d) => {
  return IfcCartesianPointList.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANPOINTLIST2D] = (d) => {
  return IfcCartesianPointList2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANPOINTLIST3D] = (d) => {
  return IfcCartesianPointList3D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR] = (d) => {
  return IfcCartesianTransformationOperator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR2D] = (d) => {
  return IfcCartesianTransformationOperator2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM] = (d) => {
  return IfcCartesianTransformationOperator2DnonUniform.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR3D] = (d) => {
  return IfcCartesianTransformationOperator3D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM] = (d) => {
  return IfcCartesianTransformationOperator3DnonUniform.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCENTERLINEPROFILEDEF] = (d) => {
  return IfcCenterLineProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCHILLER] = (d) => {
  return IfcChiller.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCHILLERTYPE] = (d) => {
  return IfcChillerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCHIMNEY] = (d) => {
  return IfcChimney.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCHIMNEYTYPE] = (d) => {
  return IfcChimneyType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIRCLE] = (d) => {
  return IfcCircle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIRCLEHOLLOWPROFILEDEF] = (d) => {
  return IfcCircleHollowProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIRCLEPROFILEDEF] = (d) => {
  return IfcCircleProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIRCULARARCSEGMENT2D] = (d) => {
  return IfcCircularArcSegment2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIVILELEMENT] = (d) => {
  return IfcCivilElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIVILELEMENTTYPE] = (d) => {
  return IfcCivilElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCLASSIFICATION] = (d) => {
  return IfcClassification.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCLASSIFICATIONREFERENCE] = (d) => {
  return IfcClassificationReference.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCLOSEDSHELL] = (d) => {
  return IfcClosedShell.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOIL] = (d) => {
  return IfcCoil.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOILTYPE] = (d) => {
  return IfcCoilType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLOURRGB] = (d) => {
  return IfcColourRgb.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLOURRGBLIST] = (d) => {
  return IfcColourRgbList.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLOURSPECIFICATION] = (d) => {
  return IfcColourSpecification.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLUMN] = (d) => {
  return IfcColumn.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLUMNSTANDARDCASE] = (d) => {
  return IfcColumnStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLUMNTYPE] = (d) => {
  return IfcColumnType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMMUNICATIONSAPPLIANCE] = (d) => {
  return IfcCommunicationsAppliance.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMMUNICATIONSAPPLIANCETYPE] = (d) => {
  return IfcCommunicationsApplianceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPLEXPROPERTY] = (d) => {
  return IfcComplexProperty.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPLEXPROPERTYTEMPLATE] = (d) => {
  return IfcComplexPropertyTemplate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPOSITECURVE] = (d) => {
  return IfcCompositeCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPOSITECURVEONSURFACE] = (d) => {
  return IfcCompositeCurveOnSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPOSITECURVESEGMENT] = (d) => {
  return IfcCompositeCurveSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPOSITEPROFILEDEF] = (d) => {
  return IfcCompositeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPRESSOR] = (d) => {
  return IfcCompressor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPRESSORTYPE] = (d) => {
  return IfcCompressorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONDENSER] = (d) => {
  return IfcCondenser.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONDENSERTYPE] = (d) => {
  return IfcCondenserType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONIC] = (d) => {
  return IfcConic.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTEDFACESET] = (d) => {
  return IfcConnectedFaceSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONCURVEGEOMETRY] = (d) => {
  return IfcConnectionCurveGeometry.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONGEOMETRY] = (d) => {
  return IfcConnectionGeometry.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONPOINTECCENTRICITY] = (d) => {
  return IfcConnectionPointEccentricity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONPOINTGEOMETRY] = (d) => {
  return IfcConnectionPointGeometry.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONSURFACEGEOMETRY] = (d) => {
  return IfcConnectionSurfaceGeometry.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONVOLUMEGEOMETRY] = (d) => {
  return IfcConnectionVolumeGeometry.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRAINT] = (d) => {
  return IfcConstraint.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONEQUIPMENTRESOURCE] = (d) => {
  return IfcConstructionEquipmentResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE] = (d) => {
  return IfcConstructionEquipmentResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONMATERIALRESOURCE] = (d) => {
  return IfcConstructionMaterialResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONMATERIALRESOURCETYPE] = (d) => {
  return IfcConstructionMaterialResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONPRODUCTRESOURCE] = (d) => {
  return IfcConstructionProductResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONPRODUCTRESOURCETYPE] = (d) => {
  return IfcConstructionProductResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONRESOURCE] = (d) => {
  return IfcConstructionResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONRESOURCETYPE] = (d) => {
  return IfcConstructionResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONTEXT] = (d) => {
  return IfcContext.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONTEXTDEPENDENTUNIT] = (d) => {
  return IfcContextDependentUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONTROL] = (d) => {
  return IfcControl.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONTROLLER] = (d) => {
  return IfcController.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONTROLLERTYPE] = (d) => {
  return IfcControllerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONVERSIONBASEDUNIT] = (d) => {
  return IfcConversionBasedUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONVERSIONBASEDUNITWITHOFFSET] = (d) => {
  return IfcConversionBasedUnitWithOffset.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOOLEDBEAM] = (d) => {
  return IfcCooledBeam.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOOLEDBEAMTYPE] = (d) => {
  return IfcCooledBeamType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOOLINGTOWER] = (d) => {
  return IfcCoolingTower.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOOLINGTOWERTYPE] = (d) => {
  return IfcCoolingTowerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOORDINATEOPERATION] = (d) => {
  return IfcCoordinateOperation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOORDINATEREFERENCESYSTEM] = (d) => {
  return IfcCoordinateReferenceSystem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOSTITEM] = (d) => {
  return IfcCostItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOSTSCHEDULE] = (d) => {
  return IfcCostSchedule.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOSTVALUE] = (d) => {
  return IfcCostValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOVERING] = (d) => {
  return IfcCovering.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOVERINGTYPE] = (d) => {
  return IfcCoveringType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCREWRESOURCE] = (d) => {
  return IfcCrewResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCREWRESOURCETYPE] = (d) => {
  return IfcCrewResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCSGPRIMITIVE3D] = (d) => {
  return IfcCsgPrimitive3D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCSGSOLID] = (d) => {
  return IfcCsgSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURRENCYRELATIONSHIP] = (d) => {
  return IfcCurrencyRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURTAINWALL] = (d) => {
  return IfcCurtainWall.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURTAINWALLTYPE] = (d) => {
  return IfcCurtainWallType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVE] = (d) => {
  return IfcCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVEBOUNDEDPLANE] = (d) => {
  return IfcCurveBoundedPlane.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVEBOUNDEDSURFACE] = (d) => {
  return IfcCurveBoundedSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVESEGMENT2D] = (d) => {
  return IfcCurveSegment2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVESTYLE] = (d) => {
  return IfcCurveStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVESTYLEFONT] = (d) => {
  return IfcCurveStyleFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVESTYLEFONTANDSCALING] = (d) => {
  return IfcCurveStyleFontAndScaling.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVESTYLEFONTPATTERN] = (d) => {
  return IfcCurveStyleFontPattern.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCYLINDRICALSURFACE] = (d) => {
  return IfcCylindricalSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDAMPER] = (d) => {
  return IfcDamper.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDAMPERTYPE] = (d) => {
  return IfcDamperType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDEEPFOUNDATION] = (d) => {
  return IfcDeepFoundation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDEEPFOUNDATIONTYPE] = (d) => {
  return IfcDeepFoundationType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDERIVEDPROFILEDEF] = (d) => {
  return IfcDerivedProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDERIVEDUNIT] = (d) => {
  return IfcDerivedUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDERIVEDUNITELEMENT] = (d) => {
  return IfcDerivedUnitElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDIMENSIONALEXPONENTS] = (d) => {
  return IfcDimensionalExponents.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDIRECTION] = (d) => {
  return IfcDirection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISCRETEACCESSORY] = (d) => {
  return IfcDiscreteAccessory.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISCRETEACCESSORYTYPE] = (d) => {
  return IfcDiscreteAccessoryType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTANCEEXPRESSION] = (d) => {
  return IfcDistanceExpression.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONCHAMBERELEMENT] = (d) => {
  return IfcDistributionChamberElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONCHAMBERELEMENTTYPE] = (d) => {
  return IfcDistributionChamberElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONCIRCUIT] = (d) => {
  return IfcDistributionCircuit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONCONTROLELEMENT] = (d) => {
  return IfcDistributionControlElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONCONTROLELEMENTTYPE] = (d) => {
  return IfcDistributionControlElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONELEMENT] = (d) => {
  return IfcDistributionElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONELEMENTTYPE] = (d) => {
  return IfcDistributionElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONFLOWELEMENT] = (d) => {
  return IfcDistributionFlowElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONFLOWELEMENTTYPE] = (d) => {
  return IfcDistributionFlowElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONPORT] = (d) => {
  return IfcDistributionPort.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONSYSTEM] = (d) => {
  return IfcDistributionSystem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOCUMENTINFORMATION] = (d) => {
  return IfcDocumentInformation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOCUMENTINFORMATIONRELATIONSHIP] = (d) => {
  return IfcDocumentInformationRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOCUMENTREFERENCE] = (d) => {
  return IfcDocumentReference.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOOR] = (d) => {
  return IfcDoor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOORLININGPROPERTIES] = (d) => {
  return IfcDoorLiningProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOORPANELPROPERTIES] = (d) => {
  return IfcDoorPanelProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOORSTANDARDCASE] = (d) => {
  return IfcDoorStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOORSTYLE] = (d) => {
  return IfcDoorStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOORTYPE] = (d) => {
  return IfcDoorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDRAUGHTINGPREDEFINEDCOLOUR] = (d) => {
  return IfcDraughtingPreDefinedColour.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDRAUGHTINGPREDEFINEDCURVEFONT] = (d) => {
  return IfcDraughtingPreDefinedCurveFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTFITTING] = (d) => {
  return IfcDuctFitting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTFITTINGTYPE] = (d) => {
  return IfcDuctFittingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTSEGMENT] = (d) => {
  return IfcDuctSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTSEGMENTTYPE] = (d) => {
  return IfcDuctSegmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTSILENCER] = (d) => {
  return IfcDuctSilencer.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTSILENCERTYPE] = (d) => {
  return IfcDuctSilencerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEDGE] = (d) => {
  return IfcEdge.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEDGECURVE] = (d) => {
  return IfcEdgeCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEDGELOOP] = (d) => {
  return IfcEdgeLoop.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICAPPLIANCE] = (d) => {
  return IfcElectricAppliance.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICAPPLIANCETYPE] = (d) => {
  return IfcElectricApplianceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICDISTRIBUTIONBOARD] = (d) => {
  return IfcElectricDistributionBoard.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICDISTRIBUTIONBOARDTYPE] = (d) => {
  return IfcElectricDistributionBoardType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICFLOWSTORAGEDEVICE] = (d) => {
  return IfcElectricFlowStorageDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICFLOWSTORAGEDEVICETYPE] = (d) => {
  return IfcElectricFlowStorageDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICGENERATOR] = (d) => {
  return IfcElectricGenerator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICGENERATORTYPE] = (d) => {
  return IfcElectricGeneratorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICMOTOR] = (d) => {
  return IfcElectricMotor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICMOTORTYPE] = (d) => {
  return IfcElectricMotorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICTIMECONTROL] = (d) => {
  return IfcElectricTimeControl.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICTIMECONTROLTYPE] = (d) => {
  return IfcElectricTimeControlType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENT] = (d) => {
  return IfcElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTASSEMBLY] = (d) => {
  return IfcElementAssembly.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTASSEMBLYTYPE] = (d) => {
  return IfcElementAssemblyType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTCOMPONENT] = (d) => {
  return IfcElementComponent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTCOMPONENTTYPE] = (d) => {
  return IfcElementComponentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTQUANTITY] = (d) => {
  return IfcElementQuantity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTTYPE] = (d) => {
  return IfcElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTARYSURFACE] = (d) => {
  return IfcElementarySurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELLIPSE] = (d) => {
  return IfcEllipse.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELLIPSEPROFILEDEF] = (d) => {
  return IfcEllipseProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCENERGYCONVERSIONDEVICE] = (d) => {
  return IfcEnergyConversionDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCENERGYCONVERSIONDEVICETYPE] = (d) => {
  return IfcEnergyConversionDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCENGINE] = (d) => {
  return IfcEngine.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCENGINETYPE] = (d) => {
  return IfcEngineType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVAPORATIVECOOLER] = (d) => {
  return IfcEvaporativeCooler.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVAPORATIVECOOLERTYPE] = (d) => {
  return IfcEvaporativeCoolerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVAPORATOR] = (d) => {
  return IfcEvaporator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVAPORATORTYPE] = (d) => {
  return IfcEvaporatorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVENT] = (d) => {
  return IfcEvent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVENTTIME] = (d) => {
  return IfcEventTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVENTTYPE] = (d) => {
  return IfcEventType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTENDEDPROPERTIES] = (d) => {
  return IfcExtendedProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALINFORMATION] = (d) => {
  return IfcExternalInformation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALREFERENCE] = (d) => {
  return IfcExternalReference.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALREFERENCERELATIONSHIP] = (d) => {
  return IfcExternalReferenceRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALSPATIALELEMENT] = (d) => {
  return IfcExternalSpatialElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALSPATIALSTRUCTUREELEMENT] = (d) => {
  return IfcExternalSpatialStructureElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALLYDEFINEDHATCHSTYLE] = (d) => {
  return IfcExternallyDefinedHatchStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALLYDEFINEDSURFACESTYLE] = (d) => {
  return IfcExternallyDefinedSurfaceStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALLYDEFINEDTEXTFONT] = (d) => {
  return IfcExternallyDefinedTextFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTRUDEDAREASOLID] = (d) => {
  return IfcExtrudedAreaSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTRUDEDAREASOLIDTAPERED] = (d) => {
  return IfcExtrudedAreaSolidTapered.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACE] = (d) => {
  return IfcFace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACEBASEDSURFACEMODEL] = (d) => {
  return IfcFaceBasedSurfaceModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACEBOUND] = (d) => {
  return IfcFaceBound.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACEOUTERBOUND] = (d) => {
  return IfcFaceOuterBound.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACESURFACE] = (d) => {
  return IfcFaceSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACETEDBREP] = (d) => {
  return IfcFacetedBrep.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACETEDBREPWITHVOIDS] = (d) => {
  return IfcFacetedBrepWithVoids.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACILITY] = (d) => {
  return IfcFacility.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACILITYPART] = (d) => {
  return IfcFacilityPart.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFAILURECONNECTIONCONDITION] = (d) => {
  return IfcFailureConnectionCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFAN] = (d) => {
  return IfcFan.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFANTYPE] = (d) => {
  return IfcFanType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFASTENER] = (d) => {
  return IfcFastener.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFASTENERTYPE] = (d) => {
  return IfcFastenerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFEATUREELEMENT] = (d) => {
  return IfcFeatureElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFEATUREELEMENTADDITION] = (d) => {
  return IfcFeatureElementAddition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFEATUREELEMENTSUBTRACTION] = (d) => {
  return IfcFeatureElementSubtraction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFILLAREASTYLE] = (d) => {
  return IfcFillAreaStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFILLAREASTYLEHATCHING] = (d) => {
  return IfcFillAreaStyleHatching.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFILLAREASTYLETILES] = (d) => {
  return IfcFillAreaStyleTiles.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFILTER] = (d) => {
  return IfcFilter.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFILTERTYPE] = (d) => {
  return IfcFilterType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFIRESUPPRESSIONTERMINAL] = (d) => {
  return IfcFireSuppressionTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFIRESUPPRESSIONTERMINALTYPE] = (d) => {
  return IfcFireSuppressionTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFIXEDREFERENCESWEPTAREASOLID] = (d) => {
  return IfcFixedReferenceSweptAreaSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWCONTROLLER] = (d) => {
  return IfcFlowController.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWCONTROLLERTYPE] = (d) => {
  return IfcFlowControllerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWFITTING] = (d) => {
  return IfcFlowFitting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWFITTINGTYPE] = (d) => {
  return IfcFlowFittingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWINSTRUMENT] = (d) => {
  return IfcFlowInstrument.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWINSTRUMENTTYPE] = (d) => {
  return IfcFlowInstrumentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWMETER] = (d) => {
  return IfcFlowMeter.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWMETERTYPE] = (d) => {
  return IfcFlowMeterType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWMOVINGDEVICE] = (d) => {
  return IfcFlowMovingDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWMOVINGDEVICETYPE] = (d) => {
  return IfcFlowMovingDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWSEGMENT] = (d) => {
  return IfcFlowSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWSEGMENTTYPE] = (d) => {
  return IfcFlowSegmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWSTORAGEDEVICE] = (d) => {
  return IfcFlowStorageDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWSTORAGEDEVICETYPE] = (d) => {
  return IfcFlowStorageDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWTERMINAL] = (d) => {
  return IfcFlowTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWTERMINALTYPE] = (d) => {
  return IfcFlowTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWTREATMENTDEVICE] = (d) => {
  return IfcFlowTreatmentDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWTREATMENTDEVICETYPE] = (d) => {
  return IfcFlowTreatmentDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFOOTING] = (d) => {
  return IfcFooting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFOOTINGTYPE] = (d) => {
  return IfcFootingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFURNISHINGELEMENT] = (d) => {
  return IfcFurnishingElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFURNISHINGELEMENTTYPE] = (d) => {
  return IfcFurnishingElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFURNITURE] = (d) => {
  return IfcFurniture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFURNITURETYPE] = (d) => {
  return IfcFurnitureType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOGRAPHICELEMENT] = (d) => {
  return IfcGeographicElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOGRAPHICELEMENTTYPE] = (d) => {
  return IfcGeographicElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOMETRICCURVESET] = (d) => {
  return IfcGeometricCurveSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOMETRICREPRESENTATIONCONTEXT] = (d) => {
  return IfcGeometricRepresentationContext.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOMETRICREPRESENTATIONITEM] = (d) => {
  return IfcGeometricRepresentationItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOMETRICREPRESENTATIONSUBCONTEXT] = (d) => {
  return IfcGeometricRepresentationSubContext.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOMETRICSET] = (d) => {
  return IfcGeometricSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGRID] = (d) => {
  return IfcGrid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGRIDAXIS] = (d) => {
  return IfcGridAxis.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGRIDPLACEMENT] = (d) => {
  return IfcGridPlacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGROUP] = (d) => {
  return IfcGroup.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCHALFSPACESOLID] = (d) => {
  return IfcHalfSpaceSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCHEATEXCHANGER] = (d) => {
  return IfcHeatExchanger.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCHEATEXCHANGERTYPE] = (d) => {
  return IfcHeatExchangerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCHUMIDIFIER] = (d) => {
  return IfcHumidifier.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCHUMIDIFIERTYPE] = (d) => {
  return IfcHumidifierType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCISHAPEPROFILEDEF] = (d) => {
  return IfcIShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCIMAGETEXTURE] = (d) => {
  return IfcImageTexture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDCOLOURMAP] = (d) => {
  return IfcIndexedColourMap.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDPOLYCURVE] = (d) => {
  return IfcIndexedPolyCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDPOLYGONALFACE] = (d) => {
  return IfcIndexedPolygonalFace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDPOLYGONALFACEWITHVOIDS] = (d) => {
  return IfcIndexedPolygonalFaceWithVoids.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDTEXTUREMAP] = (d) => {
  return IfcIndexedTextureMap.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDTRIANGLETEXTUREMAP] = (d) => {
  return IfcIndexedTriangleTextureMap.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINTERCEPTOR] = (d) => {
  return IfcInterceptor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINTERCEPTORTYPE] = (d) => {
  return IfcInterceptorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINTERSECTIONCURVE] = (d) => {
  return IfcIntersectionCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINVENTORY] = (d) => {
  return IfcInventory.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCIRREGULARTIMESERIES] = (d) => {
  return IfcIrregularTimeSeries.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCIRREGULARTIMESERIESVALUE] = (d) => {
  return IfcIrregularTimeSeriesValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCJUNCTIONBOX] = (d) => {
  return IfcJunctionBox.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCJUNCTIONBOXTYPE] = (d) => {
  return IfcJunctionBoxType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLSHAPEPROFILEDEF] = (d) => {
  return IfcLShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLABORRESOURCE] = (d) => {
  return IfcLaborResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLABORRESOURCETYPE] = (d) => {
  return IfcLaborResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLAGTIME] = (d) => {
  return IfcLagTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLAMP] = (d) => {
  return IfcLamp.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLAMPTYPE] = (d) => {
  return IfcLampType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIBRARYINFORMATION] = (d) => {
  return IfcLibraryInformation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIBRARYREFERENCE] = (d) => {
  return IfcLibraryReference.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTDISTRIBUTIONDATA] = (d) => {
  return IfcLightDistributionData.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTFIXTURE] = (d) => {
  return IfcLightFixture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTFIXTURETYPE] = (d) => {
  return IfcLightFixtureType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTINTENSITYDISTRIBUTION] = (d) => {
  return IfcLightIntensityDistribution.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCE] = (d) => {
  return IfcLightSource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCEAMBIENT] = (d) => {
  return IfcLightSourceAmbient.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCEDIRECTIONAL] = (d) => {
  return IfcLightSourceDirectional.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCEGONIOMETRIC] = (d) => {
  return IfcLightSourceGoniometric.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCEPOSITIONAL] = (d) => {
  return IfcLightSourcePositional.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCESPOT] = (d) => {
  return IfcLightSourceSpot.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLINE] = (d) => {
  return IfcLine.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLINESEGMENT2D] = (d) => {
  return IfcLineSegment2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLINEARPLACEMENT] = (d) => {
  return IfcLinearPlacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLINEARPOSITIONINGELEMENT] = (d) => {
  return IfcLinearPositioningElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLOCALPLACEMENT] = (d) => {
  return IfcLocalPlacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLOOP] = (d) => {
  return IfcLoop.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMANIFOLDSOLIDBREP] = (d) => {
  return IfcManifoldSolidBrep.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMAPCONVERSION] = (d) => {
  return IfcMapConversion.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMAPPEDITEM] = (d) => {
  return IfcMappedItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIAL] = (d) => {
  return IfcMaterial.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALCLASSIFICATIONRELATIONSHIP] = (d) => {
  return IfcMaterialClassificationRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALCONSTITUENT] = (d) => {
  return IfcMaterialConstituent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALCONSTITUENTSET] = (d) => {
  return IfcMaterialConstituentSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALDEFINITION] = (d) => {
  return IfcMaterialDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALDEFINITIONREPRESENTATION] = (d) => {
  return IfcMaterialDefinitionRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALLAYER] = (d) => {
  return IfcMaterialLayer.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALLAYERSET] = (d) => {
  return IfcMaterialLayerSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALLAYERSETUSAGE] = (d) => {
  return IfcMaterialLayerSetUsage.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALLAYERWITHOFFSETS] = (d) => {
  return IfcMaterialLayerWithOffsets.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALLIST] = (d) => {
  return IfcMaterialList.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROFILE] = (d) => {
  return IfcMaterialProfile.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROFILESET] = (d) => {
  return IfcMaterialProfileSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROFILESETUSAGE] = (d) => {
  return IfcMaterialProfileSetUsage.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROFILESETUSAGETAPERING] = (d) => {
  return IfcMaterialProfileSetUsageTapering.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROFILEWITHOFFSETS] = (d) => {
  return IfcMaterialProfileWithOffsets.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROPERTIES] = (d) => {
  return IfcMaterialProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALRELATIONSHIP] = (d) => {
  return IfcMaterialRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALUSAGEDEFINITION] = (d) => {
  return IfcMaterialUsageDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEASUREWITHUNIT] = (d) => {
  return IfcMeasureWithUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMECHANICALFASTENER] = (d) => {
  return IfcMechanicalFastener.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMECHANICALFASTENERTYPE] = (d) => {
  return IfcMechanicalFastenerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEDICALDEVICE] = (d) => {
  return IfcMedicalDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEDICALDEVICETYPE] = (d) => {
  return IfcMedicalDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEMBER] = (d) => {
  return IfcMember.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEMBERSTANDARDCASE] = (d) => {
  return IfcMemberStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEMBERTYPE] = (d) => {
  return IfcMemberType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMETRIC] = (d) => {
  return IfcMetric.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMIRROREDPROFILEDEF] = (d) => {
  return IfcMirroredProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMONETARYUNIT] = (d) => {
  return IfcMonetaryUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMOTORCONNECTION] = (d) => {
  return IfcMotorConnection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMOTORCONNECTIONTYPE] = (d) => {
  return IfcMotorConnectionType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCNAMEDUNIT] = (d) => {
  return IfcNamedUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOBJECT] = (d) => {
  return IfcObject.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOBJECTDEFINITION] = (d) => {
  return IfcObjectDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOBJECTPLACEMENT] = (d) => {
  return IfcObjectPlacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOBJECTIVE] = (d) => {
  return IfcObjective.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOCCUPANT] = (d) => {
  return IfcOccupant.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOFFSETCURVE] = (d) => {
  return IfcOffsetCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOFFSETCURVE2D] = (d) => {
  return IfcOffsetCurve2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOFFSETCURVE3D] = (d) => {
  return IfcOffsetCurve3D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOFFSETCURVEBYDISTANCES] = (d) => {
  return IfcOffsetCurveByDistances.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOPENSHELL] = (d) => {
  return IfcOpenShell.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOPENINGELEMENT] = (d) => {
  return IfcOpeningElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOPENINGSTANDARDCASE] = (d) => {
  return IfcOpeningStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCORGANIZATION] = (d) => {
  return IfcOrganization.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCORGANIZATIONRELATIONSHIP] = (d) => {
  return IfcOrganizationRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCORIENTATIONEXPRESSION] = (d) => {
  return IfcOrientationExpression.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCORIENTEDEDGE] = (d) => {
  return IfcOrientedEdge.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOUTERBOUNDARYCURVE] = (d) => {
  return IfcOuterBoundaryCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOUTLET] = (d) => {
  return IfcOutlet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOUTLETTYPE] = (d) => {
  return IfcOutletType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOWNERHISTORY] = (d) => {
  return IfcOwnerHistory.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPARAMETERIZEDPROFILEDEF] = (d) => {
  return IfcParameterizedProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPATH] = (d) => {
  return IfcPath.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPCURVE] = (d) => {
  return IfcPcurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPERFORMANCEHISTORY] = (d) => {
  return IfcPerformanceHistory.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPERMEABLECOVERINGPROPERTIES] = (d) => {
  return IfcPermeableCoveringProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPERMIT] = (d) => {
  return IfcPermit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPERSON] = (d) => {
  return IfcPerson.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPERSONANDORGANIZATION] = (d) => {
  return IfcPersonAndOrganization.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPHYSICALCOMPLEXQUANTITY] = (d) => {
  return IfcPhysicalComplexQuantity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPHYSICALQUANTITY] = (d) => {
  return IfcPhysicalQuantity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPHYSICALSIMPLEQUANTITY] = (d) => {
  return IfcPhysicalSimpleQuantity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPILE] = (d) => {
  return IfcPile.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPILETYPE] = (d) => {
  return IfcPileType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPIPEFITTING] = (d) => {
  return IfcPipeFitting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPIPEFITTINGTYPE] = (d) => {
  return IfcPipeFittingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPIPESEGMENT] = (d) => {
  return IfcPipeSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPIPESEGMENTTYPE] = (d) => {
  return IfcPipeSegmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPIXELTEXTURE] = (d) => {
  return IfcPixelTexture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLACEMENT] = (d) => {
  return IfcPlacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLANARBOX] = (d) => {
  return IfcPlanarBox.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLANAREXTENT] = (d) => {
  return IfcPlanarExtent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLANE] = (d) => {
  return IfcPlane.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLATE] = (d) => {
  return IfcPlate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLATESTANDARDCASE] = (d) => {
  return IfcPlateStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLATETYPE] = (d) => {
  return IfcPlateType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOINT] = (d) => {
  return IfcPoint.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOINTONCURVE] = (d) => {
  return IfcPointOnCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOINTONSURFACE] = (d) => {
  return IfcPointOnSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOLYLOOP] = (d) => {
  return IfcPolyLoop.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOLYGONALBOUNDEDHALFSPACE] = (d) => {
  return IfcPolygonalBoundedHalfSpace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOLYGONALFACESET] = (d) => {
  return IfcPolygonalFaceSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOLYLINE] = (d) => {
  return IfcPolyline.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPORT] = (d) => {
  return IfcPort.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOSITIONINGELEMENT] = (d) => {
  return IfcPositioningElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOSTALADDRESS] = (d) => {
  return IfcPostalAddress.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDCOLOUR] = (d) => {
  return IfcPreDefinedColour.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDCURVEFONT] = (d) => {
  return IfcPreDefinedCurveFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDITEM] = (d) => {
  return IfcPreDefinedItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDPROPERTIES] = (d) => {
  return IfcPreDefinedProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDPROPERTYSET] = (d) => {
  return IfcPreDefinedPropertySet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDTEXTFONT] = (d) => {
  return IfcPreDefinedTextFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRESENTATIONITEM] = (d) => {
  return IfcPresentationItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRESENTATIONLAYERASSIGNMENT] = (d) => {
  return IfcPresentationLayerAssignment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRESENTATIONLAYERWITHSTYLE] = (d) => {
  return IfcPresentationLayerWithStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRESENTATIONSTYLE] = (d) => {
  return IfcPresentationStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRESENTATIONSTYLEASSIGNMENT] = (d) => {
  return IfcPresentationStyleAssignment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROCEDURE] = (d) => {
  return IfcProcedure.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROCEDURETYPE] = (d) => {
  return IfcProcedureType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROCESS] = (d) => {
  return IfcProcess.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRODUCT] = (d) => {
  return IfcProduct.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRODUCTDEFINITIONSHAPE] = (d) => {
  return IfcProductDefinitionShape.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRODUCTREPRESENTATION] = (d) => {
  return IfcProductRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROFILEDEF] = (d) => {
  return IfcProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROFILEPROPERTIES] = (d) => {
  return IfcProfileProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROJECT] = (d) => {
  return IfcProject.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROJECTLIBRARY] = (d) => {
  return IfcProjectLibrary.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROJECTORDER] = (d) => {
  return IfcProjectOrder.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROJECTEDCRS] = (d) => {
  return IfcProjectedCRS.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROJECTIONELEMENT] = (d) => {
  return IfcProjectionElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTY] = (d) => {
  return IfcProperty.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYABSTRACTION] = (d) => {
  return IfcPropertyAbstraction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYBOUNDEDVALUE] = (d) => {
  return IfcPropertyBoundedValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYDEFINITION] = (d) => {
  return IfcPropertyDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYDEPENDENCYRELATIONSHIP] = (d) => {
  return IfcPropertyDependencyRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYENUMERATEDVALUE] = (d) => {
  return IfcPropertyEnumeratedValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYENUMERATION] = (d) => {
  return IfcPropertyEnumeration.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYLISTVALUE] = (d) => {
  return IfcPropertyListValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYREFERENCEVALUE] = (d) => {
  return IfcPropertyReferenceValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYSET] = (d) => {
  return IfcPropertySet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYSETDEFINITION] = (d) => {
  return IfcPropertySetDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYSETTEMPLATE] = (d) => {
  return IfcPropertySetTemplate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYSINGLEVALUE] = (d) => {
  return IfcPropertySingleValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYTABLEVALUE] = (d) => {
  return IfcPropertyTableValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYTEMPLATE] = (d) => {
  return IfcPropertyTemplate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYTEMPLATEDEFINITION] = (d) => {
  return IfcPropertyTemplateDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROTECTIVEDEVICE] = (d) => {
  return IfcProtectiveDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROTECTIVEDEVICETRIPPINGUNIT] = (d) => {
  return IfcProtectiveDeviceTrippingUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROTECTIVEDEVICETRIPPINGUNITTYPE] = (d) => {
  return IfcProtectiveDeviceTrippingUnitType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROTECTIVEDEVICETYPE] = (d) => {
  return IfcProtectiveDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROXY] = (d) => {
  return IfcProxy.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPUMP] = (d) => {
  return IfcPump.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPUMPTYPE] = (d) => {
  return IfcPumpType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYAREA] = (d) => {
  return IfcQuantityArea.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYCOUNT] = (d) => {
  return IfcQuantityCount.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYLENGTH] = (d) => {
  return IfcQuantityLength.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYSET] = (d) => {
  return IfcQuantitySet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYTIME] = (d) => {
  return IfcQuantityTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYVOLUME] = (d) => {
  return IfcQuantityVolume.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYWEIGHT] = (d) => {
  return IfcQuantityWeight.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAILING] = (d) => {
  return IfcRailing.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAILINGTYPE] = (d) => {
  return IfcRailingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAMP] = (d) => {
  return IfcRamp.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAMPFLIGHT] = (d) => {
  return IfcRampFlight.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAMPFLIGHTTYPE] = (d) => {
  return IfcRampFlightType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAMPTYPE] = (d) => {
  return IfcRampType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRATIONALBSPLINECURVEWITHKNOTS] = (d) => {
  return IfcRationalBSplineCurveWithKnots.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRATIONALBSPLINESURFACEWITHKNOTS] = (d) => {
  return IfcRationalBSplineSurfaceWithKnots.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRECTANGLEHOLLOWPROFILEDEF] = (d) => {
  return IfcRectangleHollowProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRECTANGLEPROFILEDEF] = (d) => {
  return IfcRectangleProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRECTANGULARPYRAMID] = (d) => {
  return IfcRectangularPyramid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRECTANGULARTRIMMEDSURFACE] = (d) => {
  return IfcRectangularTrimmedSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRECURRENCEPATTERN] = (d) => {
  return IfcRecurrencePattern.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREFERENCE] = (d) => {
  return IfcReference.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREFERENT] = (d) => {
  return IfcReferent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREGULARTIMESERIES] = (d) => {
  return IfcRegularTimeSeries.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCEMENTBARPROPERTIES] = (d) => {
  return IfcReinforcementBarProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCEMENTDEFINITIONPROPERTIES] = (d) => {
  return IfcReinforcementDefinitionProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGBAR] = (d) => {
  return IfcReinforcingBar.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGBARTYPE] = (d) => {
  return IfcReinforcingBarType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGELEMENT] = (d) => {
  return IfcReinforcingElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGELEMENTTYPE] = (d) => {
  return IfcReinforcingElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGMESH] = (d) => {
  return IfcReinforcingMesh.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGMESHTYPE] = (d) => {
  return IfcReinforcingMeshType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELAGGREGATES] = (d) => {
  return IfcRelAggregates.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNS] = (d) => {
  return IfcRelAssigns.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOACTOR] = (d) => {
  return IfcRelAssignsToActor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOCONTROL] = (d) => {
  return IfcRelAssignsToControl.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOGROUP] = (d) => {
  return IfcRelAssignsToGroup.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOGROUPBYFACTOR] = (d) => {
  return IfcRelAssignsToGroupByFactor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOPROCESS] = (d) => {
  return IfcRelAssignsToProcess.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOPRODUCT] = (d) => {
  return IfcRelAssignsToProduct.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTORESOURCE] = (d) => {
  return IfcRelAssignsToResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATES] = (d) => {
  return IfcRelAssociates.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESAPPROVAL] = (d) => {
  return IfcRelAssociatesApproval.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESCLASSIFICATION] = (d) => {
  return IfcRelAssociatesClassification.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESCONSTRAINT] = (d) => {
  return IfcRelAssociatesConstraint.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESDOCUMENT] = (d) => {
  return IfcRelAssociatesDocument.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESLIBRARY] = (d) => {
  return IfcRelAssociatesLibrary.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESMATERIAL] = (d) => {
  return IfcRelAssociatesMaterial.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTS] = (d) => {
  return IfcRelConnects.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSELEMENTS] = (d) => {
  return IfcRelConnectsElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSPATHELEMENTS] = (d) => {
  return IfcRelConnectsPathElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSPORTTOELEMENT] = (d) => {
  return IfcRelConnectsPortToElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSPORTS] = (d) => {
  return IfcRelConnectsPorts.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSSTRUCTURALACTIVITY] = (d) => {
  return IfcRelConnectsStructuralActivity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSSTRUCTURALMEMBER] = (d) => {
  return IfcRelConnectsStructuralMember.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSWITHECCENTRICITY] = (d) => {
  return IfcRelConnectsWithEccentricity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSWITHREALIZINGELEMENTS] = (d) => {
  return IfcRelConnectsWithRealizingElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONTAINEDINSPATIALSTRUCTURE] = (d) => {
  return IfcRelContainedInSpatialStructure.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCOVERSBLDGELEMENTS] = (d) => {
  return IfcRelCoversBldgElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCOVERSSPACES] = (d) => {
  return IfcRelCoversSpaces.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDECLARES] = (d) => {
  return IfcRelDeclares.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDECOMPOSES] = (d) => {
  return IfcRelDecomposes.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDEFINES] = (d) => {
  return IfcRelDefines.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDEFINESBYOBJECT] = (d) => {
  return IfcRelDefinesByObject.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDEFINESBYPROPERTIES] = (d) => {
  return IfcRelDefinesByProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDEFINESBYTEMPLATE] = (d) => {
  return IfcRelDefinesByTemplate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDEFINESBYTYPE] = (d) => {
  return IfcRelDefinesByType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELFILLSELEMENT] = (d) => {
  return IfcRelFillsElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELFLOWCONTROLELEMENTS] = (d) => {
  return IfcRelFlowControlElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELINTERFERESELEMENTS] = (d) => {
  return IfcRelInterferesElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELNESTS] = (d) => {
  return IfcRelNests.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELPOSITIONS] = (d) => {
  return IfcRelPositions.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELPROJECTSELEMENT] = (d) => {
  return IfcRelProjectsElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELREFERENCEDINSPATIALSTRUCTURE] = (d) => {
  return IfcRelReferencedInSpatialStructure.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELSEQUENCE] = (d) => {
  return IfcRelSequence.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELSERVICESBUILDINGS] = (d) => {
  return IfcRelServicesBuildings.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELSPACEBOUNDARY] = (d) => {
  return IfcRelSpaceBoundary.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELSPACEBOUNDARY1STLEVEL] = (d) => {
  return IfcRelSpaceBoundary1stLevel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELSPACEBOUNDARY2NDLEVEL] = (d) => {
  return IfcRelSpaceBoundary2ndLevel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELVOIDSELEMENT] = (d) => {
  return IfcRelVoidsElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELATIONSHIP] = (d) => {
  return IfcRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREPARAMETRISEDCOMPOSITECURVESEGMENT] = (d) => {
  return IfcReparametrisedCompositeCurveSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREPRESENTATION] = (d) => {
  return IfcRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREPRESENTATIONCONTEXT] = (d) => {
  return IfcRepresentationContext.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREPRESENTATIONITEM] = (d) => {
  return IfcRepresentationItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREPRESENTATIONMAP] = (d) => {
  return IfcRepresentationMap.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRESOURCE] = (d) => {
  return IfcResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRESOURCEAPPROVALRELATIONSHIP] = (d) => {
  return IfcResourceApprovalRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRESOURCECONSTRAINTRELATIONSHIP] = (d) => {
  return IfcResourceConstraintRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRESOURCELEVELRELATIONSHIP] = (d) => {
  return IfcResourceLevelRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRESOURCETIME] = (d) => {
  return IfcResourceTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREVOLVEDAREASOLID] = (d) => {
  return IfcRevolvedAreaSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREVOLVEDAREASOLIDTAPERED] = (d) => {
  return IfcRevolvedAreaSolidTapered.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRIGHTCIRCULARCONE] = (d) => {
  return IfcRightCircularCone.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRIGHTCIRCULARCYLINDER] = (d) => {
  return IfcRightCircularCylinder.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCROOF] = (d) => {
  return IfcRoof.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCROOFTYPE] = (d) => {
  return IfcRoofType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCROOT] = (d) => {
  return IfcRoot.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCROUNDEDRECTANGLEPROFILEDEF] = (d) => {
  return IfcRoundedRectangleProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSIUNIT] = (d) => {
  return IfcSIUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSANITARYTERMINAL] = (d) => {
  return IfcSanitaryTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSANITARYTERMINALTYPE] = (d) => {
  return IfcSanitaryTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSCHEDULINGTIME] = (d) => {
  return IfcSchedulingTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSEAMCURVE] = (d) => {
  return IfcSeamCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSECTIONPROPERTIES] = (d) => {
  return IfcSectionProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSECTIONREINFORCEMENTPROPERTIES] = (d) => {
  return IfcSectionReinforcementProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSECTIONEDSOLID] = (d) => {
  return IfcSectionedSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSECTIONEDSOLIDHORIZONTAL] = (d) => {
  return IfcSectionedSolidHorizontal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSECTIONEDSPINE] = (d) => {
  return IfcSectionedSpine.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSENSOR] = (d) => {
  return IfcSensor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSENSORTYPE] = (d) => {
  return IfcSensorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHADINGDEVICE] = (d) => {
  return IfcShadingDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHADINGDEVICETYPE] = (d) => {
  return IfcShadingDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHAPEASPECT] = (d) => {
  return IfcShapeAspect.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHAPEMODEL] = (d) => {
  return IfcShapeModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHAPEREPRESENTATION] = (d) => {
  return IfcShapeRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHELLBASEDSURFACEMODEL] = (d) => {
  return IfcShellBasedSurfaceModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSIMPLEPROPERTY] = (d) => {
  return IfcSimpleProperty.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSIMPLEPROPERTYTEMPLATE] = (d) => {
  return IfcSimplePropertyTemplate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSITE] = (d) => {
  return IfcSite.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSLAB] = (d) => {
  return IfcSlab.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSLABELEMENTEDCASE] = (d) => {
  return IfcSlabElementedCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSLABSTANDARDCASE] = (d) => {
  return IfcSlabStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSLABTYPE] = (d) => {
  return IfcSlabType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSLIPPAGECONNECTIONCONDITION] = (d) => {
  return IfcSlippageConnectionCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSOLARDEVICE] = (d) => {
  return IfcSolarDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSOLARDEVICETYPE] = (d) => {
  return IfcSolarDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSOLIDMODEL] = (d) => {
  return IfcSolidModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPACE] = (d) => {
  return IfcSpace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPACEHEATER] = (d) => {
  return IfcSpaceHeater.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPACEHEATERTYPE] = (d) => {
  return IfcSpaceHeaterType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPACETYPE] = (d) => {
  return IfcSpaceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALELEMENT] = (d) => {
  return IfcSpatialElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALELEMENTTYPE] = (d) => {
  return IfcSpatialElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALSTRUCTUREELEMENT] = (d) => {
  return IfcSpatialStructureElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALSTRUCTUREELEMENTTYPE] = (d) => {
  return IfcSpatialStructureElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALZONE] = (d) => {
  return IfcSpatialZone.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALZONETYPE] = (d) => {
  return IfcSpatialZoneType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPHERE] = (d) => {
  return IfcSphere.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPHERICALSURFACE] = (d) => {
  return IfcSphericalSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTACKTERMINAL] = (d) => {
  return IfcStackTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTACKTERMINALTYPE] = (d) => {
  return IfcStackTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTAIR] = (d) => {
  return IfcStair.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTAIRFLIGHT] = (d) => {
  return IfcStairFlight.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTAIRFLIGHTTYPE] = (d) => {
  return IfcStairFlightType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTAIRTYPE] = (d) => {
  return IfcStairType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALACTION] = (d) => {
  return IfcStructuralAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALACTIVITY] = (d) => {
  return IfcStructuralActivity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALANALYSISMODEL] = (d) => {
  return IfcStructuralAnalysisModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCONNECTION] = (d) => {
  return IfcStructuralConnection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCONNECTIONCONDITION] = (d) => {
  return IfcStructuralConnectionCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCURVEACTION] = (d) => {
  return IfcStructuralCurveAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCURVECONNECTION] = (d) => {
  return IfcStructuralCurveConnection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCURVEMEMBER] = (d) => {
  return IfcStructuralCurveMember.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCURVEMEMBERVARYING] = (d) => {
  return IfcStructuralCurveMemberVarying.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCURVEREACTION] = (d) => {
  return IfcStructuralCurveReaction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALITEM] = (d) => {
  return IfcStructuralItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLINEARACTION] = (d) => {
  return IfcStructuralLinearAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOAD] = (d) => {
  return IfcStructuralLoad.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADCASE] = (d) => {
  return IfcStructuralLoadCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADCONFIGURATION] = (d) => {
  return IfcStructuralLoadConfiguration.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADGROUP] = (d) => {
  return IfcStructuralLoadGroup.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADLINEARFORCE] = (d) => {
  return IfcStructuralLoadLinearForce.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADORRESULT] = (d) => {
  return IfcStructuralLoadOrResult.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADPLANARFORCE] = (d) => {
  return IfcStructuralLoadPlanarForce.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADSINGLEDISPLACEMENT] = (d) => {
  return IfcStructuralLoadSingleDisplacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION] = (d) => {
  return IfcStructuralLoadSingleDisplacementDistortion.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADSINGLEFORCE] = (d) => {
  return IfcStructuralLoadSingleForce.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADSINGLEFORCEWARPING] = (d) => {
  return IfcStructuralLoadSingleForceWarping.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADSTATIC] = (d) => {
  return IfcStructuralLoadStatic.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADTEMPERATURE] = (d) => {
  return IfcStructuralLoadTemperature.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALMEMBER] = (d) => {
  return IfcStructuralMember.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALPLANARACTION] = (d) => {
  return IfcStructuralPlanarAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALPOINTACTION] = (d) => {
  return IfcStructuralPointAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALPOINTCONNECTION] = (d) => {
  return IfcStructuralPointConnection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALPOINTREACTION] = (d) => {
  return IfcStructuralPointReaction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALREACTION] = (d) => {
  return IfcStructuralReaction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALRESULTGROUP] = (d) => {
  return IfcStructuralResultGroup.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALSURFACEACTION] = (d) => {
  return IfcStructuralSurfaceAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALSURFACECONNECTION] = (d) => {
  return IfcStructuralSurfaceConnection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALSURFACEMEMBER] = (d) => {
  return IfcStructuralSurfaceMember.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALSURFACEMEMBERVARYING] = (d) => {
  return IfcStructuralSurfaceMemberVarying.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALSURFACEREACTION] = (d) => {
  return IfcStructuralSurfaceReaction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTYLEMODEL] = (d) => {
  return IfcStyleModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTYLEDITEM] = (d) => {
  return IfcStyledItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTYLEDREPRESENTATION] = (d) => {
  return IfcStyledRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSUBCONTRACTRESOURCE] = (d) => {
  return IfcSubContractResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSUBCONTRACTRESOURCETYPE] = (d) => {
  return IfcSubContractResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSUBEDGE] = (d) => {
  return IfcSubedge.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACE] = (d) => {
  return IfcSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACECURVE] = (d) => {
  return IfcSurfaceCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACECURVESWEPTAREASOLID] = (d) => {
  return IfcSurfaceCurveSweptAreaSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACEFEATURE] = (d) => {
  return IfcSurfaceFeature.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACEOFLINEAREXTRUSION] = (d) => {
  return IfcSurfaceOfLinearExtrusion.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACEOFREVOLUTION] = (d) => {
  return IfcSurfaceOfRevolution.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACEREINFORCEMENTAREA] = (d) => {
  return IfcSurfaceReinforcementArea.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLE] = (d) => {
  return IfcSurfaceStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLELIGHTING] = (d) => {
  return IfcSurfaceStyleLighting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLEREFRACTION] = (d) => {
  return IfcSurfaceStyleRefraction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLERENDERING] = (d) => {
  return IfcSurfaceStyleRendering.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLESHADING] = (d) => {
  return IfcSurfaceStyleShading.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLEWITHTEXTURES] = (d) => {
  return IfcSurfaceStyleWithTextures.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACETEXTURE] = (d) => {
  return IfcSurfaceTexture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWEPTAREASOLID] = (d) => {
  return IfcSweptAreaSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWEPTDISKSOLID] = (d) => {
  return IfcSweptDiskSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWEPTDISKSOLIDPOLYGONAL] = (d) => {
  return IfcSweptDiskSolidPolygonal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWEPTSURFACE] = (d) => {
  return IfcSweptSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWITCHINGDEVICE] = (d) => {
  return IfcSwitchingDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWITCHINGDEVICETYPE] = (d) => {
  return IfcSwitchingDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSYSTEM] = (d) => {
  return IfcSystem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSYSTEMFURNITUREELEMENT] = (d) => {
  return IfcSystemFurnitureElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSYSTEMFURNITUREELEMENTTYPE] = (d) => {
  return IfcSystemFurnitureElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTSHAPEPROFILEDEF] = (d) => {
  return IfcTShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTABLE] = (d) => {
  return IfcTable.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTABLECOLUMN] = (d) => {
  return IfcTableColumn.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTABLEROW] = (d) => {
  return IfcTableRow.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTANK] = (d) => {
  return IfcTank.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTANKTYPE] = (d) => {
  return IfcTankType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTASK] = (d) => {
  return IfcTask.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTASKTIME] = (d) => {
  return IfcTaskTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTASKTIMERECURRING] = (d) => {
  return IfcTaskTimeRecurring.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTASKTYPE] = (d) => {
  return IfcTaskType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTELECOMADDRESS] = (d) => {
  return IfcTelecomAddress.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDON] = (d) => {
  return IfcTendon.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDONANCHOR] = (d) => {
  return IfcTendonAnchor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDONANCHORTYPE] = (d) => {
  return IfcTendonAnchorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDONCONDUIT] = (d) => {
  return IfcTendonConduit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDONCONDUITTYPE] = (d) => {
  return IfcTendonConduitType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDONTYPE] = (d) => {
  return IfcTendonType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTESSELLATEDFACESET] = (d) => {
  return IfcTessellatedFaceSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTESSELLATEDITEM] = (d) => {
  return IfcTessellatedItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTLITERAL] = (d) => {
  return IfcTextLiteral.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTLITERALWITHEXTENT] = (d) => {
  return IfcTextLiteralWithExtent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTSTYLE] = (d) => {
  return IfcTextStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTSTYLEFONTMODEL] = (d) => {
  return IfcTextStyleFontModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTSTYLEFORDEFINEDFONT] = (d) => {
  return IfcTextStyleForDefinedFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTSTYLETEXTMODEL] = (d) => {
  return IfcTextStyleTextModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTURECOORDINATE] = (d) => {
  return IfcTextureCoordinate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTURECOORDINATEGENERATOR] = (d) => {
  return IfcTextureCoordinateGenerator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTUREMAP] = (d) => {
  return IfcTextureMap.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTUREVERTEX] = (d) => {
  return IfcTextureVertex.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTUREVERTEXLIST] = (d) => {
  return IfcTextureVertexList.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTIMEPERIOD] = (d) => {
  return IfcTimePeriod.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTIMESERIES] = (d) => {
  return IfcTimeSeries.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTIMESERIESVALUE] = (d) => {
  return IfcTimeSeriesValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTOPOLOGICALREPRESENTATIONITEM] = (d) => {
  return IfcTopologicalRepresentationItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTOPOLOGYREPRESENTATION] = (d) => {
  return IfcTopologyRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTOROIDALSURFACE] = (d) => {
  return IfcToroidalSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRANSFORMER] = (d) => {
  return IfcTransformer.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRANSFORMERTYPE] = (d) => {
  return IfcTransformerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRANSITIONCURVESEGMENT2D] = (d) => {
  return IfcTransitionCurveSegment2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRANSPORTELEMENT] = (d) => {
  return IfcTransportElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRANSPORTELEMENTTYPE] = (d) => {
  return IfcTransportElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRAPEZIUMPROFILEDEF] = (d) => {
  return IfcTrapeziumProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRIANGULATEDFACESET] = (d) => {
  return IfcTriangulatedFaceSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRIANGULATEDIRREGULARNETWORK] = (d) => {
  return IfcTriangulatedIrregularNetwork.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRIMMEDCURVE] = (d) => {
  return IfcTrimmedCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTUBEBUNDLE] = (d) => {
  return IfcTubeBundle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTUBEBUNDLETYPE] = (d) => {
  return IfcTubeBundleType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTYPEOBJECT] = (d) => {
  return IfcTypeObject.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTYPEPROCESS] = (d) => {
  return IfcTypeProcess.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTYPEPRODUCT] = (d) => {
  return IfcTypeProduct.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTYPERESOURCE] = (d) => {
  return IfcTypeResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUSHAPEPROFILEDEF] = (d) => {
  return IfcUShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUNITASSIGNMENT] = (d) => {
  return IfcUnitAssignment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUNITARYCONTROLELEMENT] = (d) => {
  return IfcUnitaryControlElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUNITARYCONTROLELEMENTTYPE] = (d) => {
  return IfcUnitaryControlElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUNITARYEQUIPMENT] = (d) => {
  return IfcUnitaryEquipment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUNITARYEQUIPMENTTYPE] = (d) => {
  return IfcUnitaryEquipmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVALVE] = (d) => {
  return IfcValve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVALVETYPE] = (d) => {
  return IfcValveType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVECTOR] = (d) => {
  return IfcVector.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVERTEX] = (d) => {
  return IfcVertex.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVERTEXLOOP] = (d) => {
  return IfcVertexLoop.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVERTEXPOINT] = (d) => {
  return IfcVertexPoint.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIBRATIONDAMPER] = (d) => {
  return IfcVibrationDamper.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIBRATIONDAMPERTYPE] = (d) => {
  return IfcVibrationDamperType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIBRATIONISOLATOR] = (d) => {
  return IfcVibrationIsolator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIBRATIONISOLATORTYPE] = (d) => {
  return IfcVibrationIsolatorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIRTUALELEMENT] = (d) => {
  return IfcVirtualElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIRTUALGRIDINTERSECTION] = (d) => {
  return IfcVirtualGridIntersection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVOIDINGFEATURE] = (d) => {
  return IfcVoidingFeature.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWALL] = (d) => {
  return IfcWall.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWALLELEMENTEDCASE] = (d) => {
  return IfcWallElementedCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWALLSTANDARDCASE] = (d) => {
  return IfcWallStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWALLTYPE] = (d) => {
  return IfcWallType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWASTETERMINAL] = (d) => {
  return IfcWasteTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWASTETERMINALTYPE] = (d) => {
  return IfcWasteTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOW] = (d) => {
  return IfcWindow.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOWLININGPROPERTIES] = (d) => {
  return IfcWindowLiningProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOWPANELPROPERTIES] = (d) => {
  return IfcWindowPanelProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOWSTANDARDCASE] = (d) => {
  return IfcWindowStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOWSTYLE] = (d) => {
  return IfcWindowStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOWTYPE] = (d) => {
  return IfcWindowType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWORKCALENDAR] = (d) => {
  return IfcWorkCalendar.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWORKCONTROL] = (d) => {
  return IfcWorkControl.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWORKPLAN] = (d) => {
  return IfcWorkPlan.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWORKSCHEDULE] = (d) => {
  return IfcWorkSchedule.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWORKTIME] = (d) => {
  return IfcWorkTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCZSHAPEPROFILEDEF] = (d) => {
  return IfcZShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCZONE] = (d) => {
  return IfcZone.FromTape(d.ID, d.type, d.arguments);
};
var IfcActionRequest = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.PredefinedType = PredefinedType;
    this.Status = Status;
    this.LongDescription = LongDescription;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Status = tape[ptr++];
    let LongDescription = tape[ptr++];
    return new IfcActionRequest(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.PredefinedType);
    args.push(this.Status);
    args.push(this.LongDescription);
    return args;
  }
};
var IfcActor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.TheActor = TheActor;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let TheActor = tape[ptr++];
    return new IfcActor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.TheActor);
    return args;
  }
};
var IfcActorRole = class {
  constructor(expressID, type, Role, UserDefinedRole, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Role = Role;
    this.UserDefinedRole = UserDefinedRole;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Role = tape[ptr++];
    let UserDefinedRole = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcActorRole(expressID, type, Role, UserDefinedRole, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Role);
    args.push(this.UserDefinedRole);
    args.push(this.Description);
    return args;
  }
};
var IfcActuator = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcActuator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcActuatorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcActuatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAddress = class {
  constructor(expressID, type, Purpose, Description, UserDefinedPurpose) {
    this.expressID = expressID;
    this.type = type;
    this.Purpose = Purpose;
    this.Description = Description;
    this.UserDefinedPurpose = UserDefinedPurpose;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Purpose = tape[ptr++];
    let Description = tape[ptr++];
    let UserDefinedPurpose = tape[ptr++];
    return new IfcAddress(expressID, type, Purpose, Description, UserDefinedPurpose);
  }
  ToTape() {
    let args = [];
    args.push(this.Purpose);
    args.push(this.Description);
    args.push(this.UserDefinedPurpose);
    return args;
  }
};
var IfcAdvancedBrep = class {
  constructor(expressID, type, Outer) {
    this.expressID = expressID;
    this.type = type;
    this.Outer = Outer;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Outer = tape[ptr++];
    return new IfcAdvancedBrep(expressID, type, Outer);
  }
  ToTape() {
    let args = [];
    args.push(this.Outer);
    return args;
  }
};
var IfcAdvancedBrepWithVoids = class {
  constructor(expressID, type, Outer, Voids) {
    this.expressID = expressID;
    this.type = type;
    this.Outer = Outer;
    this.Voids = Voids;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Outer = tape[ptr++];
    let Voids = tape[ptr++];
    return new IfcAdvancedBrepWithVoids(expressID, type, Outer, Voids);
  }
  ToTape() {
    let args = [];
    args.push(this.Outer);
    args.push(this.Voids);
    return args;
  }
};
var IfcAdvancedFace = class {
  constructor(expressID, type, Bounds, FaceSurface, SameSense) {
    this.expressID = expressID;
    this.type = type;
    this.Bounds = Bounds;
    this.FaceSurface = FaceSurface;
    this.SameSense = SameSense;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Bounds = tape[ptr++];
    let FaceSurface = tape[ptr++];
    let SameSense = tape[ptr++];
    return new IfcAdvancedFace(expressID, type, Bounds, FaceSurface, SameSense);
  }
  ToTape() {
    let args = [];
    args.push(this.Bounds);
    args.push(this.FaceSurface);
    args.push(this.SameSense);
    return args;
  }
};
var IfcAirTerminal = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAirTerminalBox = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirTerminalBox(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAirTerminalBoxType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirTerminalBoxType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAirTerminalType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAirToAirHeatRecovery = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirToAirHeatRecovery(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAirToAirHeatRecoveryType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirToAirHeatRecoveryType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAlarm = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAlarm(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAlarmType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAlarmType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAlignment = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Axis = Axis;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Axis = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAlignment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Axis);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAlignment2DHorizontal = class {
  constructor(expressID, type, StartDistAlong, Segments) {
    this.expressID = expressID;
    this.type = type;
    this.StartDistAlong = StartDistAlong;
    this.Segments = Segments;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartDistAlong = tape[ptr++];
    let Segments = tape[ptr++];
    return new IfcAlignment2DHorizontal(expressID, type, StartDistAlong, Segments);
  }
  ToTape() {
    let args = [];
    args.push(this.StartDistAlong);
    args.push(this.Segments);
    return args;
  }
};
var IfcAlignment2DHorizontalSegment = class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag, CurveGeometry) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
    this.CurveGeometry = CurveGeometry;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    let CurveGeometry = tape[ptr++];
    return new IfcAlignment2DHorizontalSegment(expressID, type, TangentialContinuity, StartTag, EndTag, CurveGeometry);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    args.push(this.StartTag);
    args.push(this.EndTag);
    args.push(this.CurveGeometry);
    return args;
  }
};
var IfcAlignment2DSegment = class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    return new IfcAlignment2DSegment(expressID, type, TangentialContinuity, StartTag, EndTag);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    args.push(this.StartTag);
    args.push(this.EndTag);
    return args;
  }
};
var IfcAlignment2DVerSegCircularArc = class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, Radius, IsConvex) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
    this.StartDistAlong = StartDistAlong;
    this.HorizontalLength = HorizontalLength;
    this.StartHeight = StartHeight;
    this.StartGradient = StartGradient;
    this.Radius = Radius;
    this.IsConvex = IsConvex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    let StartDistAlong = tape[ptr++];
    let HorizontalLength = tape[ptr++];
    let StartHeight = tape[ptr++];
    let StartGradient = tape[ptr++];
    let Radius = tape[ptr++];
    let IsConvex = tape[ptr++];
    return new IfcAlignment2DVerSegCircularArc(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, Radius, IsConvex);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    args.push(this.StartTag);
    args.push(this.EndTag);
    args.push(this.StartDistAlong);
    args.push(this.HorizontalLength);
    args.push(this.StartHeight);
    args.push(this.StartGradient);
    args.push(this.Radius);
    args.push(this.IsConvex);
    return args;
  }
};
var IfcAlignment2DVerSegLine = class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
    this.StartDistAlong = StartDistAlong;
    this.HorizontalLength = HorizontalLength;
    this.StartHeight = StartHeight;
    this.StartGradient = StartGradient;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    let StartDistAlong = tape[ptr++];
    let HorizontalLength = tape[ptr++];
    let StartHeight = tape[ptr++];
    let StartGradient = tape[ptr++];
    return new IfcAlignment2DVerSegLine(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    args.push(this.StartTag);
    args.push(this.EndTag);
    args.push(this.StartDistAlong);
    args.push(this.HorizontalLength);
    args.push(this.StartHeight);
    args.push(this.StartGradient);
    return args;
  }
};
var IfcAlignment2DVerSegParabolicArc = class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, ParabolaConstant, IsConvex) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
    this.StartDistAlong = StartDistAlong;
    this.HorizontalLength = HorizontalLength;
    this.StartHeight = StartHeight;
    this.StartGradient = StartGradient;
    this.ParabolaConstant = ParabolaConstant;
    this.IsConvex = IsConvex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    let StartDistAlong = tape[ptr++];
    let HorizontalLength = tape[ptr++];
    let StartHeight = tape[ptr++];
    let StartGradient = tape[ptr++];
    let ParabolaConstant = tape[ptr++];
    let IsConvex = tape[ptr++];
    return new IfcAlignment2DVerSegParabolicArc(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, ParabolaConstant, IsConvex);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    args.push(this.StartTag);
    args.push(this.EndTag);
    args.push(this.StartDistAlong);
    args.push(this.HorizontalLength);
    args.push(this.StartHeight);
    args.push(this.StartGradient);
    args.push(this.ParabolaConstant);
    args.push(this.IsConvex);
    return args;
  }
};
var IfcAlignment2DVertical = class {
  constructor(expressID, type, Segments) {
    this.expressID = expressID;
    this.type = type;
    this.Segments = Segments;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Segments = tape[ptr++];
    return new IfcAlignment2DVertical(expressID, type, Segments);
  }
  ToTape() {
    let args = [];
    args.push(this.Segments);
    return args;
  }
};
var IfcAlignment2DVerticalSegment = class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
    this.StartDistAlong = StartDistAlong;
    this.HorizontalLength = HorizontalLength;
    this.StartHeight = StartHeight;
    this.StartGradient = StartGradient;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    let StartDistAlong = tape[ptr++];
    let HorizontalLength = tape[ptr++];
    let StartHeight = tape[ptr++];
    let StartGradient = tape[ptr++];
    return new IfcAlignment2DVerticalSegment(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    args.push(this.StartTag);
    args.push(this.EndTag);
    args.push(this.StartDistAlong);
    args.push(this.HorizontalLength);
    args.push(this.StartHeight);
    args.push(this.StartGradient);
    return args;
  }
};
var IfcAlignmentCurve = class {
  constructor(expressID, type, Horizontal, Vertical, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.Horizontal = Horizontal;
    this.Vertical = Vertical;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Horizontal = tape[ptr++];
    let Vertical = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcAlignmentCurve(expressID, type, Horizontal, Vertical, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.Horizontal);
    args.push(this.Vertical);
    args.push(this.Tag);
    return args;
  }
};
var IfcAnnotation = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcAnnotation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    return args;
  }
};
var IfcAnnotationFillArea = class {
  constructor(expressID, type, OuterBoundary, InnerBoundaries) {
    this.expressID = expressID;
    this.type = type;
    this.OuterBoundary = OuterBoundary;
    this.InnerBoundaries = InnerBoundaries;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let OuterBoundary = tape[ptr++];
    let InnerBoundaries = tape[ptr++];
    return new IfcAnnotationFillArea(expressID, type, OuterBoundary, InnerBoundaries);
  }
  ToTape() {
    let args = [];
    args.push(this.OuterBoundary);
    args.push(this.InnerBoundaries);
    return args;
  }
};
var IfcApplication = class {
  constructor(expressID, type, ApplicationDeveloper, Version, ApplicationFullName, ApplicationIdentifier) {
    this.expressID = expressID;
    this.type = type;
    this.ApplicationDeveloper = ApplicationDeveloper;
    this.Version = Version;
    this.ApplicationFullName = ApplicationFullName;
    this.ApplicationIdentifier = ApplicationIdentifier;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ApplicationDeveloper = tape[ptr++];
    let Version = tape[ptr++];
    let ApplicationFullName = tape[ptr++];
    let ApplicationIdentifier = tape[ptr++];
    return new IfcApplication(expressID, type, ApplicationDeveloper, Version, ApplicationFullName, ApplicationIdentifier);
  }
  ToTape() {
    let args = [];
    args.push(this.ApplicationDeveloper);
    args.push(this.Version);
    args.push(this.ApplicationFullName);
    args.push(this.ApplicationIdentifier);
    return args;
  }
};
var IfcAppliedValue = class {
  constructor(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.AppliedValue = AppliedValue;
    this.UnitBasis = UnitBasis;
    this.ApplicableDate = ApplicableDate;
    this.FixedUntilDate = FixedUntilDate;
    this.Category = Category;
    this.Condition = Condition;
    this.ArithmeticOperator = ArithmeticOperator;
    this.Components = Components;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let AppliedValue = tape[ptr++];
    let UnitBasis = tape[ptr++];
    let ApplicableDate = tape[ptr++];
    let FixedUntilDate = tape[ptr++];
    let Category = tape[ptr++];
    let Condition = tape[ptr++];
    let ArithmeticOperator = tape[ptr++];
    let Components = tape[ptr++];
    return new IfcAppliedValue(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.AppliedValue);
    args.push(this.UnitBasis);
    args.push(this.ApplicableDate);
    args.push(this.FixedUntilDate);
    args.push(this.Category);
    args.push(this.Condition);
    args.push(this.ArithmeticOperator);
    args.push(this.Components);
    return args;
  }
};
var IfcApproval = class {
  constructor(expressID, type, Identifier, Name, Description, TimeOfApproval, Status, Level, Qualifier, RequestingApproval, GivingApproval) {
    this.expressID = expressID;
    this.type = type;
    this.Identifier = Identifier;
    this.Name = Name;
    this.Description = Description;
    this.TimeOfApproval = TimeOfApproval;
    this.Status = Status;
    this.Level = Level;
    this.Qualifier = Qualifier;
    this.RequestingApproval = RequestingApproval;
    this.GivingApproval = GivingApproval;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Identifier = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let TimeOfApproval = tape[ptr++];
    let Status = tape[ptr++];
    let Level = tape[ptr++];
    let Qualifier = tape[ptr++];
    let RequestingApproval = tape[ptr++];
    let GivingApproval = tape[ptr++];
    return new IfcApproval(expressID, type, Identifier, Name, Description, TimeOfApproval, Status, Level, Qualifier, RequestingApproval, GivingApproval);
  }
  ToTape() {
    let args = [];
    args.push(this.Identifier);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.TimeOfApproval);
    args.push(this.Status);
    args.push(this.Level);
    args.push(this.Qualifier);
    args.push(this.RequestingApproval);
    args.push(this.GivingApproval);
    return args;
  }
};
var IfcApprovalRelationship = class {
  constructor(expressID, type, Name, Description, RelatingApproval, RelatedApprovals) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingApproval = RelatingApproval;
    this.RelatedApprovals = RelatedApprovals;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingApproval = tape[ptr++];
    let RelatedApprovals = tape[ptr++];
    return new IfcApprovalRelationship(expressID, type, Name, Description, RelatingApproval, RelatedApprovals);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingApproval);
    args.push(this.RelatedApprovals);
    return args;
  }
};
var IfcArbitraryClosedProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, OuterCurve) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.OuterCurve = OuterCurve;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let OuterCurve = tape[ptr++];
    return new IfcArbitraryClosedProfileDef(expressID, type, ProfileType, ProfileName, OuterCurve);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.OuterCurve);
    return args;
  }
};
var IfcArbitraryOpenProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Curve) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Curve = Curve;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Curve = tape[ptr++];
    return new IfcArbitraryOpenProfileDef(expressID, type, ProfileType, ProfileName, Curve);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Curve);
    return args;
  }
};
var IfcArbitraryProfileDefWithVoids = class {
  constructor(expressID, type, ProfileType, ProfileName, OuterCurve, InnerCurves) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.OuterCurve = OuterCurve;
    this.InnerCurves = InnerCurves;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let OuterCurve = tape[ptr++];
    let InnerCurves = tape[ptr++];
    return new IfcArbitraryProfileDefWithVoids(expressID, type, ProfileType, ProfileName, OuterCurve, InnerCurves);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.OuterCurve);
    args.push(this.InnerCurves);
    return args;
  }
};
var IfcAsset = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, OriginalValue, CurrentValue, TotalReplacementCost, Owner, User, ResponsiblePerson, IncorporationDate, DepreciatedValue) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.OriginalValue = OriginalValue;
    this.CurrentValue = CurrentValue;
    this.TotalReplacementCost = TotalReplacementCost;
    this.Owner = Owner;
    this.User = User;
    this.ResponsiblePerson = ResponsiblePerson;
    this.IncorporationDate = IncorporationDate;
    this.DepreciatedValue = DepreciatedValue;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let OriginalValue = tape[ptr++];
    let CurrentValue = tape[ptr++];
    let TotalReplacementCost = tape[ptr++];
    let Owner = tape[ptr++];
    let User = tape[ptr++];
    let ResponsiblePerson = tape[ptr++];
    let IncorporationDate = tape[ptr++];
    let DepreciatedValue = tape[ptr++];
    return new IfcAsset(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, OriginalValue, CurrentValue, TotalReplacementCost, Owner, User, ResponsiblePerson, IncorporationDate, DepreciatedValue);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.OriginalValue);
    args.push(this.CurrentValue);
    args.push(this.TotalReplacementCost);
    args.push(this.Owner);
    args.push(this.User);
    args.push(this.ResponsiblePerson);
    args.push(this.IncorporationDate);
    args.push(this.DepreciatedValue);
    return args;
  }
};
var IfcAsymmetricIShapeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, BottomFlangeWidth, OverallDepth, WebThickness, BottomFlangeThickness, BottomFlangeFilletRadius, TopFlangeWidth, TopFlangeThickness, TopFlangeFilletRadius, BottomFlangeEdgeRadius, BottomFlangeSlope, TopFlangeEdgeRadius, TopFlangeSlope) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.BottomFlangeWidth = BottomFlangeWidth;
    this.OverallDepth = OverallDepth;
    this.WebThickness = WebThickness;
    this.BottomFlangeThickness = BottomFlangeThickness;
    this.BottomFlangeFilletRadius = BottomFlangeFilletRadius;
    this.TopFlangeWidth = TopFlangeWidth;
    this.TopFlangeThickness = TopFlangeThickness;
    this.TopFlangeFilletRadius = TopFlangeFilletRadius;
    this.BottomFlangeEdgeRadius = BottomFlangeEdgeRadius;
    this.BottomFlangeSlope = BottomFlangeSlope;
    this.TopFlangeEdgeRadius = TopFlangeEdgeRadius;
    this.TopFlangeSlope = TopFlangeSlope;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let BottomFlangeWidth = tape[ptr++];
    let OverallDepth = tape[ptr++];
    let WebThickness = tape[ptr++];
    let BottomFlangeThickness = tape[ptr++];
    let BottomFlangeFilletRadius = tape[ptr++];
    let TopFlangeWidth = tape[ptr++];
    let TopFlangeThickness = tape[ptr++];
    let TopFlangeFilletRadius = tape[ptr++];
    let BottomFlangeEdgeRadius = tape[ptr++];
    let BottomFlangeSlope = tape[ptr++];
    let TopFlangeEdgeRadius = tape[ptr++];
    let TopFlangeSlope = tape[ptr++];
    return new IfcAsymmetricIShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, BottomFlangeWidth, OverallDepth, WebThickness, BottomFlangeThickness, BottomFlangeFilletRadius, TopFlangeWidth, TopFlangeThickness, TopFlangeFilletRadius, BottomFlangeEdgeRadius, BottomFlangeSlope, TopFlangeEdgeRadius, TopFlangeSlope);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.BottomFlangeWidth);
    args.push(this.OverallDepth);
    args.push(this.WebThickness);
    args.push(this.BottomFlangeThickness);
    args.push(this.BottomFlangeFilletRadius);
    args.push(this.TopFlangeWidth);
    args.push(this.TopFlangeThickness);
    args.push(this.TopFlangeFilletRadius);
    args.push(this.BottomFlangeEdgeRadius);
    args.push(this.BottomFlangeSlope);
    args.push(this.TopFlangeEdgeRadius);
    args.push(this.TopFlangeSlope);
    return args;
  }
};
var IfcAudioVisualAppliance = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAudioVisualAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAudioVisualApplianceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAudioVisualApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAxis1Placement = class {
  constructor(expressID, type, Location, Axis) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Axis = Axis;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Axis = tape[ptr++];
    return new IfcAxis1Placement(expressID, type, Location, Axis);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    args.push(this.Axis);
    return args;
  }
};
var IfcAxis2Placement2D = class {
  constructor(expressID, type, Location, RefDirection) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.RefDirection = RefDirection;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let RefDirection = tape[ptr++];
    return new IfcAxis2Placement2D(expressID, type, Location, RefDirection);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    args.push(this.RefDirection);
    return args;
  }
};
var IfcAxis2Placement3D = class {
  constructor(expressID, type, Location, Axis, RefDirection) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Axis = Axis;
    this.RefDirection = RefDirection;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Axis = tape[ptr++];
    let RefDirection = tape[ptr++];
    return new IfcAxis2Placement3D(expressID, type, Location, Axis, RefDirection);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    args.push(this.Axis);
    args.push(this.RefDirection);
    return args;
  }
};
var IfcBSplineCurve = class {
  constructor(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Degree = Degree;
    this.ControlPointsList = ControlPointsList;
    this.CurveForm = CurveForm;
    this.ClosedCurve = ClosedCurve;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Degree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let CurveForm = tape[ptr++];
    let ClosedCurve = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcBSplineCurve(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Degree);
    args.push(this.ControlPointsList);
    args.push(this.CurveForm);
    args.push(this.ClosedCurve);
    args.push(this.SelfIntersect);
    return args;
  }
};
var IfcBSplineCurveWithKnots = class {
  constructor(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec) {
    this.expressID = expressID;
    this.type = type;
    this.Degree = Degree;
    this.ControlPointsList = ControlPointsList;
    this.CurveForm = CurveForm;
    this.ClosedCurve = ClosedCurve;
    this.SelfIntersect = SelfIntersect;
    this.KnotMultiplicities = KnotMultiplicities;
    this.Knots = Knots;
    this.KnotSpec = KnotSpec;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Degree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let CurveForm = tape[ptr++];
    let ClosedCurve = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    let KnotMultiplicities = tape[ptr++];
    let Knots = tape[ptr++];
    let KnotSpec = tape[ptr++];
    return new IfcBSplineCurveWithKnots(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec);
  }
  ToTape() {
    let args = [];
    args.push(this.Degree);
    args.push(this.ControlPointsList);
    args.push(this.CurveForm);
    args.push(this.ClosedCurve);
    args.push(this.SelfIntersect);
    args.push(this.KnotMultiplicities);
    args.push(this.Knots);
    args.push(this.KnotSpec);
    return args;
  }
};
var IfcBSplineSurface = class {
  constructor(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.UDegree = UDegree;
    this.VDegree = VDegree;
    this.ControlPointsList = ControlPointsList;
    this.SurfaceForm = SurfaceForm;
    this.UClosed = UClosed;
    this.VClosed = VClosed;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let UDegree = tape[ptr++];
    let VDegree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let SurfaceForm = tape[ptr++];
    let UClosed = tape[ptr++];
    let VClosed = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcBSplineSurface(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.UDegree);
    args.push(this.VDegree);
    args.push(this.ControlPointsList);
    args.push(this.SurfaceForm);
    args.push(this.UClosed);
    args.push(this.VClosed);
    args.push(this.SelfIntersect);
    return args;
  }
};
var IfcBSplineSurfaceWithKnots = class {
  constructor(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec) {
    this.expressID = expressID;
    this.type = type;
    this.UDegree = UDegree;
    this.VDegree = VDegree;
    this.ControlPointsList = ControlPointsList;
    this.SurfaceForm = SurfaceForm;
    this.UClosed = UClosed;
    this.VClosed = VClosed;
    this.SelfIntersect = SelfIntersect;
    this.UMultiplicities = UMultiplicities;
    this.VMultiplicities = VMultiplicities;
    this.UKnots = UKnots;
    this.VKnots = VKnots;
    this.KnotSpec = KnotSpec;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let UDegree = tape[ptr++];
    let VDegree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let SurfaceForm = tape[ptr++];
    let UClosed = tape[ptr++];
    let VClosed = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    let UMultiplicities = tape[ptr++];
    let VMultiplicities = tape[ptr++];
    let UKnots = tape[ptr++];
    let VKnots = tape[ptr++];
    let KnotSpec = tape[ptr++];
    return new IfcBSplineSurfaceWithKnots(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec);
  }
  ToTape() {
    let args = [];
    args.push(this.UDegree);
    args.push(this.VDegree);
    args.push(this.ControlPointsList);
    args.push(this.SurfaceForm);
    args.push(this.UClosed);
    args.push(this.VClosed);
    args.push(this.SelfIntersect);
    args.push(this.UMultiplicities);
    args.push(this.VMultiplicities);
    args.push(this.UKnots);
    args.push(this.VKnots);
    args.push(this.KnotSpec);
    return args;
  }
};
var IfcBeam = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBeam(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBeamStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBeamStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBeamType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBeamType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBearing = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBearing(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBearingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBearingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBlobTexture = class {
  constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, RasterFormat, RasterCode) {
    this.expressID = expressID;
    this.type = type;
    this.RepeatS = RepeatS;
    this.RepeatT = RepeatT;
    this.Mode = Mode;
    this.TextureTransform = TextureTransform;
    this.Parameter = Parameter;
    this.RasterFormat = RasterFormat;
    this.RasterCode = RasterCode;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RepeatS = tape[ptr++];
    let RepeatT = tape[ptr++];
    let Mode = tape[ptr++];
    let TextureTransform = tape[ptr++];
    let Parameter = tape[ptr++];
    let RasterFormat = tape[ptr++];
    let RasterCode = tape[ptr++];
    return new IfcBlobTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, RasterFormat, RasterCode);
  }
  ToTape() {
    let args = [];
    args.push(this.RepeatS);
    args.push(this.RepeatT);
    args.push(this.Mode);
    args.push(this.TextureTransform);
    args.push(this.Parameter);
    args.push(this.RasterFormat);
    args.push(this.RasterCode);
    return args;
  }
};
var IfcBlock = class {
  constructor(expressID, type, Position, XLength, YLength, ZLength) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.XLength = XLength;
    this.YLength = YLength;
    this.ZLength = ZLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let XLength = tape[ptr++];
    let YLength = tape[ptr++];
    let ZLength = tape[ptr++];
    return new IfcBlock(expressID, type, Position, XLength, YLength, ZLength);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    args.push(this.XLength);
    args.push(this.YLength);
    args.push(this.ZLength);
    return args;
  }
};
var IfcBoiler = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBoiler(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBoilerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBoilerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBooleanClippingResult = class {
  constructor(expressID, type, Operator, FirstOperand, SecondOperand) {
    this.expressID = expressID;
    this.type = type;
    this.Operator = Operator;
    this.FirstOperand = FirstOperand;
    this.SecondOperand = SecondOperand;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Operator = tape[ptr++];
    let FirstOperand = tape[ptr++];
    let SecondOperand = tape[ptr++];
    return new IfcBooleanClippingResult(expressID, type, Operator, FirstOperand, SecondOperand);
  }
  ToTape() {
    let args = [];
    args.push(this.Operator);
    args.push(this.FirstOperand);
    args.push(this.SecondOperand);
    return args;
  }
};
var IfcBooleanResult = class {
  constructor(expressID, type, Operator, FirstOperand, SecondOperand) {
    this.expressID = expressID;
    this.type = type;
    this.Operator = Operator;
    this.FirstOperand = FirstOperand;
    this.SecondOperand = SecondOperand;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Operator = tape[ptr++];
    let FirstOperand = tape[ptr++];
    let SecondOperand = tape[ptr++];
    return new IfcBooleanResult(expressID, type, Operator, FirstOperand, SecondOperand);
  }
  ToTape() {
    let args = [];
    args.push(this.Operator);
    args.push(this.FirstOperand);
    args.push(this.SecondOperand);
    return args;
  }
};
var IfcBoundaryCondition = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcBoundaryCondition(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcBoundaryCurve = class {
  constructor(expressID, type, Segments, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Segments = Segments;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Segments = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcBoundaryCurve(expressID, type, Segments, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Segments);
    args.push(this.SelfIntersect);
    return args;
  }
};
var IfcBoundaryEdgeCondition = class {
  constructor(expressID, type, Name, TranslationalStiffnessByLengthX, TranslationalStiffnessByLengthY, TranslationalStiffnessByLengthZ, RotationalStiffnessByLengthX, RotationalStiffnessByLengthY, RotationalStiffnessByLengthZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TranslationalStiffnessByLengthX = TranslationalStiffnessByLengthX;
    this.TranslationalStiffnessByLengthY = TranslationalStiffnessByLengthY;
    this.TranslationalStiffnessByLengthZ = TranslationalStiffnessByLengthZ;
    this.RotationalStiffnessByLengthX = RotationalStiffnessByLengthX;
    this.RotationalStiffnessByLengthY = RotationalStiffnessByLengthY;
    this.RotationalStiffnessByLengthZ = RotationalStiffnessByLengthZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TranslationalStiffnessByLengthX = tape[ptr++];
    let TranslationalStiffnessByLengthY = tape[ptr++];
    let TranslationalStiffnessByLengthZ = tape[ptr++];
    let RotationalStiffnessByLengthX = tape[ptr++];
    let RotationalStiffnessByLengthY = tape[ptr++];
    let RotationalStiffnessByLengthZ = tape[ptr++];
    return new IfcBoundaryEdgeCondition(expressID, type, Name, TranslationalStiffnessByLengthX, TranslationalStiffnessByLengthY, TranslationalStiffnessByLengthZ, RotationalStiffnessByLengthX, RotationalStiffnessByLengthY, RotationalStiffnessByLengthZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.TranslationalStiffnessByLengthX);
    args.push(this.TranslationalStiffnessByLengthY);
    args.push(this.TranslationalStiffnessByLengthZ);
    args.push(this.RotationalStiffnessByLengthX);
    args.push(this.RotationalStiffnessByLengthY);
    args.push(this.RotationalStiffnessByLengthZ);
    return args;
  }
};
var IfcBoundaryFaceCondition = class {
  constructor(expressID, type, Name, TranslationalStiffnessByAreaX, TranslationalStiffnessByAreaY, TranslationalStiffnessByAreaZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TranslationalStiffnessByAreaX = TranslationalStiffnessByAreaX;
    this.TranslationalStiffnessByAreaY = TranslationalStiffnessByAreaY;
    this.TranslationalStiffnessByAreaZ = TranslationalStiffnessByAreaZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TranslationalStiffnessByAreaX = tape[ptr++];
    let TranslationalStiffnessByAreaY = tape[ptr++];
    let TranslationalStiffnessByAreaZ = tape[ptr++];
    return new IfcBoundaryFaceCondition(expressID, type, Name, TranslationalStiffnessByAreaX, TranslationalStiffnessByAreaY, TranslationalStiffnessByAreaZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.TranslationalStiffnessByAreaX);
    args.push(this.TranslationalStiffnessByAreaY);
    args.push(this.TranslationalStiffnessByAreaZ);
    return args;
  }
};
var IfcBoundaryNodeCondition = class {
  constructor(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TranslationalStiffnessX = TranslationalStiffnessX;
    this.TranslationalStiffnessY = TranslationalStiffnessY;
    this.TranslationalStiffnessZ = TranslationalStiffnessZ;
    this.RotationalStiffnessX = RotationalStiffnessX;
    this.RotationalStiffnessY = RotationalStiffnessY;
    this.RotationalStiffnessZ = RotationalStiffnessZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TranslationalStiffnessX = tape[ptr++];
    let TranslationalStiffnessY = tape[ptr++];
    let TranslationalStiffnessZ = tape[ptr++];
    let RotationalStiffnessX = tape[ptr++];
    let RotationalStiffnessY = tape[ptr++];
    let RotationalStiffnessZ = tape[ptr++];
    return new IfcBoundaryNodeCondition(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.TranslationalStiffnessX);
    args.push(this.TranslationalStiffnessY);
    args.push(this.TranslationalStiffnessZ);
    args.push(this.RotationalStiffnessX);
    args.push(this.RotationalStiffnessY);
    args.push(this.RotationalStiffnessZ);
    return args;
  }
};
var IfcBoundaryNodeConditionWarping = class {
  constructor(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ, WarpingStiffness) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TranslationalStiffnessX = TranslationalStiffnessX;
    this.TranslationalStiffnessY = TranslationalStiffnessY;
    this.TranslationalStiffnessZ = TranslationalStiffnessZ;
    this.RotationalStiffnessX = RotationalStiffnessX;
    this.RotationalStiffnessY = RotationalStiffnessY;
    this.RotationalStiffnessZ = RotationalStiffnessZ;
    this.WarpingStiffness = WarpingStiffness;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TranslationalStiffnessX = tape[ptr++];
    let TranslationalStiffnessY = tape[ptr++];
    let TranslationalStiffnessZ = tape[ptr++];
    let RotationalStiffnessX = tape[ptr++];
    let RotationalStiffnessY = tape[ptr++];
    let RotationalStiffnessZ = tape[ptr++];
    let WarpingStiffness = tape[ptr++];
    return new IfcBoundaryNodeConditionWarping(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ, WarpingStiffness);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.TranslationalStiffnessX);
    args.push(this.TranslationalStiffnessY);
    args.push(this.TranslationalStiffnessZ);
    args.push(this.RotationalStiffnessX);
    args.push(this.RotationalStiffnessY);
    args.push(this.RotationalStiffnessZ);
    args.push(this.WarpingStiffness);
    return args;
  }
};
var IfcBoundedCurve = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcBoundedCurve(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcBoundedSurface = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcBoundedSurface(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcBoundingBox = class {
  constructor(expressID, type, Corner, XDim, YDim, ZDim) {
    this.expressID = expressID;
    this.type = type;
    this.Corner = Corner;
    this.XDim = XDim;
    this.YDim = YDim;
    this.ZDim = ZDim;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Corner = tape[ptr++];
    let XDim = tape[ptr++];
    let YDim = tape[ptr++];
    let ZDim = tape[ptr++];
    return new IfcBoundingBox(expressID, type, Corner, XDim, YDim, ZDim);
  }
  ToTape() {
    let args = [];
    args.push(this.Corner);
    args.push(this.XDim);
    args.push(this.YDim);
    args.push(this.ZDim);
    return args;
  }
};
var IfcBoxedHalfSpace = class {
  constructor(expressID, type, BaseSurface, AgreementFlag, Enclosure) {
    this.expressID = expressID;
    this.type = type;
    this.BaseSurface = BaseSurface;
    this.AgreementFlag = AgreementFlag;
    this.Enclosure = Enclosure;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BaseSurface = tape[ptr++];
    let AgreementFlag = tape[ptr++];
    let Enclosure = tape[ptr++];
    return new IfcBoxedHalfSpace(expressID, type, BaseSurface, AgreementFlag, Enclosure);
  }
  ToTape() {
    let args = [];
    args.push(this.BaseSurface);
    args.push(this.AgreementFlag);
    args.push(this.Enclosure);
    return args;
  }
};
var IfcBridge = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBridge(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.CompositionType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBridgePart = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBridgePart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.CompositionType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBuilding = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, ElevationOfRefHeight, ElevationOfTerrain, BuildingAddress) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.ElevationOfRefHeight = ElevationOfRefHeight;
    this.ElevationOfTerrain = ElevationOfTerrain;
    this.BuildingAddress = BuildingAddress;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let ElevationOfRefHeight = tape[ptr++];
    let ElevationOfTerrain = tape[ptr++];
    let BuildingAddress = tape[ptr++];
    return new IfcBuilding(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, ElevationOfRefHeight, ElevationOfTerrain, BuildingAddress);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.CompositionType);
    args.push(this.ElevationOfRefHeight);
    args.push(this.ElevationOfTerrain);
    args.push(this.BuildingAddress);
    return args;
  }
};
var IfcBuildingElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcBuildingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcBuildingElementPart = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBuildingElementPart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBuildingElementPartType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBuildingElementPartType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBuildingElementProxy = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBuildingElementProxy(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBuildingElementProxyType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBuildingElementProxyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBuildingElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcBuildingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcBuildingStorey = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, Elevation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.Elevation = Elevation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let Elevation = tape[ptr++];
    return new IfcBuildingStorey(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, Elevation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.CompositionType);
    args.push(this.Elevation);
    return args;
  }
};
var IfcBuildingSystem = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.PredefinedType = PredefinedType;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcBuildingSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.PredefinedType);
    args.push(this.LongName);
    return args;
  }
};
var IfcBurner = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBurner(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBurnerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBurnerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCShapeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Depth, Width, WallThickness, Girth, InternalFilletRadius) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Depth = Depth;
    this.Width = Width;
    this.WallThickness = WallThickness;
    this.Girth = Girth;
    this.InternalFilletRadius = InternalFilletRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Depth = tape[ptr++];
    let Width = tape[ptr++];
    let WallThickness = tape[ptr++];
    let Girth = tape[ptr++];
    let InternalFilletRadius = tape[ptr++];
    return new IfcCShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, Width, WallThickness, Girth, InternalFilletRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.Depth);
    args.push(this.Width);
    args.push(this.WallThickness);
    args.push(this.Girth);
    args.push(this.InternalFilletRadius);
    return args;
  }
};
var IfcCableCarrierFitting = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableCarrierFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCableCarrierFittingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableCarrierFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCableCarrierSegment = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableCarrierSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCableCarrierSegmentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableCarrierSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCableFitting = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCableFittingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCableSegment = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCableSegmentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCaissonFoundation = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCaissonFoundation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCaissonFoundationType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCaissonFoundationType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCartesianPoint = class {
  constructor(expressID, type, Coordinates) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    return new IfcCartesianPoint(expressID, type, Coordinates);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    return args;
  }
};
var IfcCartesianPointList = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcCartesianPointList(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcCartesianPointList2D = class {
  constructor(expressID, type, CoordList, TagList) {
    this.expressID = expressID;
    this.type = type;
    this.CoordList = CoordList;
    this.TagList = TagList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CoordList = tape[ptr++];
    let TagList = tape[ptr++];
    return new IfcCartesianPointList2D(expressID, type, CoordList, TagList);
  }
  ToTape() {
    let args = [];
    args.push(this.CoordList);
    args.push(this.TagList);
    return args;
  }
};
var IfcCartesianPointList3D = class {
  constructor(expressID, type, CoordList, TagList) {
    this.expressID = expressID;
    this.type = type;
    this.CoordList = CoordList;
    this.TagList = TagList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CoordList = tape[ptr++];
    let TagList = tape[ptr++];
    return new IfcCartesianPointList3D(expressID, type, CoordList, TagList);
  }
  ToTape() {
    let args = [];
    args.push(this.CoordList);
    args.push(this.TagList);
    return args;
  }
};
var IfcCartesianTransformationOperator = class {
  constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale) {
    this.expressID = expressID;
    this.type = type;
    this.Axis1 = Axis1;
    this.Axis2 = Axis2;
    this.LocalOrigin = LocalOrigin;
    this.Scale = Scale;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Axis1 = tape[ptr++];
    let Axis2 = tape[ptr++];
    let LocalOrigin = tape[ptr++];
    let Scale = tape[ptr++];
    return new IfcCartesianTransformationOperator(expressID, type, Axis1, Axis2, LocalOrigin, Scale);
  }
  ToTape() {
    let args = [];
    args.push(this.Axis1);
    args.push(this.Axis2);
    args.push(this.LocalOrigin);
    args.push(this.Scale);
    return args;
  }
};
var IfcCartesianTransformationOperator2D = class {
  constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale) {
    this.expressID = expressID;
    this.type = type;
    this.Axis1 = Axis1;
    this.Axis2 = Axis2;
    this.LocalOrigin = LocalOrigin;
    this.Scale = Scale;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Axis1 = tape[ptr++];
    let Axis2 = tape[ptr++];
    let LocalOrigin = tape[ptr++];
    let Scale = tape[ptr++];
    return new IfcCartesianTransformationOperator2D(expressID, type, Axis1, Axis2, LocalOrigin, Scale);
  }
  ToTape() {
    let args = [];
    args.push(this.Axis1);
    args.push(this.Axis2);
    args.push(this.LocalOrigin);
    args.push(this.Scale);
    return args;
  }
};
var IfcCartesianTransformationOperator2DnonUniform = class {
  constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Scale2) {
    this.expressID = expressID;
    this.type = type;
    this.Axis1 = Axis1;
    this.Axis2 = Axis2;
    this.LocalOrigin = LocalOrigin;
    this.Scale = Scale;
    this.Scale2 = Scale2;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Axis1 = tape[ptr++];
    let Axis2 = tape[ptr++];
    let LocalOrigin = tape[ptr++];
    let Scale = tape[ptr++];
    let Scale2 = tape[ptr++];
    return new IfcCartesianTransformationOperator2DnonUniform(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Scale2);
  }
  ToTape() {
    let args = [];
    args.push(this.Axis1);
    args.push(this.Axis2);
    args.push(this.LocalOrigin);
    args.push(this.Scale);
    args.push(this.Scale2);
    return args;
  }
};
var IfcCartesianTransformationOperator3D = class {
  constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3) {
    this.expressID = expressID;
    this.type = type;
    this.Axis1 = Axis1;
    this.Axis2 = Axis2;
    this.LocalOrigin = LocalOrigin;
    this.Scale = Scale;
    this.Axis3 = Axis3;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Axis1 = tape[ptr++];
    let Axis2 = tape[ptr++];
    let LocalOrigin = tape[ptr++];
    let Scale = tape[ptr++];
    let Axis3 = tape[ptr++];
    return new IfcCartesianTransformationOperator3D(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3);
  }
  ToTape() {
    let args = [];
    args.push(this.Axis1);
    args.push(this.Axis2);
    args.push(this.LocalOrigin);
    args.push(this.Scale);
    args.push(this.Axis3);
    return args;
  }
};
var IfcCartesianTransformationOperator3DnonUniform = class {
  constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3, Scale2, Scale3) {
    this.expressID = expressID;
    this.type = type;
    this.Axis1 = Axis1;
    this.Axis2 = Axis2;
    this.LocalOrigin = LocalOrigin;
    this.Scale = Scale;
    this.Axis3 = Axis3;
    this.Scale2 = Scale2;
    this.Scale3 = Scale3;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Axis1 = tape[ptr++];
    let Axis2 = tape[ptr++];
    let LocalOrigin = tape[ptr++];
    let Scale = tape[ptr++];
    let Axis3 = tape[ptr++];
    let Scale2 = tape[ptr++];
    let Scale3 = tape[ptr++];
    return new IfcCartesianTransformationOperator3DnonUniform(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3, Scale2, Scale3);
  }
  ToTape() {
    let args = [];
    args.push(this.Axis1);
    args.push(this.Axis2);
    args.push(this.LocalOrigin);
    args.push(this.Scale);
    args.push(this.Axis3);
    args.push(this.Scale2);
    args.push(this.Scale3);
    return args;
  }
};
var IfcCenterLineProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Curve, Thickness) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Curve = Curve;
    this.Thickness = Thickness;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Curve = tape[ptr++];
    let Thickness = tape[ptr++];
    return new IfcCenterLineProfileDef(expressID, type, ProfileType, ProfileName, Curve, Thickness);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Curve);
    args.push(this.Thickness);
    return args;
  }
};
var IfcChiller = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcChiller(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcChillerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcChillerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcChimney = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcChimney(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcChimneyType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcChimneyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCircle = class {
  constructor(expressID, type, Position, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcCircle(expressID, type, Position, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    args.push(this.Radius);
    return args;
  }
};
var IfcCircleHollowProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Radius, WallThickness) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Radius = Radius;
    this.WallThickness = WallThickness;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    let WallThickness = tape[ptr++];
    return new IfcCircleHollowProfileDef(expressID, type, ProfileType, ProfileName, Position, Radius, WallThickness);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.Radius);
    args.push(this.WallThickness);
    return args;
  }
};
var IfcCircleProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcCircleProfileDef(expressID, type, ProfileType, ProfileName, Position, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.Radius);
    return args;
  }
};
var IfcCircularArcSegment2D = class {
  constructor(expressID, type, StartPoint, StartDirection, SegmentLength, Radius, IsCCW) {
    this.expressID = expressID;
    this.type = type;
    this.StartPoint = StartPoint;
    this.StartDirection = StartDirection;
    this.SegmentLength = SegmentLength;
    this.Radius = Radius;
    this.IsCCW = IsCCW;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartPoint = tape[ptr++];
    let StartDirection = tape[ptr++];
    let SegmentLength = tape[ptr++];
    let Radius = tape[ptr++];
    let IsCCW = tape[ptr++];
    return new IfcCircularArcSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength, Radius, IsCCW);
  }
  ToTape() {
    let args = [];
    args.push(this.StartPoint);
    args.push(this.StartDirection);
    args.push(this.SegmentLength);
    args.push(this.Radius);
    args.push(this.IsCCW);
    return args;
  }
};
var IfcCivilElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcCivilElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcCivilElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcCivilElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcClassification = class {
  constructor(expressID, type, Source, Edition, EditionDate, Name, Description, Location, ReferenceTokens) {
    this.expressID = expressID;
    this.type = type;
    this.Source = Source;
    this.Edition = Edition;
    this.EditionDate = EditionDate;
    this.Name = Name;
    this.Description = Description;
    this.Location = Location;
    this.ReferenceTokens = ReferenceTokens;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Source = tape[ptr++];
    let Edition = tape[ptr++];
    let EditionDate = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Location = tape[ptr++];
    let ReferenceTokens = tape[ptr++];
    return new IfcClassification(expressID, type, Source, Edition, EditionDate, Name, Description, Location, ReferenceTokens);
  }
  ToTape() {
    let args = [];
    args.push(this.Source);
    args.push(this.Edition);
    args.push(this.EditionDate);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Location);
    args.push(this.ReferenceTokens);
    return args;
  }
};
var IfcClassificationReference = class {
  constructor(expressID, type, Location, Identification, Name, ReferencedSource, Description, Sort) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
    this.ReferencedSource = ReferencedSource;
    this.Description = Description;
    this.Sort = Sort;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    let ReferencedSource = tape[ptr++];
    let Description = tape[ptr++];
    let Sort = tape[ptr++];
    return new IfcClassificationReference(expressID, type, Location, Identification, Name, ReferencedSource, Description, Sort);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    args.push(this.Identification);
    args.push(this.Name);
    args.push(this.ReferencedSource);
    args.push(this.Description);
    args.push(this.Sort);
    return args;
  }
};
var IfcClosedShell = class {
  constructor(expressID, type, CfsFaces) {
    this.expressID = expressID;
    this.type = type;
    this.CfsFaces = CfsFaces;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CfsFaces = tape[ptr++];
    return new IfcClosedShell(expressID, type, CfsFaces);
  }
  ToTape() {
    let args = [];
    args.push(this.CfsFaces);
    return args;
  }
};
var IfcCoil = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCoil(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCoilType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCoilType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcColourRgb = class {
  constructor(expressID, type, Name, Red, Green, Blue) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Red = Red;
    this.Green = Green;
    this.Blue = Blue;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Red = tape[ptr++];
    let Green = tape[ptr++];
    let Blue = tape[ptr++];
    return new IfcColourRgb(expressID, type, Name, Red, Green, Blue);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Red);
    args.push(this.Green);
    args.push(this.Blue);
    return args;
  }
};
var IfcColourRgbList = class {
  constructor(expressID, type, ColourList) {
    this.expressID = expressID;
    this.type = type;
    this.ColourList = ColourList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ColourList = tape[ptr++];
    return new IfcColourRgbList(expressID, type, ColourList);
  }
  ToTape() {
    let args = [];
    args.push(this.ColourList);
    return args;
  }
};
var IfcColourSpecification = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcColourSpecification(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcColumn = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcColumn(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcColumnStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcColumnStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcColumnType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcColumnType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCommunicationsAppliance = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCommunicationsAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCommunicationsApplianceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCommunicationsApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcComplexProperty = class {
  constructor(expressID, type, Name, Description, UsageName, HasProperties) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.UsageName = UsageName;
    this.HasProperties = HasProperties;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let UsageName = tape[ptr++];
    let HasProperties = tape[ptr++];
    return new IfcComplexProperty(expressID, type, Name, Description, UsageName, HasProperties);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.UsageName);
    args.push(this.HasProperties);
    return args;
  }
};
var IfcComplexPropertyTemplate = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, UsageName, TemplateType, HasPropertyTemplates) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.UsageName = UsageName;
    this.TemplateType = TemplateType;
    this.HasPropertyTemplates = HasPropertyTemplates;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let UsageName = tape[ptr++];
    let TemplateType = tape[ptr++];
    let HasPropertyTemplates = tape[ptr++];
    return new IfcComplexPropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, UsageName, TemplateType, HasPropertyTemplates);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.UsageName);
    args.push(this.TemplateType);
    args.push(this.HasPropertyTemplates);
    return args;
  }
};
var IfcCompositeCurve = class {
  constructor(expressID, type, Segments, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Segments = Segments;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Segments = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcCompositeCurve(expressID, type, Segments, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Segments);
    args.push(this.SelfIntersect);
    return args;
  }
};
var IfcCompositeCurveOnSurface = class {
  constructor(expressID, type, Segments, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Segments = Segments;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Segments = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcCompositeCurveOnSurface(expressID, type, Segments, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Segments);
    args.push(this.SelfIntersect);
    return args;
  }
};
var IfcCompositeCurveSegment = class {
  constructor(expressID, type, Transition, SameSense, ParentCurve) {
    this.expressID = expressID;
    this.type = type;
    this.Transition = Transition;
    this.SameSense = SameSense;
    this.ParentCurve = ParentCurve;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Transition = tape[ptr++];
    let SameSense = tape[ptr++];
    let ParentCurve = tape[ptr++];
    return new IfcCompositeCurveSegment(expressID, type, Transition, SameSense, ParentCurve);
  }
  ToTape() {
    let args = [];
    args.push(this.Transition);
    args.push(this.SameSense);
    args.push(this.ParentCurve);
    return args;
  }
};
var IfcCompositeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Profiles, Label) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Profiles = Profiles;
    this.Label = Label;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Profiles = tape[ptr++];
    let Label = tape[ptr++];
    return new IfcCompositeProfileDef(expressID, type, ProfileType, ProfileName, Profiles, Label);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Profiles);
    args.push(this.Label);
    return args;
  }
};
var IfcCompressor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCompressor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCompressorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCompressorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCondenser = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCondenser(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCondenserType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCondenserType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcConic = class {
  constructor(expressID, type, Position) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    return new IfcConic(expressID, type, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    return args;
  }
};
var IfcConnectedFaceSet = class {
  constructor(expressID, type, CfsFaces) {
    this.expressID = expressID;
    this.type = type;
    this.CfsFaces = CfsFaces;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CfsFaces = tape[ptr++];
    return new IfcConnectedFaceSet(expressID, type, CfsFaces);
  }
  ToTape() {
    let args = [];
    args.push(this.CfsFaces);
    return args;
  }
};
var IfcConnectionCurveGeometry = class {
  constructor(expressID, type, CurveOnRelatingElement, CurveOnRelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.CurveOnRelatingElement = CurveOnRelatingElement;
    this.CurveOnRelatedElement = CurveOnRelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CurveOnRelatingElement = tape[ptr++];
    let CurveOnRelatedElement = tape[ptr++];
    return new IfcConnectionCurveGeometry(expressID, type, CurveOnRelatingElement, CurveOnRelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.CurveOnRelatingElement);
    args.push(this.CurveOnRelatedElement);
    return args;
  }
};
var IfcConnectionGeometry = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcConnectionGeometry(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcConnectionPointEccentricity = class {
  constructor(expressID, type, PointOnRelatingElement, PointOnRelatedElement, EccentricityInX, EccentricityInY, EccentricityInZ) {
    this.expressID = expressID;
    this.type = type;
    this.PointOnRelatingElement = PointOnRelatingElement;
    this.PointOnRelatedElement = PointOnRelatedElement;
    this.EccentricityInX = EccentricityInX;
    this.EccentricityInY = EccentricityInY;
    this.EccentricityInZ = EccentricityInZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PointOnRelatingElement = tape[ptr++];
    let PointOnRelatedElement = tape[ptr++];
    let EccentricityInX = tape[ptr++];
    let EccentricityInY = tape[ptr++];
    let EccentricityInZ = tape[ptr++];
    return new IfcConnectionPointEccentricity(expressID, type, PointOnRelatingElement, PointOnRelatedElement, EccentricityInX, EccentricityInY, EccentricityInZ);
  }
  ToTape() {
    let args = [];
    args.push(this.PointOnRelatingElement);
    args.push(this.PointOnRelatedElement);
    args.push(this.EccentricityInX);
    args.push(this.EccentricityInY);
    args.push(this.EccentricityInZ);
    return args;
  }
};
var IfcConnectionPointGeometry = class {
  constructor(expressID, type, PointOnRelatingElement, PointOnRelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.PointOnRelatingElement = PointOnRelatingElement;
    this.PointOnRelatedElement = PointOnRelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PointOnRelatingElement = tape[ptr++];
    let PointOnRelatedElement = tape[ptr++];
    return new IfcConnectionPointGeometry(expressID, type, PointOnRelatingElement, PointOnRelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.PointOnRelatingElement);
    args.push(this.PointOnRelatedElement);
    return args;
  }
};
var IfcConnectionSurfaceGeometry = class {
  constructor(expressID, type, SurfaceOnRelatingElement, SurfaceOnRelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.SurfaceOnRelatingElement = SurfaceOnRelatingElement;
    this.SurfaceOnRelatedElement = SurfaceOnRelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SurfaceOnRelatingElement = tape[ptr++];
    let SurfaceOnRelatedElement = tape[ptr++];
    return new IfcConnectionSurfaceGeometry(expressID, type, SurfaceOnRelatingElement, SurfaceOnRelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.SurfaceOnRelatingElement);
    args.push(this.SurfaceOnRelatedElement);
    return args;
  }
};
var IfcConnectionVolumeGeometry = class {
  constructor(expressID, type, VolumeOnRelatingElement, VolumeOnRelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.VolumeOnRelatingElement = VolumeOnRelatingElement;
    this.VolumeOnRelatedElement = VolumeOnRelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let VolumeOnRelatingElement = tape[ptr++];
    let VolumeOnRelatedElement = tape[ptr++];
    return new IfcConnectionVolumeGeometry(expressID, type, VolumeOnRelatingElement, VolumeOnRelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.VolumeOnRelatingElement);
    args.push(this.VolumeOnRelatedElement);
    return args;
  }
};
var IfcConstraint = class {
  constructor(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.ConstraintGrade = ConstraintGrade;
    this.ConstraintSource = ConstraintSource;
    this.CreatingActor = CreatingActor;
    this.CreationTime = CreationTime;
    this.UserDefinedGrade = UserDefinedGrade;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConstraintGrade = tape[ptr++];
    let ConstraintSource = tape[ptr++];
    let CreatingActor = tape[ptr++];
    let CreationTime = tape[ptr++];
    let UserDefinedGrade = tape[ptr++];
    return new IfcConstraint(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ConstraintGrade);
    args.push(this.ConstraintSource);
    args.push(this.CreatingActor);
    args.push(this.CreationTime);
    args.push(this.UserDefinedGrade);
    return args;
  }
};
var IfcConstructionEquipmentResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionEquipmentResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.Usage);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcConstructionEquipmentResourceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionEquipmentResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ResourceType);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcConstructionMaterialResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionMaterialResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.Usage);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcConstructionMaterialResourceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionMaterialResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ResourceType);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcConstructionProductResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionProductResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.Usage);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcConstructionProductResourceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionProductResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ResourceType);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcConstructionResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    return new IfcConstructionResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.Usage);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    return args;
  }
};
var IfcConstructionResourceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    return new IfcConstructionResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ResourceType);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    return args;
  }
};
var IfcContext = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
    this.Phase = Phase;
    this.RepresentationContexts = RepresentationContexts;
    this.UnitsInContext = UnitsInContext;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    let Phase = tape[ptr++];
    let RepresentationContexts = tape[ptr++];
    let UnitsInContext = tape[ptr++];
    return new IfcContext(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.LongName);
    args.push(this.Phase);
    args.push(this.RepresentationContexts);
    args.push(this.UnitsInContext);
    return args;
  }
};
var IfcContextDependentUnit = class {
  constructor(expressID, type, Dimensions, UnitType, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Dimensions = Dimensions;
    this.UnitType = UnitType;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Dimensions = tape[ptr++];
    let UnitType = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcContextDependentUnit(expressID, type, Dimensions, UnitType, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Dimensions);
    args.push(this.UnitType);
    args.push(this.Name);
    return args;
  }
};
var IfcControl = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    return new IfcControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    return args;
  }
};
var IfcController = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcController(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcControllerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcControllerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcConversionBasedUnit = class {
  constructor(expressID, type, Dimensions, UnitType, Name, ConversionFactor) {
    this.expressID = expressID;
    this.type = type;
    this.Dimensions = Dimensions;
    this.UnitType = UnitType;
    this.Name = Name;
    this.ConversionFactor = ConversionFactor;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Dimensions = tape[ptr++];
    let UnitType = tape[ptr++];
    let Name = tape[ptr++];
    let ConversionFactor = tape[ptr++];
    return new IfcConversionBasedUnit(expressID, type, Dimensions, UnitType, Name, ConversionFactor);
  }
  ToTape() {
    let args = [];
    args.push(this.Dimensions);
    args.push(this.UnitType);
    args.push(this.Name);
    args.push(this.ConversionFactor);
    return args;
  }
};
var IfcConversionBasedUnitWithOffset = class {
  constructor(expressID, type, Dimensions, UnitType, Name, ConversionFactor, ConversionOffset) {
    this.expressID = expressID;
    this.type = type;
    this.Dimensions = Dimensions;
    this.UnitType = UnitType;
    this.Name = Name;
    this.ConversionFactor = ConversionFactor;
    this.ConversionOffset = ConversionOffset;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Dimensions = tape[ptr++];
    let UnitType = tape[ptr++];
    let Name = tape[ptr++];
    let ConversionFactor = tape[ptr++];
    let ConversionOffset = tape[ptr++];
    return new IfcConversionBasedUnitWithOffset(expressID, type, Dimensions, UnitType, Name, ConversionFactor, ConversionOffset);
  }
  ToTape() {
    let args = [];
    args.push(this.Dimensions);
    args.push(this.UnitType);
    args.push(this.Name);
    args.push(this.ConversionFactor);
    args.push(this.ConversionOffset);
    return args;
  }
};
var IfcCooledBeam = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCooledBeam(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCooledBeamType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCooledBeamType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCoolingTower = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCoolingTower(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCoolingTowerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCoolingTowerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCoordinateOperation = class {
  constructor(expressID, type, SourceCRS, TargetCRS) {
    this.expressID = expressID;
    this.type = type;
    this.SourceCRS = SourceCRS;
    this.TargetCRS = TargetCRS;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SourceCRS = tape[ptr++];
    let TargetCRS = tape[ptr++];
    return new IfcCoordinateOperation(expressID, type, SourceCRS, TargetCRS);
  }
  ToTape() {
    let args = [];
    args.push(this.SourceCRS);
    args.push(this.TargetCRS);
    return args;
  }
};
var IfcCoordinateReferenceSystem = class {
  constructor(expressID, type, Name, Description, GeodeticDatum, VerticalDatum) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.GeodeticDatum = GeodeticDatum;
    this.VerticalDatum = VerticalDatum;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let GeodeticDatum = tape[ptr++];
    let VerticalDatum = tape[ptr++];
    return new IfcCoordinateReferenceSystem(expressID, type, Name, Description, GeodeticDatum, VerticalDatum);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.GeodeticDatum);
    args.push(this.VerticalDatum);
    return args;
  }
};
var IfcCostItem = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, CostValues, CostQuantities) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.PredefinedType = PredefinedType;
    this.CostValues = CostValues;
    this.CostQuantities = CostQuantities;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let CostValues = tape[ptr++];
    let CostQuantities = tape[ptr++];
    return new IfcCostItem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, CostValues, CostQuantities);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.PredefinedType);
    args.push(this.CostValues);
    args.push(this.CostQuantities);
    return args;
  }
};
var IfcCostSchedule = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, SubmittedOn, UpdateDate) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.PredefinedType = PredefinedType;
    this.Status = Status;
    this.SubmittedOn = SubmittedOn;
    this.UpdateDate = UpdateDate;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Status = tape[ptr++];
    let SubmittedOn = tape[ptr++];
    let UpdateDate = tape[ptr++];
    return new IfcCostSchedule(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, SubmittedOn, UpdateDate);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.PredefinedType);
    args.push(this.Status);
    args.push(this.SubmittedOn);
    args.push(this.UpdateDate);
    return args;
  }
};
var IfcCostValue = class {
  constructor(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.AppliedValue = AppliedValue;
    this.UnitBasis = UnitBasis;
    this.ApplicableDate = ApplicableDate;
    this.FixedUntilDate = FixedUntilDate;
    this.Category = Category;
    this.Condition = Condition;
    this.ArithmeticOperator = ArithmeticOperator;
    this.Components = Components;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let AppliedValue = tape[ptr++];
    let UnitBasis = tape[ptr++];
    let ApplicableDate = tape[ptr++];
    let FixedUntilDate = tape[ptr++];
    let Category = tape[ptr++];
    let Condition = tape[ptr++];
    let ArithmeticOperator = tape[ptr++];
    let Components = tape[ptr++];
    return new IfcCostValue(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.AppliedValue);
    args.push(this.UnitBasis);
    args.push(this.ApplicableDate);
    args.push(this.FixedUntilDate);
    args.push(this.Category);
    args.push(this.Condition);
    args.push(this.ArithmeticOperator);
    args.push(this.Components);
    return args;
  }
};
var IfcCovering = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCovering(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCoveringType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCoveringType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCrewResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCrewResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.Usage);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCrewResourceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCrewResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ResourceType);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCsgPrimitive3D = class {
  constructor(expressID, type, Position) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    return new IfcCsgPrimitive3D(expressID, type, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    return args;
  }
};
var IfcCsgSolid = class {
  constructor(expressID, type, TreeRootExpression) {
    this.expressID = expressID;
    this.type = type;
    this.TreeRootExpression = TreeRootExpression;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TreeRootExpression = tape[ptr++];
    return new IfcCsgSolid(expressID, type, TreeRootExpression);
  }
  ToTape() {
    let args = [];
    args.push(this.TreeRootExpression);
    return args;
  }
};
var IfcCurrencyRelationship = class {
  constructor(expressID, type, Name, Description, RelatingMonetaryUnit, RelatedMonetaryUnit, ExchangeRate, RateDateTime, RateSource) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingMonetaryUnit = RelatingMonetaryUnit;
    this.RelatedMonetaryUnit = RelatedMonetaryUnit;
    this.ExchangeRate = ExchangeRate;
    this.RateDateTime = RateDateTime;
    this.RateSource = RateSource;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingMonetaryUnit = tape[ptr++];
    let RelatedMonetaryUnit = tape[ptr++];
    let ExchangeRate = tape[ptr++];
    let RateDateTime = tape[ptr++];
    let RateSource = tape[ptr++];
    return new IfcCurrencyRelationship(expressID, type, Name, Description, RelatingMonetaryUnit, RelatedMonetaryUnit, ExchangeRate, RateDateTime, RateSource);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingMonetaryUnit);
    args.push(this.RelatedMonetaryUnit);
    args.push(this.ExchangeRate);
    args.push(this.RateDateTime);
    args.push(this.RateSource);
    return args;
  }
};
var IfcCurtainWall = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCurtainWall(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCurtainWallType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCurtainWallType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCurve = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcCurve(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcCurveBoundedPlane = class {
  constructor(expressID, type, BasisSurface, OuterBoundary, InnerBoundaries) {
    this.expressID = expressID;
    this.type = type;
    this.BasisSurface = BasisSurface;
    this.OuterBoundary = OuterBoundary;
    this.InnerBoundaries = InnerBoundaries;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisSurface = tape[ptr++];
    let OuterBoundary = tape[ptr++];
    let InnerBoundaries = tape[ptr++];
    return new IfcCurveBoundedPlane(expressID, type, BasisSurface, OuterBoundary, InnerBoundaries);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisSurface);
    args.push(this.OuterBoundary);
    args.push(this.InnerBoundaries);
    return args;
  }
};
var IfcCurveBoundedSurface = class {
  constructor(expressID, type, BasisSurface, Boundaries, ImplicitOuter) {
    this.expressID = expressID;
    this.type = type;
    this.BasisSurface = BasisSurface;
    this.Boundaries = Boundaries;
    this.ImplicitOuter = ImplicitOuter;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisSurface = tape[ptr++];
    let Boundaries = tape[ptr++];
    let ImplicitOuter = tape[ptr++];
    return new IfcCurveBoundedSurface(expressID, type, BasisSurface, Boundaries, ImplicitOuter);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisSurface);
    args.push(this.Boundaries);
    args.push(this.ImplicitOuter);
    return args;
  }
};
var IfcCurveSegment2D = class {
  constructor(expressID, type, StartPoint, StartDirection, SegmentLength) {
    this.expressID = expressID;
    this.type = type;
    this.StartPoint = StartPoint;
    this.StartDirection = StartDirection;
    this.SegmentLength = SegmentLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartPoint = tape[ptr++];
    let StartDirection = tape[ptr++];
    let SegmentLength = tape[ptr++];
    return new IfcCurveSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength);
  }
  ToTape() {
    let args = [];
    args.push(this.StartPoint);
    args.push(this.StartDirection);
    args.push(this.SegmentLength);
    return args;
  }
};
var IfcCurveStyle = class {
  constructor(expressID, type, Name, CurveFont, CurveWidth, CurveColour, ModelOrDraughting) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.CurveFont = CurveFont;
    this.CurveWidth = CurveWidth;
    this.CurveColour = CurveColour;
    this.ModelOrDraughting = ModelOrDraughting;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let CurveFont = tape[ptr++];
    let CurveWidth = tape[ptr++];
    let CurveColour = tape[ptr++];
    let ModelOrDraughting = tape[ptr++];
    return new IfcCurveStyle(expressID, type, Name, CurveFont, CurveWidth, CurveColour, ModelOrDraughting);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.CurveFont);
    args.push(this.CurveWidth);
    args.push(this.CurveColour);
    args.push(this.ModelOrDraughting);
    return args;
  }
};
var IfcCurveStyleFont = class {
  constructor(expressID, type, Name, PatternList) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.PatternList = PatternList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let PatternList = tape[ptr++];
    return new IfcCurveStyleFont(expressID, type, Name, PatternList);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.PatternList);
    return args;
  }
};
var IfcCurveStyleFontAndScaling = class {
  constructor(expressID, type, Name, CurveFont, CurveFontScaling) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.CurveFont = CurveFont;
    this.CurveFontScaling = CurveFontScaling;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let CurveFont = tape[ptr++];
    let CurveFontScaling = tape[ptr++];
    return new IfcCurveStyleFontAndScaling(expressID, type, Name, CurveFont, CurveFontScaling);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.CurveFont);
    args.push(this.CurveFontScaling);
    return args;
  }
};
var IfcCurveStyleFontPattern = class {
  constructor(expressID, type, VisibleSegmentLength, InvisibleSegmentLength) {
    this.expressID = expressID;
    this.type = type;
    this.VisibleSegmentLength = VisibleSegmentLength;
    this.InvisibleSegmentLength = InvisibleSegmentLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let VisibleSegmentLength = tape[ptr++];
    let InvisibleSegmentLength = tape[ptr++];
    return new IfcCurveStyleFontPattern(expressID, type, VisibleSegmentLength, InvisibleSegmentLength);
  }
  ToTape() {
    let args = [];
    args.push(this.VisibleSegmentLength);
    args.push(this.InvisibleSegmentLength);
    return args;
  }
};
var IfcCylindricalSurface = class {
  constructor(expressID, type, Position, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcCylindricalSurface(expressID, type, Position, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    args.push(this.Radius);
    return args;
  }
};
var IfcDamper = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDamper(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDamperType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDamperType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDeepFoundation = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcDeepFoundation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcDeepFoundationType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcDeepFoundationType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcDerivedProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.ParentProfile = ParentProfile;
    this.Operator = Operator;
    this.Label = Label;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let ParentProfile = tape[ptr++];
    let Operator = tape[ptr++];
    let Label = tape[ptr++];
    return new IfcDerivedProfileDef(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.ParentProfile);
    args.push(this.Operator);
    args.push(this.Label);
    return args;
  }
};
var IfcDerivedUnit = class {
  constructor(expressID, type, Elements, UnitType, UserDefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.Elements = Elements;
    this.UnitType = UnitType;
    this.UserDefinedType = UserDefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Elements = tape[ptr++];
    let UnitType = tape[ptr++];
    let UserDefinedType = tape[ptr++];
    return new IfcDerivedUnit(expressID, type, Elements, UnitType, UserDefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.Elements);
    args.push(this.UnitType);
    args.push(this.UserDefinedType);
    return args;
  }
};
var IfcDerivedUnitElement = class {
  constructor(expressID, type, Unit, Exponent) {
    this.expressID = expressID;
    this.type = type;
    this.Unit = Unit;
    this.Exponent = Exponent;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Unit = tape[ptr++];
    let Exponent = tape[ptr++];
    return new IfcDerivedUnitElement(expressID, type, Unit, Exponent);
  }
  ToTape() {
    let args = [];
    args.push(this.Unit);
    args.push(this.Exponent);
    return args;
  }
};
var IfcDimensionalExponents = class {
  constructor(expressID, type, LengthExponent, MassExponent, TimeExponent, ElectricCurrentExponent, ThermodynamicTemperatureExponent, AmountOfSubstanceExponent, LuminousIntensityExponent) {
    this.expressID = expressID;
    this.type = type;
    this.LengthExponent = LengthExponent;
    this.MassExponent = MassExponent;
    this.TimeExponent = TimeExponent;
    this.ElectricCurrentExponent = ElectricCurrentExponent;
    this.ThermodynamicTemperatureExponent = ThermodynamicTemperatureExponent;
    this.AmountOfSubstanceExponent = AmountOfSubstanceExponent;
    this.LuminousIntensityExponent = LuminousIntensityExponent;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let LengthExponent = tape[ptr++];
    let MassExponent = tape[ptr++];
    let TimeExponent = tape[ptr++];
    let ElectricCurrentExponent = tape[ptr++];
    let ThermodynamicTemperatureExponent = tape[ptr++];
    let AmountOfSubstanceExponent = tape[ptr++];
    let LuminousIntensityExponent = tape[ptr++];
    return new IfcDimensionalExponents(expressID, type, LengthExponent, MassExponent, TimeExponent, ElectricCurrentExponent, ThermodynamicTemperatureExponent, AmountOfSubstanceExponent, LuminousIntensityExponent);
  }
  ToTape() {
    let args = [];
    args.push(this.LengthExponent);
    args.push(this.MassExponent);
    args.push(this.TimeExponent);
    args.push(this.ElectricCurrentExponent);
    args.push(this.ThermodynamicTemperatureExponent);
    args.push(this.AmountOfSubstanceExponent);
    args.push(this.LuminousIntensityExponent);
    return args;
  }
};
var IfcDirection = class {
  constructor(expressID, type, DirectionRatios) {
    this.expressID = expressID;
    this.type = type;
    this.DirectionRatios = DirectionRatios;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let DirectionRatios = tape[ptr++];
    return new IfcDirection(expressID, type, DirectionRatios);
  }
  ToTape() {
    let args = [];
    args.push(this.DirectionRatios);
    return args;
  }
};
var IfcDiscreteAccessory = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDiscreteAccessory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDiscreteAccessoryType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDiscreteAccessoryType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDistanceExpression = class {
  constructor(expressID, type, DistanceAlong, OffsetLateral, OffsetVertical, OffsetLongitudinal, AlongHorizontal) {
    this.expressID = expressID;
    this.type = type;
    this.DistanceAlong = DistanceAlong;
    this.OffsetLateral = OffsetLateral;
    this.OffsetVertical = OffsetVertical;
    this.OffsetLongitudinal = OffsetLongitudinal;
    this.AlongHorizontal = AlongHorizontal;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let DistanceAlong = tape[ptr++];
    let OffsetLateral = tape[ptr++];
    let OffsetVertical = tape[ptr++];
    let OffsetLongitudinal = tape[ptr++];
    let AlongHorizontal = tape[ptr++];
    return new IfcDistanceExpression(expressID, type, DistanceAlong, OffsetLateral, OffsetVertical, OffsetLongitudinal, AlongHorizontal);
  }
  ToTape() {
    let args = [];
    args.push(this.DistanceAlong);
    args.push(this.OffsetLateral);
    args.push(this.OffsetVertical);
    args.push(this.OffsetLongitudinal);
    args.push(this.AlongHorizontal);
    return args;
  }
};
var IfcDistributionChamberElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDistributionChamberElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDistributionChamberElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDistributionChamberElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDistributionCircuit = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDistributionCircuit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.LongName);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDistributionControlElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcDistributionControlElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcDistributionControlElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcDistributionControlElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcDistributionElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcDistributionElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcDistributionElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcDistributionElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcDistributionFlowElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcDistributionFlowElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcDistributionFlowElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcDistributionFlowElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcDistributionPort = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, FlowDirection, PredefinedType, SystemType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.FlowDirection = FlowDirection;
    this.PredefinedType = PredefinedType;
    this.SystemType = SystemType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let FlowDirection = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let SystemType = tape[ptr++];
    return new IfcDistributionPort(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, FlowDirection, PredefinedType, SystemType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.FlowDirection);
    args.push(this.PredefinedType);
    args.push(this.SystemType);
    return args;
  }
};
var IfcDistributionSystem = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDistributionSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.LongName);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDocumentInformation = class {
  constructor(expressID, type, Identification, Name, Description, Location, Purpose, IntendedUse, Scope, Revision, DocumentOwner, Editors, CreationTime, LastRevisionTime, ElectronicFormat, ValidFrom, ValidUntil, Confidentiality, Status) {
    this.expressID = expressID;
    this.type = type;
    this.Identification = Identification;
    this.Name = Name;
    this.Description = Description;
    this.Location = Location;
    this.Purpose = Purpose;
    this.IntendedUse = IntendedUse;
    this.Scope = Scope;
    this.Revision = Revision;
    this.DocumentOwner = DocumentOwner;
    this.Editors = Editors;
    this.CreationTime = CreationTime;
    this.LastRevisionTime = LastRevisionTime;
    this.ElectronicFormat = ElectronicFormat;
    this.ValidFrom = ValidFrom;
    this.ValidUntil = ValidUntil;
    this.Confidentiality = Confidentiality;
    this.Status = Status;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Location = tape[ptr++];
    let Purpose = tape[ptr++];
    let IntendedUse = tape[ptr++];
    let Scope = tape[ptr++];
    let Revision = tape[ptr++];
    let DocumentOwner = tape[ptr++];
    let Editors = tape[ptr++];
    let CreationTime = tape[ptr++];
    let LastRevisionTime = tape[ptr++];
    let ElectronicFormat = tape[ptr++];
    let ValidFrom = tape[ptr++];
    let ValidUntil = tape[ptr++];
    let Confidentiality = tape[ptr++];
    let Status = tape[ptr++];
    return new IfcDocumentInformation(expressID, type, Identification, Name, Description, Location, Purpose, IntendedUse, Scope, Revision, DocumentOwner, Editors, CreationTime, LastRevisionTime, ElectronicFormat, ValidFrom, ValidUntil, Confidentiality, Status);
  }
  ToTape() {
    let args = [];
    args.push(this.Identification);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Location);
    args.push(this.Purpose);
    args.push(this.IntendedUse);
    args.push(this.Scope);
    args.push(this.Revision);
    args.push(this.DocumentOwner);
    args.push(this.Editors);
    args.push(this.CreationTime);
    args.push(this.LastRevisionTime);
    args.push(this.ElectronicFormat);
    args.push(this.ValidFrom);
    args.push(this.ValidUntil);
    args.push(this.Confidentiality);
    args.push(this.Status);
    return args;
  }
};
var IfcDocumentInformationRelationship = class {
  constructor(expressID, type, Name, Description, RelatingDocument, RelatedDocuments, RelationshipType) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingDocument = RelatingDocument;
    this.RelatedDocuments = RelatedDocuments;
    this.RelationshipType = RelationshipType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingDocument = tape[ptr++];
    let RelatedDocuments = tape[ptr++];
    let RelationshipType = tape[ptr++];
    return new IfcDocumentInformationRelationship(expressID, type, Name, Description, RelatingDocument, RelatedDocuments, RelationshipType);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingDocument);
    args.push(this.RelatedDocuments);
    args.push(this.RelationshipType);
    return args;
  }
};
var IfcDocumentReference = class {
  constructor(expressID, type, Location, Identification, Name, Description, ReferencedDocument) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
    this.Description = Description;
    this.ReferencedDocument = ReferencedDocument;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ReferencedDocument = tape[ptr++];
    return new IfcDocumentReference(expressID, type, Location, Identification, Name, Description, ReferencedDocument);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    args.push(this.Identification);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ReferencedDocument);
    return args;
  }
};
var IfcDoor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.OverallHeight = OverallHeight;
    this.OverallWidth = OverallWidth;
    this.PredefinedType = PredefinedType;
    this.OperationType = OperationType;
    this.UserDefinedOperationType = UserDefinedOperationType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let OverallHeight = tape[ptr++];
    let OverallWidth = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let OperationType = tape[ptr++];
    let UserDefinedOperationType = tape[ptr++];
    return new IfcDoor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.OverallHeight);
    args.push(this.OverallWidth);
    args.push(this.PredefinedType);
    args.push(this.OperationType);
    args.push(this.UserDefinedOperationType);
    return args;
  }
};
var IfcDoorLiningProperties = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, ThresholdDepth, ThresholdThickness, TransomThickness, TransomOffset, LiningOffset, ThresholdOffset, CasingThickness, CasingDepth, ShapeAspectStyle, LiningToPanelOffsetX, LiningToPanelOffsetY) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.LiningDepth = LiningDepth;
    this.LiningThickness = LiningThickness;
    this.ThresholdDepth = ThresholdDepth;
    this.ThresholdThickness = ThresholdThickness;
    this.TransomThickness = TransomThickness;
    this.TransomOffset = TransomOffset;
    this.LiningOffset = LiningOffset;
    this.ThresholdOffset = ThresholdOffset;
    this.CasingThickness = CasingThickness;
    this.CasingDepth = CasingDepth;
    this.ShapeAspectStyle = ShapeAspectStyle;
    this.LiningToPanelOffsetX = LiningToPanelOffsetX;
    this.LiningToPanelOffsetY = LiningToPanelOffsetY;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let LiningDepth = tape[ptr++];
    let LiningThickness = tape[ptr++];
    let ThresholdDepth = tape[ptr++];
    let ThresholdThickness = tape[ptr++];
    let TransomThickness = tape[ptr++];
    let TransomOffset = tape[ptr++];
    let LiningOffset = tape[ptr++];
    let ThresholdOffset = tape[ptr++];
    let CasingThickness = tape[ptr++];
    let CasingDepth = tape[ptr++];
    let ShapeAspectStyle = tape[ptr++];
    let LiningToPanelOffsetX = tape[ptr++];
    let LiningToPanelOffsetY = tape[ptr++];
    return new IfcDoorLiningProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, ThresholdDepth, ThresholdThickness, TransomThickness, TransomOffset, LiningOffset, ThresholdOffset, CasingThickness, CasingDepth, ShapeAspectStyle, LiningToPanelOffsetX, LiningToPanelOffsetY);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.LiningDepth);
    args.push(this.LiningThickness);
    args.push(this.ThresholdDepth);
    args.push(this.ThresholdThickness);
    args.push(this.TransomThickness);
    args.push(this.TransomOffset);
    args.push(this.LiningOffset);
    args.push(this.ThresholdOffset);
    args.push(this.CasingThickness);
    args.push(this.CasingDepth);
    args.push(this.ShapeAspectStyle);
    args.push(this.LiningToPanelOffsetX);
    args.push(this.LiningToPanelOffsetY);
    return args;
  }
};
var IfcDoorPanelProperties = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, PanelDepth, PanelOperation, PanelWidth, PanelPosition, ShapeAspectStyle) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.PanelDepth = PanelDepth;
    this.PanelOperation = PanelOperation;
    this.PanelWidth = PanelWidth;
    this.PanelPosition = PanelPosition;
    this.ShapeAspectStyle = ShapeAspectStyle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let PanelDepth = tape[ptr++];
    let PanelOperation = tape[ptr++];
    let PanelWidth = tape[ptr++];
    let PanelPosition = tape[ptr++];
    let ShapeAspectStyle = tape[ptr++];
    return new IfcDoorPanelProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, PanelDepth, PanelOperation, PanelWidth, PanelPosition, ShapeAspectStyle);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.PanelDepth);
    args.push(this.PanelOperation);
    args.push(this.PanelWidth);
    args.push(this.PanelPosition);
    args.push(this.ShapeAspectStyle);
    return args;
  }
};
var IfcDoorStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.OverallHeight = OverallHeight;
    this.OverallWidth = OverallWidth;
    this.PredefinedType = PredefinedType;
    this.OperationType = OperationType;
    this.UserDefinedOperationType = UserDefinedOperationType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let OverallHeight = tape[ptr++];
    let OverallWidth = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let OperationType = tape[ptr++];
    let UserDefinedOperationType = tape[ptr++];
    return new IfcDoorStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.OverallHeight);
    args.push(this.OverallWidth);
    args.push(this.PredefinedType);
    args.push(this.OperationType);
    args.push(this.UserDefinedOperationType);
    return args;
  }
};
var IfcDoorStyle = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, OperationType, ConstructionType, ParameterTakesPrecedence, Sizeable) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.OperationType = OperationType;
    this.ConstructionType = ConstructionType;
    this.ParameterTakesPrecedence = ParameterTakesPrecedence;
    this.Sizeable = Sizeable;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let OperationType = tape[ptr++];
    let ConstructionType = tape[ptr++];
    let ParameterTakesPrecedence = tape[ptr++];
    let Sizeable = tape[ptr++];
    return new IfcDoorStyle(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, OperationType, ConstructionType, ParameterTakesPrecedence, Sizeable);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.OperationType);
    args.push(this.ConstructionType);
    args.push(this.ParameterTakesPrecedence);
    args.push(this.Sizeable);
    return args;
  }
};
var IfcDoorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, OperationType, ParameterTakesPrecedence, UserDefinedOperationType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.OperationType = OperationType;
    this.ParameterTakesPrecedence = ParameterTakesPrecedence;
    this.UserDefinedOperationType = UserDefinedOperationType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let OperationType = tape[ptr++];
    let ParameterTakesPrecedence = tape[ptr++];
    let UserDefinedOperationType = tape[ptr++];
    return new IfcDoorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, OperationType, ParameterTakesPrecedence, UserDefinedOperationType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    args.push(this.OperationType);
    args.push(this.ParameterTakesPrecedence);
    args.push(this.UserDefinedOperationType);
    return args;
  }
};
var IfcDraughtingPreDefinedColour = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcDraughtingPreDefinedColour(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcDraughtingPreDefinedCurveFont = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcDraughtingPreDefinedCurveFont(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcDuctFitting = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDuctFittingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDuctSegment = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDuctSegmentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDuctSilencer = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctSilencer(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDuctSilencerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctSilencerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcEdge = class {
  constructor(expressID, type, EdgeStart, EdgeEnd) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeStart = EdgeStart;
    this.EdgeEnd = EdgeEnd;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeStart = tape[ptr++];
    let EdgeEnd = tape[ptr++];
    return new IfcEdge(expressID, type, EdgeStart, EdgeEnd);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeStart);
    args.push(this.EdgeEnd);
    return args;
  }
};
var IfcEdgeCurve = class {
  constructor(expressID, type, EdgeStart, EdgeEnd, EdgeGeometry, SameSense) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeStart = EdgeStart;
    this.EdgeEnd = EdgeEnd;
    this.EdgeGeometry = EdgeGeometry;
    this.SameSense = SameSense;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeStart = tape[ptr++];
    let EdgeEnd = tape[ptr++];
    let EdgeGeometry = tape[ptr++];
    let SameSense = tape[ptr++];
    return new IfcEdgeCurve(expressID, type, EdgeStart, EdgeEnd, EdgeGeometry, SameSense);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeStart);
    args.push(this.EdgeEnd);
    args.push(this.EdgeGeometry);
    args.push(this.SameSense);
    return args;
  }
};
var IfcEdgeLoop = class {
  constructor(expressID, type, EdgeList) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeList = EdgeList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeList = tape[ptr++];
    return new IfcEdgeLoop(expressID, type, EdgeList);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeList);
    return args;
  }
};
var IfcElectricAppliance = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricApplianceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricDistributionBoard = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricDistributionBoard(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricDistributionBoardType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricDistributionBoardType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricFlowStorageDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricFlowStorageDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricFlowStorageDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricFlowStorageDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricGenerator = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricGenerator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricGeneratorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricGeneratorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricMotor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricMotor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricMotorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricMotorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricTimeControl = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricTimeControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricTimeControlType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricTimeControlType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcElementAssembly = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, AssemblyPlace, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.AssemblyPlace = AssemblyPlace;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let AssemblyPlace = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElementAssembly(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, AssemblyPlace, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.AssemblyPlace);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElementAssemblyType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElementAssemblyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElementComponent = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcElementComponent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcElementComponentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcElementComponentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcElementQuantity = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, MethodOfMeasurement, Quantities) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.MethodOfMeasurement = MethodOfMeasurement;
    this.Quantities = Quantities;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let MethodOfMeasurement = tape[ptr++];
    let Quantities = tape[ptr++];
    return new IfcElementQuantity(expressID, type, GlobalId, OwnerHistory, Name, Description, MethodOfMeasurement, Quantities);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.MethodOfMeasurement);
    args.push(this.Quantities);
    return args;
  }
};
var IfcElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcElementarySurface = class {
  constructor(expressID, type, Position) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    return new IfcElementarySurface(expressID, type, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    return args;
  }
};
var IfcEllipse = class {
  constructor(expressID, type, Position, SemiAxis1, SemiAxis2) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.SemiAxis1 = SemiAxis1;
    this.SemiAxis2 = SemiAxis2;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let SemiAxis1 = tape[ptr++];
    let SemiAxis2 = tape[ptr++];
    return new IfcEllipse(expressID, type, Position, SemiAxis1, SemiAxis2);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    args.push(this.SemiAxis1);
    args.push(this.SemiAxis2);
    return args;
  }
};
var IfcEllipseProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, SemiAxis1, SemiAxis2) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.SemiAxis1 = SemiAxis1;
    this.SemiAxis2 = SemiAxis2;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let SemiAxis1 = tape[ptr++];
    let SemiAxis2 = tape[ptr++];
    return new IfcEllipseProfileDef(expressID, type, ProfileType, ProfileName, Position, SemiAxis1, SemiAxis2);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.SemiAxis1);
    args.push(this.SemiAxis2);
    return args;
  }
};
var IfcEnergyConversionDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcEnergyConversionDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcEnergyConversionDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcEnergyConversionDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcEngine = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEngine(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcEngineType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEngineType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcEvaporativeCooler = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEvaporativeCooler(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcEvaporativeCoolerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEvaporativeCoolerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcEvaporator = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEvaporator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcEvaporatorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEvaporatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcEvent = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType, EventTriggerType, UserDefinedEventTriggerType, EventOccurenceTime) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.PredefinedType = PredefinedType;
    this.EventTriggerType = EventTriggerType;
    this.UserDefinedEventTriggerType = UserDefinedEventTriggerType;
    this.EventOccurenceTime = EventOccurenceTime;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let EventTriggerType = tape[ptr++];
    let UserDefinedEventTriggerType = tape[ptr++];
    let EventOccurenceTime = tape[ptr++];
    return new IfcEvent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType, EventTriggerType, UserDefinedEventTriggerType, EventOccurenceTime);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.PredefinedType);
    args.push(this.EventTriggerType);
    args.push(this.UserDefinedEventTriggerType);
    args.push(this.EventOccurenceTime);
    return args;
  }
};
var IfcEventTime = class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ActualDate, EarlyDate, LateDate, ScheduleDate) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.ActualDate = ActualDate;
    this.EarlyDate = EarlyDate;
    this.LateDate = LateDate;
    this.ScheduleDate = ScheduleDate;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let ActualDate = tape[ptr++];
    let EarlyDate = tape[ptr++];
    let LateDate = tape[ptr++];
    let ScheduleDate = tape[ptr++];
    return new IfcEventTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ActualDate, EarlyDate, LateDate, ScheduleDate);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.DataOrigin);
    args.push(this.UserDefinedDataOrigin);
    args.push(this.ActualDate);
    args.push(this.EarlyDate);
    args.push(this.LateDate);
    args.push(this.ScheduleDate);
    return args;
  }
};
var IfcEventType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, EventTriggerType, UserDefinedEventTriggerType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ProcessType = ProcessType;
    this.PredefinedType = PredefinedType;
    this.EventTriggerType = EventTriggerType;
    this.UserDefinedEventTriggerType = UserDefinedEventTriggerType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ProcessType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let EventTriggerType = tape[ptr++];
    let UserDefinedEventTriggerType = tape[ptr++];
    return new IfcEventType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, EventTriggerType, UserDefinedEventTriggerType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ProcessType);
    args.push(this.PredefinedType);
    args.push(this.EventTriggerType);
    args.push(this.UserDefinedEventTriggerType);
    return args;
  }
};
var IfcExtendedProperties = class {
  constructor(expressID, type, Name, Description, Properties2) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Properties = Properties2;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Properties2 = tape[ptr++];
    return new IfcExtendedProperties(expressID, type, Name, Description, Properties2);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Properties);
    return args;
  }
};
var IfcExternalInformation = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcExternalInformation(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcExternalReference = class {
  constructor(expressID, type, Location, Identification, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcExternalReference(expressID, type, Location, Identification, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    args.push(this.Identification);
    args.push(this.Name);
    return args;
  }
};
var IfcExternalReferenceRelationship = class {
  constructor(expressID, type, Name, Description, RelatingReference, RelatedResourceObjects) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingReference = RelatingReference;
    this.RelatedResourceObjects = RelatedResourceObjects;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingReference = tape[ptr++];
    let RelatedResourceObjects = tape[ptr++];
    return new IfcExternalReferenceRelationship(expressID, type, Name, Description, RelatingReference, RelatedResourceObjects);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingReference);
    args.push(this.RelatedResourceObjects);
    return args;
  }
};
var IfcExternalSpatialElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcExternalSpatialElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcExternalSpatialStructureElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcExternalSpatialStructureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    return args;
  }
};
var IfcExternallyDefinedHatchStyle = class {
  constructor(expressID, type, Location, Identification, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcExternallyDefinedHatchStyle(expressID, type, Location, Identification, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    args.push(this.Identification);
    args.push(this.Name);
    return args;
  }
};
var IfcExternallyDefinedSurfaceStyle = class {
  constructor(expressID, type, Location, Identification, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcExternallyDefinedSurfaceStyle(expressID, type, Location, Identification, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    args.push(this.Identification);
    args.push(this.Name);
    return args;
  }
};
var IfcExternallyDefinedTextFont = class {
  constructor(expressID, type, Location, Identification, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcExternallyDefinedTextFont(expressID, type, Location, Identification, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    args.push(this.Identification);
    args.push(this.Name);
    return args;
  }
};
var IfcExtrudedAreaSolid = class {
  constructor(expressID, type, SweptArea, Position, ExtrudedDirection, Depth) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.ExtrudedDirection = ExtrudedDirection;
    this.Depth = Depth;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let ExtrudedDirection = tape[ptr++];
    let Depth = tape[ptr++];
    return new IfcExtrudedAreaSolid(expressID, type, SweptArea, Position, ExtrudedDirection, Depth);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    args.push(this.Position);
    args.push(this.ExtrudedDirection);
    args.push(this.Depth);
    return args;
  }
};
var IfcExtrudedAreaSolidTapered = class {
  constructor(expressID, type, SweptArea, Position, ExtrudedDirection, Depth, EndSweptArea) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.ExtrudedDirection = ExtrudedDirection;
    this.Depth = Depth;
    this.EndSweptArea = EndSweptArea;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let ExtrudedDirection = tape[ptr++];
    let Depth = tape[ptr++];
    let EndSweptArea = tape[ptr++];
    return new IfcExtrudedAreaSolidTapered(expressID, type, SweptArea, Position, ExtrudedDirection, Depth, EndSweptArea);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    args.push(this.Position);
    args.push(this.ExtrudedDirection);
    args.push(this.Depth);
    args.push(this.EndSweptArea);
    return args;
  }
};
var IfcFace = class {
  constructor(expressID, type, Bounds) {
    this.expressID = expressID;
    this.type = type;
    this.Bounds = Bounds;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Bounds = tape[ptr++];
    return new IfcFace(expressID, type, Bounds);
  }
  ToTape() {
    let args = [];
    args.push(this.Bounds);
    return args;
  }
};
var IfcFaceBasedSurfaceModel = class {
  constructor(expressID, type, FbsmFaces) {
    this.expressID = expressID;
    this.type = type;
    this.FbsmFaces = FbsmFaces;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let FbsmFaces = tape[ptr++];
    return new IfcFaceBasedSurfaceModel(expressID, type, FbsmFaces);
  }
  ToTape() {
    let args = [];
    args.push(this.FbsmFaces);
    return args;
  }
};
var IfcFaceBound = class {
  constructor(expressID, type, Bound, Orientation) {
    this.expressID = expressID;
    this.type = type;
    this.Bound = Bound;
    this.Orientation = Orientation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Bound = tape[ptr++];
    let Orientation = tape[ptr++];
    return new IfcFaceBound(expressID, type, Bound, Orientation);
  }
  ToTape() {
    let args = [];
    args.push(this.Bound);
    args.push(this.Orientation);
    return args;
  }
};
var IfcFaceOuterBound = class {
  constructor(expressID, type, Bound, Orientation) {
    this.expressID = expressID;
    this.type = type;
    this.Bound = Bound;
    this.Orientation = Orientation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Bound = tape[ptr++];
    let Orientation = tape[ptr++];
    return new IfcFaceOuterBound(expressID, type, Bound, Orientation);
  }
  ToTape() {
    let args = [];
    args.push(this.Bound);
    args.push(this.Orientation);
    return args;
  }
};
var IfcFaceSurface = class {
  constructor(expressID, type, Bounds, FaceSurface, SameSense) {
    this.expressID = expressID;
    this.type = type;
    this.Bounds = Bounds;
    this.FaceSurface = FaceSurface;
    this.SameSense = SameSense;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Bounds = tape[ptr++];
    let FaceSurface = tape[ptr++];
    let SameSense = tape[ptr++];
    return new IfcFaceSurface(expressID, type, Bounds, FaceSurface, SameSense);
  }
  ToTape() {
    let args = [];
    args.push(this.Bounds);
    args.push(this.FaceSurface);
    args.push(this.SameSense);
    return args;
  }
};
var IfcFacetedBrep = class {
  constructor(expressID, type, Outer) {
    this.expressID = expressID;
    this.type = type;
    this.Outer = Outer;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Outer = tape[ptr++];
    return new IfcFacetedBrep(expressID, type, Outer);
  }
  ToTape() {
    let args = [];
    args.push(this.Outer);
    return args;
  }
};
var IfcFacetedBrepWithVoids = class {
  constructor(expressID, type, Outer, Voids) {
    this.expressID = expressID;
    this.type = type;
    this.Outer = Outer;
    this.Voids = Voids;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Outer = tape[ptr++];
    let Voids = tape[ptr++];
    return new IfcFacetedBrepWithVoids(expressID, type, Outer, Voids);
  }
  ToTape() {
    let args = [];
    args.push(this.Outer);
    args.push(this.Voids);
    return args;
  }
};
var IfcFacility = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    return new IfcFacility(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.CompositionType);
    return args;
  }
};
var IfcFacilityPart = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    return new IfcFacilityPart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.CompositionType);
    return args;
  }
};
var IfcFailureConnectionCondition = class {
  constructor(expressID, type, Name, TensionFailureX, TensionFailureY, TensionFailureZ, CompressionFailureX, CompressionFailureY, CompressionFailureZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TensionFailureX = TensionFailureX;
    this.TensionFailureY = TensionFailureY;
    this.TensionFailureZ = TensionFailureZ;
    this.CompressionFailureX = CompressionFailureX;
    this.CompressionFailureY = CompressionFailureY;
    this.CompressionFailureZ = CompressionFailureZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TensionFailureX = tape[ptr++];
    let TensionFailureY = tape[ptr++];
    let TensionFailureZ = tape[ptr++];
    let CompressionFailureX = tape[ptr++];
    let CompressionFailureY = tape[ptr++];
    let CompressionFailureZ = tape[ptr++];
    return new IfcFailureConnectionCondition(expressID, type, Name, TensionFailureX, TensionFailureY, TensionFailureZ, CompressionFailureX, CompressionFailureY, CompressionFailureZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.TensionFailureX);
    args.push(this.TensionFailureY);
    args.push(this.TensionFailureZ);
    args.push(this.CompressionFailureX);
    args.push(this.CompressionFailureY);
    args.push(this.CompressionFailureZ);
    return args;
  }
};
var IfcFan = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFan(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFanType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFanType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFastener = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFastener(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFastenerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFastenerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFeatureElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFeatureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFeatureElementAddition = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFeatureElementAddition(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFeatureElementSubtraction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFeatureElementSubtraction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFillAreaStyle = class {
  constructor(expressID, type, Name, FillStyles, ModelorDraughting) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.FillStyles = FillStyles;
    this.ModelorDraughting = ModelorDraughting;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let FillStyles = tape[ptr++];
    let ModelorDraughting = tape[ptr++];
    return new IfcFillAreaStyle(expressID, type, Name, FillStyles, ModelorDraughting);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.FillStyles);
    args.push(this.ModelorDraughting);
    return args;
  }
};
var IfcFillAreaStyleHatching = class {
  constructor(expressID, type, HatchLineAppearance, StartOfNextHatchLine, PointOfReferenceHatchLine, PatternStart, HatchLineAngle) {
    this.expressID = expressID;
    this.type = type;
    this.HatchLineAppearance = HatchLineAppearance;
    this.StartOfNextHatchLine = StartOfNextHatchLine;
    this.PointOfReferenceHatchLine = PointOfReferenceHatchLine;
    this.PatternStart = PatternStart;
    this.HatchLineAngle = HatchLineAngle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let HatchLineAppearance = tape[ptr++];
    let StartOfNextHatchLine = tape[ptr++];
    let PointOfReferenceHatchLine = tape[ptr++];
    let PatternStart = tape[ptr++];
    let HatchLineAngle = tape[ptr++];
    return new IfcFillAreaStyleHatching(expressID, type, HatchLineAppearance, StartOfNextHatchLine, PointOfReferenceHatchLine, PatternStart, HatchLineAngle);
  }
  ToTape() {
    let args = [];
    args.push(this.HatchLineAppearance);
    args.push(this.StartOfNextHatchLine);
    args.push(this.PointOfReferenceHatchLine);
    args.push(this.PatternStart);
    args.push(this.HatchLineAngle);
    return args;
  }
};
var IfcFillAreaStyleTiles = class {
  constructor(expressID, type, TilingPattern, Tiles, TilingScale) {
    this.expressID = expressID;
    this.type = type;
    this.TilingPattern = TilingPattern;
    this.Tiles = Tiles;
    this.TilingScale = TilingScale;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TilingPattern = tape[ptr++];
    let Tiles = tape[ptr++];
    let TilingScale = tape[ptr++];
    return new IfcFillAreaStyleTiles(expressID, type, TilingPattern, Tiles, TilingScale);
  }
  ToTape() {
    let args = [];
    args.push(this.TilingPattern);
    args.push(this.Tiles);
    args.push(this.TilingScale);
    return args;
  }
};
var IfcFilter = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFilter(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFilterType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFilterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFireSuppressionTerminal = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFireSuppressionTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFireSuppressionTerminalType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFireSuppressionTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFixedReferenceSweptAreaSolid = class {
  constructor(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, FixedReference) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.Directrix = Directrix;
    this.StartParam = StartParam;
    this.EndParam = EndParam;
    this.FixedReference = FixedReference;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let Directrix = tape[ptr++];
    let StartParam = tape[ptr++];
    let EndParam = tape[ptr++];
    let FixedReference = tape[ptr++];
    return new IfcFixedReferenceSweptAreaSolid(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, FixedReference);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    args.push(this.Position);
    args.push(this.Directrix);
    args.push(this.StartParam);
    args.push(this.EndParam);
    args.push(this.FixedReference);
    return args;
  }
};
var IfcFlowController = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowController(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFlowControllerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowControllerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcFlowFitting = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFlowFittingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcFlowInstrument = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFlowInstrument(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFlowInstrumentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFlowInstrumentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFlowMeter = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFlowMeter(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFlowMeterType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFlowMeterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFlowMovingDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowMovingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFlowMovingDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowMovingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcFlowSegment = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFlowSegmentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcFlowStorageDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowStorageDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFlowStorageDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowStorageDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcFlowTerminal = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFlowTerminalType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcFlowTreatmentDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowTreatmentDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFlowTreatmentDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowTreatmentDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcFooting = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFooting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFootingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFootingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFurnishingElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFurnishingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFurnishingElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFurnishingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcFurniture = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFurniture(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFurnitureType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, AssemblyPlace, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.AssemblyPlace = AssemblyPlace;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let AssemblyPlace = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFurnitureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, AssemblyPlace, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.AssemblyPlace);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcGeographicElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcGeographicElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcGeographicElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcGeographicElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcGeometricCurveSet = class {
  constructor(expressID, type, Elements) {
    this.expressID = expressID;
    this.type = type;
    this.Elements = Elements;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Elements = tape[ptr++];
    return new IfcGeometricCurveSet(expressID, type, Elements);
  }
  ToTape() {
    let args = [];
    args.push(this.Elements);
    return args;
  }
};
var IfcGeometricRepresentationContext = class {
  constructor(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth) {
    this.expressID = expressID;
    this.type = type;
    this.ContextIdentifier = ContextIdentifier;
    this.ContextType = ContextType;
    this.CoordinateSpaceDimension = CoordinateSpaceDimension;
    this.Precision = Precision;
    this.WorldCoordinateSystem = WorldCoordinateSystem;
    this.TrueNorth = TrueNorth;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextIdentifier = tape[ptr++];
    let ContextType = tape[ptr++];
    let CoordinateSpaceDimension = tape[ptr++];
    let Precision = tape[ptr++];
    let WorldCoordinateSystem = tape[ptr++];
    let TrueNorth = tape[ptr++];
    return new IfcGeometricRepresentationContext(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextIdentifier);
    args.push(this.ContextType);
    args.push(this.CoordinateSpaceDimension);
    args.push(this.Precision);
    args.push(this.WorldCoordinateSystem);
    args.push(this.TrueNorth);
    return args;
  }
};
var IfcGeometricRepresentationItem = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcGeometricRepresentationItem(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcGeometricRepresentationSubContext = class {
  constructor(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth, ParentContext, TargetScale, TargetView, UserDefinedTargetView) {
    this.expressID = expressID;
    this.type = type;
    this.ContextIdentifier = ContextIdentifier;
    this.ContextType = ContextType;
    this.CoordinateSpaceDimension = CoordinateSpaceDimension;
    this.Precision = Precision;
    this.WorldCoordinateSystem = WorldCoordinateSystem;
    this.TrueNorth = TrueNorth;
    this.ParentContext = ParentContext;
    this.TargetScale = TargetScale;
    this.TargetView = TargetView;
    this.UserDefinedTargetView = UserDefinedTargetView;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextIdentifier = tape[ptr++];
    let ContextType = tape[ptr++];
    let CoordinateSpaceDimension = tape[ptr++];
    let Precision = tape[ptr++];
    let WorldCoordinateSystem = tape[ptr++];
    let TrueNorth = tape[ptr++];
    let ParentContext = tape[ptr++];
    let TargetScale = tape[ptr++];
    let TargetView = tape[ptr++];
    let UserDefinedTargetView = tape[ptr++];
    return new IfcGeometricRepresentationSubContext(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth, ParentContext, TargetScale, TargetView, UserDefinedTargetView);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextIdentifier);
    args.push(this.ContextType);
    args.push(this.CoordinateSpaceDimension);
    args.push(this.Precision);
    args.push(this.WorldCoordinateSystem);
    args.push(this.TrueNorth);
    args.push(this.ParentContext);
    args.push(this.TargetScale);
    args.push(this.TargetView);
    args.push(this.UserDefinedTargetView);
    return args;
  }
};
var IfcGeometricSet = class {
  constructor(expressID, type, Elements) {
    this.expressID = expressID;
    this.type = type;
    this.Elements = Elements;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Elements = tape[ptr++];
    return new IfcGeometricSet(expressID, type, Elements);
  }
  ToTape() {
    let args = [];
    args.push(this.Elements);
    return args;
  }
};
var IfcGrid = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, UAxes, VAxes, WAxes, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.UAxes = UAxes;
    this.VAxes = VAxes;
    this.WAxes = WAxes;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let UAxes = tape[ptr++];
    let VAxes = tape[ptr++];
    let WAxes = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcGrid(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, UAxes, VAxes, WAxes, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.UAxes);
    args.push(this.VAxes);
    args.push(this.WAxes);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcGridAxis = class {
  constructor(expressID, type, AxisTag, AxisCurve, SameSense) {
    this.expressID = expressID;
    this.type = type;
    this.AxisTag = AxisTag;
    this.AxisCurve = AxisCurve;
    this.SameSense = SameSense;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let AxisTag = tape[ptr++];
    let AxisCurve = tape[ptr++];
    let SameSense = tape[ptr++];
    return new IfcGridAxis(expressID, type, AxisTag, AxisCurve, SameSense);
  }
  ToTape() {
    let args = [];
    args.push(this.AxisTag);
    args.push(this.AxisCurve);
    args.push(this.SameSense);
    return args;
  }
};
var IfcGridPlacement = class {
  constructor(expressID, type, PlacementRelTo, PlacementLocation, PlacementRefDirection) {
    this.expressID = expressID;
    this.type = type;
    this.PlacementRelTo = PlacementRelTo;
    this.PlacementLocation = PlacementLocation;
    this.PlacementRefDirection = PlacementRefDirection;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PlacementRelTo = tape[ptr++];
    let PlacementLocation = tape[ptr++];
    let PlacementRefDirection = tape[ptr++];
    return new IfcGridPlacement(expressID, type, PlacementRelTo, PlacementLocation, PlacementRefDirection);
  }
  ToTape() {
    let args = [];
    args.push(this.PlacementRelTo);
    args.push(this.PlacementLocation);
    args.push(this.PlacementRefDirection);
    return args;
  }
};
var IfcGroup = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    return new IfcGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    return args;
  }
};
var IfcHalfSpaceSolid = class {
  constructor(expressID, type, BaseSurface, AgreementFlag) {
    this.expressID = expressID;
    this.type = type;
    this.BaseSurface = BaseSurface;
    this.AgreementFlag = AgreementFlag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BaseSurface = tape[ptr++];
    let AgreementFlag = tape[ptr++];
    return new IfcHalfSpaceSolid(expressID, type, BaseSurface, AgreementFlag);
  }
  ToTape() {
    let args = [];
    args.push(this.BaseSurface);
    args.push(this.AgreementFlag);
    return args;
  }
};
var IfcHeatExchanger = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcHeatExchanger(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcHeatExchangerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcHeatExchangerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcHumidifier = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcHumidifier(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcHumidifierType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcHumidifierType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcIShapeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, OverallWidth, OverallDepth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, FlangeSlope) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.OverallWidth = OverallWidth;
    this.OverallDepth = OverallDepth;
    this.WebThickness = WebThickness;
    this.FlangeThickness = FlangeThickness;
    this.FilletRadius = FilletRadius;
    this.FlangeEdgeRadius = FlangeEdgeRadius;
    this.FlangeSlope = FlangeSlope;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let OverallWidth = tape[ptr++];
    let OverallDepth = tape[ptr++];
    let WebThickness = tape[ptr++];
    let FlangeThickness = tape[ptr++];
    let FilletRadius = tape[ptr++];
    let FlangeEdgeRadius = tape[ptr++];
    let FlangeSlope = tape[ptr++];
    return new IfcIShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, OverallWidth, OverallDepth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, FlangeSlope);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.OverallWidth);
    args.push(this.OverallDepth);
    args.push(this.WebThickness);
    args.push(this.FlangeThickness);
    args.push(this.FilletRadius);
    args.push(this.FlangeEdgeRadius);
    args.push(this.FlangeSlope);
    return args;
  }
};
var IfcImageTexture = class {
  constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, URLReference) {
    this.expressID = expressID;
    this.type = type;
    this.RepeatS = RepeatS;
    this.RepeatT = RepeatT;
    this.Mode = Mode;
    this.TextureTransform = TextureTransform;
    this.Parameter = Parameter;
    this.URLReference = URLReference;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RepeatS = tape[ptr++];
    let RepeatT = tape[ptr++];
    let Mode = tape[ptr++];
    let TextureTransform = tape[ptr++];
    let Parameter = tape[ptr++];
    let URLReference = tape[ptr++];
    return new IfcImageTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, URLReference);
  }
  ToTape() {
    let args = [];
    args.push(this.RepeatS);
    args.push(this.RepeatT);
    args.push(this.Mode);
    args.push(this.TextureTransform);
    args.push(this.Parameter);
    args.push(this.URLReference);
    return args;
  }
};
var IfcIndexedColourMap = class {
  constructor(expressID, type, MappedTo, Opacity, Colours, ColourIndex) {
    this.expressID = expressID;
    this.type = type;
    this.MappedTo = MappedTo;
    this.Opacity = Opacity;
    this.Colours = Colours;
    this.ColourIndex = ColourIndex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MappedTo = tape[ptr++];
    let Opacity = tape[ptr++];
    let Colours = tape[ptr++];
    let ColourIndex = tape[ptr++];
    return new IfcIndexedColourMap(expressID, type, MappedTo, Opacity, Colours, ColourIndex);
  }
  ToTape() {
    let args = [];
    args.push(this.MappedTo);
    args.push(this.Opacity);
    args.push(this.Colours);
    args.push(this.ColourIndex);
    return args;
  }
};
var IfcIndexedPolyCurve = class {
  constructor(expressID, type, Points, Segments, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Points = Points;
    this.Segments = Segments;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Points = tape[ptr++];
    let Segments = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcIndexedPolyCurve(expressID, type, Points, Segments, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Points);
    args.push(this.Segments);
    args.push(this.SelfIntersect);
    return args;
  }
};
var IfcIndexedPolygonalFace = class {
  constructor(expressID, type, CoordIndex) {
    this.expressID = expressID;
    this.type = type;
    this.CoordIndex = CoordIndex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CoordIndex = tape[ptr++];
    return new IfcIndexedPolygonalFace(expressID, type, CoordIndex);
  }
  ToTape() {
    let args = [];
    args.push(this.CoordIndex);
    return args;
  }
};
var IfcIndexedPolygonalFaceWithVoids = class {
  constructor(expressID, type, CoordIndex, InnerCoordIndices) {
    this.expressID = expressID;
    this.type = type;
    this.CoordIndex = CoordIndex;
    this.InnerCoordIndices = InnerCoordIndices;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CoordIndex = tape[ptr++];
    let InnerCoordIndices = tape[ptr++];
    return new IfcIndexedPolygonalFaceWithVoids(expressID, type, CoordIndex, InnerCoordIndices);
  }
  ToTape() {
    let args = [];
    args.push(this.CoordIndex);
    args.push(this.InnerCoordIndices);
    return args;
  }
};
var IfcIndexedTextureMap = class {
  constructor(expressID, type, Maps, MappedTo, TexCoords) {
    this.expressID = expressID;
    this.type = type;
    this.Maps = Maps;
    this.MappedTo = MappedTo;
    this.TexCoords = TexCoords;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Maps = tape[ptr++];
    let MappedTo = tape[ptr++];
    let TexCoords = tape[ptr++];
    return new IfcIndexedTextureMap(expressID, type, Maps, MappedTo, TexCoords);
  }
  ToTape() {
    let args = [];
    args.push(this.Maps);
    args.push(this.MappedTo);
    args.push(this.TexCoords);
    return args;
  }
};
var IfcIndexedTriangleTextureMap = class {
  constructor(expressID, type, Maps, MappedTo, TexCoords, TexCoordIndex) {
    this.expressID = expressID;
    this.type = type;
    this.Maps = Maps;
    this.MappedTo = MappedTo;
    this.TexCoords = TexCoords;
    this.TexCoordIndex = TexCoordIndex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Maps = tape[ptr++];
    let MappedTo = tape[ptr++];
    let TexCoords = tape[ptr++];
    let TexCoordIndex = tape[ptr++];
    return new IfcIndexedTriangleTextureMap(expressID, type, Maps, MappedTo, TexCoords, TexCoordIndex);
  }
  ToTape() {
    let args = [];
    args.push(this.Maps);
    args.push(this.MappedTo);
    args.push(this.TexCoords);
    args.push(this.TexCoordIndex);
    return args;
  }
};
var IfcInterceptor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcInterceptor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcInterceptorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcInterceptorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcIntersectionCurve = class {
  constructor(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation) {
    this.expressID = expressID;
    this.type = type;
    this.Curve3D = Curve3D;
    this.AssociatedGeometry = AssociatedGeometry;
    this.MasterRepresentation = MasterRepresentation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Curve3D = tape[ptr++];
    let AssociatedGeometry = tape[ptr++];
    let MasterRepresentation = tape[ptr++];
    return new IfcIntersectionCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation);
  }
  ToTape() {
    let args = [];
    args.push(this.Curve3D);
    args.push(this.AssociatedGeometry);
    args.push(this.MasterRepresentation);
    return args;
  }
};
var IfcInventory = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, Jurisdiction, ResponsiblePersons, LastUpdateDate, CurrentValue, OriginalValue) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.PredefinedType = PredefinedType;
    this.Jurisdiction = Jurisdiction;
    this.ResponsiblePersons = ResponsiblePersons;
    this.LastUpdateDate = LastUpdateDate;
    this.CurrentValue = CurrentValue;
    this.OriginalValue = OriginalValue;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Jurisdiction = tape[ptr++];
    let ResponsiblePersons = tape[ptr++];
    let LastUpdateDate = tape[ptr++];
    let CurrentValue = tape[ptr++];
    let OriginalValue = tape[ptr++];
    return new IfcInventory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, Jurisdiction, ResponsiblePersons, LastUpdateDate, CurrentValue, OriginalValue);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.PredefinedType);
    args.push(this.Jurisdiction);
    args.push(this.ResponsiblePersons);
    args.push(this.LastUpdateDate);
    args.push(this.CurrentValue);
    args.push(this.OriginalValue);
    return args;
  }
};
var IfcIrregularTimeSeries = class {
  constructor(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, Values) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.StartTime = StartTime;
    this.EndTime = EndTime;
    this.TimeSeriesDataType = TimeSeriesDataType;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.Unit = Unit;
    this.Values = Values;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let StartTime = tape[ptr++];
    let EndTime = tape[ptr++];
    let TimeSeriesDataType = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let Unit = tape[ptr++];
    let Values = tape[ptr++];
    return new IfcIrregularTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, Values);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.StartTime);
    args.push(this.EndTime);
    args.push(this.TimeSeriesDataType);
    args.push(this.DataOrigin);
    args.push(this.UserDefinedDataOrigin);
    args.push(this.Unit);
    args.push(this.Values);
    return args;
  }
};
var IfcIrregularTimeSeriesValue = class {
  constructor(expressID, type, TimeStamp, ListValues) {
    this.expressID = expressID;
    this.type = type;
    this.TimeStamp = TimeStamp;
    this.ListValues = ListValues;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TimeStamp = tape[ptr++];
    let ListValues = tape[ptr++];
    return new IfcIrregularTimeSeriesValue(expressID, type, TimeStamp, ListValues);
  }
  ToTape() {
    let args = [];
    args.push(this.TimeStamp);
    args.push(this.ListValues);
    return args;
  }
};
var IfcJunctionBox = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcJunctionBox(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcJunctionBoxType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcJunctionBoxType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcLShapeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Depth, Width, Thickness, FilletRadius, EdgeRadius, LegSlope) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Depth = Depth;
    this.Width = Width;
    this.Thickness = Thickness;
    this.FilletRadius = FilletRadius;
    this.EdgeRadius = EdgeRadius;
    this.LegSlope = LegSlope;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Depth = tape[ptr++];
    let Width = tape[ptr++];
    let Thickness = tape[ptr++];
    let FilletRadius = tape[ptr++];
    let EdgeRadius = tape[ptr++];
    let LegSlope = tape[ptr++];
    return new IfcLShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, Width, Thickness, FilletRadius, EdgeRadius, LegSlope);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.Depth);
    args.push(this.Width);
    args.push(this.Thickness);
    args.push(this.FilletRadius);
    args.push(this.EdgeRadius);
    args.push(this.LegSlope);
    return args;
  }
};
var IfcLaborResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLaborResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.Usage);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcLaborResourceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLaborResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ResourceType);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcLagTime = class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, LagValue, DurationType) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.LagValue = LagValue;
    this.DurationType = DurationType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let LagValue = tape[ptr++];
    let DurationType = tape[ptr++];
    return new IfcLagTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, LagValue, DurationType);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.DataOrigin);
    args.push(this.UserDefinedDataOrigin);
    args.push(this.LagValue);
    args.push(this.DurationType);
    return args;
  }
};
var IfcLamp = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLamp(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcLampType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLampType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcLibraryInformation = class {
  constructor(expressID, type, Name, Version, Publisher, VersionDate, Location, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Version = Version;
    this.Publisher = Publisher;
    this.VersionDate = VersionDate;
    this.Location = Location;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Version = tape[ptr++];
    let Publisher = tape[ptr++];
    let VersionDate = tape[ptr++];
    let Location = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcLibraryInformation(expressID, type, Name, Version, Publisher, VersionDate, Location, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Version);
    args.push(this.Publisher);
    args.push(this.VersionDate);
    args.push(this.Location);
    args.push(this.Description);
    return args;
  }
};
var IfcLibraryReference = class {
  constructor(expressID, type, Location, Identification, Name, Description, Language, ReferencedLibrary) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
    this.Description = Description;
    this.Language = Language;
    this.ReferencedLibrary = ReferencedLibrary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Language = tape[ptr++];
    let ReferencedLibrary = tape[ptr++];
    return new IfcLibraryReference(expressID, type, Location, Identification, Name, Description, Language, ReferencedLibrary);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    args.push(this.Identification);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Language);
    args.push(this.ReferencedLibrary);
    return args;
  }
};
var IfcLightDistributionData = class {
  constructor(expressID, type, MainPlaneAngle, SecondaryPlaneAngle, LuminousIntensity) {
    this.expressID = expressID;
    this.type = type;
    this.MainPlaneAngle = MainPlaneAngle;
    this.SecondaryPlaneAngle = SecondaryPlaneAngle;
    this.LuminousIntensity = LuminousIntensity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MainPlaneAngle = tape[ptr++];
    let SecondaryPlaneAngle = tape[ptr++];
    let LuminousIntensity = tape[ptr++];
    return new IfcLightDistributionData(expressID, type, MainPlaneAngle, SecondaryPlaneAngle, LuminousIntensity);
  }
  ToTape() {
    let args = [];
    args.push(this.MainPlaneAngle);
    args.push(this.SecondaryPlaneAngle);
    args.push(this.LuminousIntensity);
    return args;
  }
};
var IfcLightFixture = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLightFixture(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcLightFixtureType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLightFixtureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcLightIntensityDistribution = class {
  constructor(expressID, type, LightDistributionCurve, DistributionData) {
    this.expressID = expressID;
    this.type = type;
    this.LightDistributionCurve = LightDistributionCurve;
    this.DistributionData = DistributionData;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let LightDistributionCurve = tape[ptr++];
    let DistributionData = tape[ptr++];
    return new IfcLightIntensityDistribution(expressID, type, LightDistributionCurve, DistributionData);
  }
  ToTape() {
    let args = [];
    args.push(this.LightDistributionCurve);
    args.push(this.DistributionData);
    return args;
  }
};
var IfcLightSource = class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    return new IfcLightSource(expressID, type, Name, LightColour, AmbientIntensity, Intensity);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.LightColour);
    args.push(this.AmbientIntensity);
    args.push(this.Intensity);
    return args;
  }
};
var IfcLightSourceAmbient = class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    return new IfcLightSourceAmbient(expressID, type, Name, LightColour, AmbientIntensity, Intensity);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.LightColour);
    args.push(this.AmbientIntensity);
    args.push(this.Intensity);
    return args;
  }
};
var IfcLightSourceDirectional = class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Orientation) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
    this.Orientation = Orientation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    let Orientation = tape[ptr++];
    return new IfcLightSourceDirectional(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Orientation);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.LightColour);
    args.push(this.AmbientIntensity);
    args.push(this.Intensity);
    args.push(this.Orientation);
    return args;
  }
};
var IfcLightSourceGoniometric = class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, ColourAppearance, ColourTemperature, LuminousFlux, LightEmissionSource, LightDistributionDataSource) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
    this.Position = Position;
    this.ColourAppearance = ColourAppearance;
    this.ColourTemperature = ColourTemperature;
    this.LuminousFlux = LuminousFlux;
    this.LightEmissionSource = LightEmissionSource;
    this.LightDistributionDataSource = LightDistributionDataSource;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    let Position = tape[ptr++];
    let ColourAppearance = tape[ptr++];
    let ColourTemperature = tape[ptr++];
    let LuminousFlux = tape[ptr++];
    let LightEmissionSource = tape[ptr++];
    let LightDistributionDataSource = tape[ptr++];
    return new IfcLightSourceGoniometric(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, ColourAppearance, ColourTemperature, LuminousFlux, LightEmissionSource, LightDistributionDataSource);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.LightColour);
    args.push(this.AmbientIntensity);
    args.push(this.Intensity);
    args.push(this.Position);
    args.push(this.ColourAppearance);
    args.push(this.ColourTemperature);
    args.push(this.LuminousFlux);
    args.push(this.LightEmissionSource);
    args.push(this.LightDistributionDataSource);
    return args;
  }
};
var IfcLightSourcePositional = class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
    this.Position = Position;
    this.Radius = Radius;
    this.ConstantAttenuation = ConstantAttenuation;
    this.DistanceAttenuation = DistanceAttenuation;
    this.QuadricAttenuation = QuadricAttenuation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    let ConstantAttenuation = tape[ptr++];
    let DistanceAttenuation = tape[ptr++];
    let QuadricAttenuation = tape[ptr++];
    return new IfcLightSourcePositional(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.LightColour);
    args.push(this.AmbientIntensity);
    args.push(this.Intensity);
    args.push(this.Position);
    args.push(this.Radius);
    args.push(this.ConstantAttenuation);
    args.push(this.DistanceAttenuation);
    args.push(this.QuadricAttenuation);
    return args;
  }
};
var IfcLightSourceSpot = class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation, Orientation, ConcentrationExponent, SpreadAngle, BeamWidthAngle) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
    this.Position = Position;
    this.Radius = Radius;
    this.ConstantAttenuation = ConstantAttenuation;
    this.DistanceAttenuation = DistanceAttenuation;
    this.QuadricAttenuation = QuadricAttenuation;
    this.Orientation = Orientation;
    this.ConcentrationExponent = ConcentrationExponent;
    this.SpreadAngle = SpreadAngle;
    this.BeamWidthAngle = BeamWidthAngle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    let ConstantAttenuation = tape[ptr++];
    let DistanceAttenuation = tape[ptr++];
    let QuadricAttenuation = tape[ptr++];
    let Orientation = tape[ptr++];
    let ConcentrationExponent = tape[ptr++];
    let SpreadAngle = tape[ptr++];
    let BeamWidthAngle = tape[ptr++];
    return new IfcLightSourceSpot(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation, Orientation, ConcentrationExponent, SpreadAngle, BeamWidthAngle);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.LightColour);
    args.push(this.AmbientIntensity);
    args.push(this.Intensity);
    args.push(this.Position);
    args.push(this.Radius);
    args.push(this.ConstantAttenuation);
    args.push(this.DistanceAttenuation);
    args.push(this.QuadricAttenuation);
    args.push(this.Orientation);
    args.push(this.ConcentrationExponent);
    args.push(this.SpreadAngle);
    args.push(this.BeamWidthAngle);
    return args;
  }
};
var IfcLine = class {
  constructor(expressID, type, Pnt, Dir) {
    this.expressID = expressID;
    this.type = type;
    this.Pnt = Pnt;
    this.Dir = Dir;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Pnt = tape[ptr++];
    let Dir = tape[ptr++];
    return new IfcLine(expressID, type, Pnt, Dir);
  }
  ToTape() {
    let args = [];
    args.push(this.Pnt);
    args.push(this.Dir);
    return args;
  }
};
var IfcLineSegment2D = class {
  constructor(expressID, type, StartPoint, StartDirection, SegmentLength) {
    this.expressID = expressID;
    this.type = type;
    this.StartPoint = StartPoint;
    this.StartDirection = StartDirection;
    this.SegmentLength = SegmentLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartPoint = tape[ptr++];
    let StartDirection = tape[ptr++];
    let SegmentLength = tape[ptr++];
    return new IfcLineSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength);
  }
  ToTape() {
    let args = [];
    args.push(this.StartPoint);
    args.push(this.StartDirection);
    args.push(this.SegmentLength);
    return args;
  }
};
var IfcLinearPlacement = class {
  constructor(expressID, type, PlacementRelTo, PlacementMeasuredAlong, Distance, Orientation, CartesianPosition) {
    this.expressID = expressID;
    this.type = type;
    this.PlacementRelTo = PlacementRelTo;
    this.PlacementMeasuredAlong = PlacementMeasuredAlong;
    this.Distance = Distance;
    this.Orientation = Orientation;
    this.CartesianPosition = CartesianPosition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PlacementRelTo = tape[ptr++];
    let PlacementMeasuredAlong = tape[ptr++];
    let Distance = tape[ptr++];
    let Orientation = tape[ptr++];
    let CartesianPosition = tape[ptr++];
    return new IfcLinearPlacement(expressID, type, PlacementRelTo, PlacementMeasuredAlong, Distance, Orientation, CartesianPosition);
  }
  ToTape() {
    let args = [];
    args.push(this.PlacementRelTo);
    args.push(this.PlacementMeasuredAlong);
    args.push(this.Distance);
    args.push(this.Orientation);
    args.push(this.CartesianPosition);
    return args;
  }
};
var IfcLinearPositioningElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Axis = Axis;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Axis = tape[ptr++];
    return new IfcLinearPositioningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Axis);
    return args;
  }
};
var IfcLocalPlacement = class {
  constructor(expressID, type, PlacementRelTo, RelativePlacement) {
    this.expressID = expressID;
    this.type = type;
    this.PlacementRelTo = PlacementRelTo;
    this.RelativePlacement = RelativePlacement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PlacementRelTo = tape[ptr++];
    let RelativePlacement = tape[ptr++];
    return new IfcLocalPlacement(expressID, type, PlacementRelTo, RelativePlacement);
  }
  ToTape() {
    let args = [];
    args.push(this.PlacementRelTo);
    args.push(this.RelativePlacement);
    return args;
  }
};
var IfcLoop = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcLoop(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcManifoldSolidBrep = class {
  constructor(expressID, type, Outer) {
    this.expressID = expressID;
    this.type = type;
    this.Outer = Outer;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Outer = tape[ptr++];
    return new IfcManifoldSolidBrep(expressID, type, Outer);
  }
  ToTape() {
    let args = [];
    args.push(this.Outer);
    return args;
  }
};
var IfcMapConversion = class {
  constructor(expressID, type, SourceCRS, TargetCRS, Eastings, Northings, OrthogonalHeight, XAxisAbscissa, XAxisOrdinate, Scale) {
    this.expressID = expressID;
    this.type = type;
    this.SourceCRS = SourceCRS;
    this.TargetCRS = TargetCRS;
    this.Eastings = Eastings;
    this.Northings = Northings;
    this.OrthogonalHeight = OrthogonalHeight;
    this.XAxisAbscissa = XAxisAbscissa;
    this.XAxisOrdinate = XAxisOrdinate;
    this.Scale = Scale;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SourceCRS = tape[ptr++];
    let TargetCRS = tape[ptr++];
    let Eastings = tape[ptr++];
    let Northings = tape[ptr++];
    let OrthogonalHeight = tape[ptr++];
    let XAxisAbscissa = tape[ptr++];
    let XAxisOrdinate = tape[ptr++];
    let Scale = tape[ptr++];
    return new IfcMapConversion(expressID, type, SourceCRS, TargetCRS, Eastings, Northings, OrthogonalHeight, XAxisAbscissa, XAxisOrdinate, Scale);
  }
  ToTape() {
    let args = [];
    args.push(this.SourceCRS);
    args.push(this.TargetCRS);
    args.push(this.Eastings);
    args.push(this.Northings);
    args.push(this.OrthogonalHeight);
    args.push(this.XAxisAbscissa);
    args.push(this.XAxisOrdinate);
    args.push(this.Scale);
    return args;
  }
};
var IfcMappedItem = class {
  constructor(expressID, type, MappingSource, MappingTarget) {
    this.expressID = expressID;
    this.type = type;
    this.MappingSource = MappingSource;
    this.MappingTarget = MappingTarget;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MappingSource = tape[ptr++];
    let MappingTarget = tape[ptr++];
    return new IfcMappedItem(expressID, type, MappingSource, MappingTarget);
  }
  ToTape() {
    let args = [];
    args.push(this.MappingSource);
    args.push(this.MappingTarget);
    return args;
  }
};
var IfcMaterial = class {
  constructor(expressID, type, Name, Description, Category) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Category = Category;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Category = tape[ptr++];
    return new IfcMaterial(expressID, type, Name, Description, Category);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Category);
    return args;
  }
};
var IfcMaterialClassificationRelationship = class {
  constructor(expressID, type, MaterialClassifications, ClassifiedMaterial) {
    this.expressID = expressID;
    this.type = type;
    this.MaterialClassifications = MaterialClassifications;
    this.ClassifiedMaterial = ClassifiedMaterial;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MaterialClassifications = tape[ptr++];
    let ClassifiedMaterial = tape[ptr++];
    return new IfcMaterialClassificationRelationship(expressID, type, MaterialClassifications, ClassifiedMaterial);
  }
  ToTape() {
    let args = [];
    args.push(this.MaterialClassifications);
    args.push(this.ClassifiedMaterial);
    return args;
  }
};
var IfcMaterialConstituent = class {
  constructor(expressID, type, Name, Description, Material, Fraction, Category) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Material = Material;
    this.Fraction = Fraction;
    this.Category = Category;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Material = tape[ptr++];
    let Fraction = tape[ptr++];
    let Category = tape[ptr++];
    return new IfcMaterialConstituent(expressID, type, Name, Description, Material, Fraction, Category);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Material);
    args.push(this.Fraction);
    args.push(this.Category);
    return args;
  }
};
var IfcMaterialConstituentSet = class {
  constructor(expressID, type, Name, Description, MaterialConstituents) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.MaterialConstituents = MaterialConstituents;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let MaterialConstituents = tape[ptr++];
    return new IfcMaterialConstituentSet(expressID, type, Name, Description, MaterialConstituents);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.MaterialConstituents);
    return args;
  }
};
var IfcMaterialDefinition = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcMaterialDefinition(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcMaterialDefinitionRepresentation = class {
  constructor(expressID, type, Name, Description, Representations, RepresentedMaterial) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Representations = Representations;
    this.RepresentedMaterial = RepresentedMaterial;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Representations = tape[ptr++];
    let RepresentedMaterial = tape[ptr++];
    return new IfcMaterialDefinitionRepresentation(expressID, type, Name, Description, Representations, RepresentedMaterial);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Representations);
    args.push(this.RepresentedMaterial);
    return args;
  }
};
var IfcMaterialLayer = class {
  constructor(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority) {
    this.expressID = expressID;
    this.type = type;
    this.Material = Material;
    this.LayerThickness = LayerThickness;
    this.IsVentilated = IsVentilated;
    this.Name = Name;
    this.Description = Description;
    this.Category = Category;
    this.Priority = Priority;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Material = tape[ptr++];
    let LayerThickness = tape[ptr++];
    let IsVentilated = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Category = tape[ptr++];
    let Priority = tape[ptr++];
    return new IfcMaterialLayer(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority);
  }
  ToTape() {
    let args = [];
    args.push(this.Material);
    args.push(this.LayerThickness);
    args.push(this.IsVentilated);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Category);
    args.push(this.Priority);
    return args;
  }
};
var IfcMaterialLayerSet = class {
  constructor(expressID, type, MaterialLayers, LayerSetName, Description) {
    this.expressID = expressID;
    this.type = type;
    this.MaterialLayers = MaterialLayers;
    this.LayerSetName = LayerSetName;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MaterialLayers = tape[ptr++];
    let LayerSetName = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcMaterialLayerSet(expressID, type, MaterialLayers, LayerSetName, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.MaterialLayers);
    args.push(this.LayerSetName);
    args.push(this.Description);
    return args;
  }
};
var IfcMaterialLayerSetUsage = class {
  constructor(expressID, type, ForLayerSet, LayerSetDirection, DirectionSense, OffsetFromReferenceLine, ReferenceExtent) {
    this.expressID = expressID;
    this.type = type;
    this.ForLayerSet = ForLayerSet;
    this.LayerSetDirection = LayerSetDirection;
    this.DirectionSense = DirectionSense;
    this.OffsetFromReferenceLine = OffsetFromReferenceLine;
    this.ReferenceExtent = ReferenceExtent;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ForLayerSet = tape[ptr++];
    let LayerSetDirection = tape[ptr++];
    let DirectionSense = tape[ptr++];
    let OffsetFromReferenceLine = tape[ptr++];
    let ReferenceExtent = tape[ptr++];
    return new IfcMaterialLayerSetUsage(expressID, type, ForLayerSet, LayerSetDirection, DirectionSense, OffsetFromReferenceLine, ReferenceExtent);
  }
  ToTape() {
    let args = [];
    args.push(this.ForLayerSet);
    args.push(this.LayerSetDirection);
    args.push(this.DirectionSense);
    args.push(this.OffsetFromReferenceLine);
    args.push(this.ReferenceExtent);
    return args;
  }
};
var IfcMaterialLayerWithOffsets = class {
  constructor(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority, OffsetDirection, OffsetValues) {
    this.expressID = expressID;
    this.type = type;
    this.Material = Material;
    this.LayerThickness = LayerThickness;
    this.IsVentilated = IsVentilated;
    this.Name = Name;
    this.Description = Description;
    this.Category = Category;
    this.Priority = Priority;
    this.OffsetDirection = OffsetDirection;
    this.OffsetValues = OffsetValues;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Material = tape[ptr++];
    let LayerThickness = tape[ptr++];
    let IsVentilated = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Category = tape[ptr++];
    let Priority = tape[ptr++];
    let OffsetDirection = tape[ptr++];
    let OffsetValues = tape[ptr++];
    return new IfcMaterialLayerWithOffsets(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority, OffsetDirection, OffsetValues);
  }
  ToTape() {
    let args = [];
    args.push(this.Material);
    args.push(this.LayerThickness);
    args.push(this.IsVentilated);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Category);
    args.push(this.Priority);
    args.push(this.OffsetDirection);
    args.push(this.OffsetValues);
    return args;
  }
};
var IfcMaterialList = class {
  constructor(expressID, type, Materials) {
    this.expressID = expressID;
    this.type = type;
    this.Materials = Materials;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Materials = tape[ptr++];
    return new IfcMaterialList(expressID, type, Materials);
  }
  ToTape() {
    let args = [];
    args.push(this.Materials);
    return args;
  }
};
var IfcMaterialProfile = class {
  constructor(expressID, type, Name, Description, Material, Profile, Priority, Category) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Material = Material;
    this.Profile = Profile;
    this.Priority = Priority;
    this.Category = Category;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Material = tape[ptr++];
    let Profile = tape[ptr++];
    let Priority = tape[ptr++];
    let Category = tape[ptr++];
    return new IfcMaterialProfile(expressID, type, Name, Description, Material, Profile, Priority, Category);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Material);
    args.push(this.Profile);
    args.push(this.Priority);
    args.push(this.Category);
    return args;
  }
};
var IfcMaterialProfileSet = class {
  constructor(expressID, type, Name, Description, MaterialProfiles, CompositeProfile) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.MaterialProfiles = MaterialProfiles;
    this.CompositeProfile = CompositeProfile;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let MaterialProfiles = tape[ptr++];
    let CompositeProfile = tape[ptr++];
    return new IfcMaterialProfileSet(expressID, type, Name, Description, MaterialProfiles, CompositeProfile);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.MaterialProfiles);
    args.push(this.CompositeProfile);
    return args;
  }
};
var IfcMaterialProfileSetUsage = class {
  constructor(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent) {
    this.expressID = expressID;
    this.type = type;
    this.ForProfileSet = ForProfileSet;
    this.CardinalPoint = CardinalPoint;
    this.ReferenceExtent = ReferenceExtent;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ForProfileSet = tape[ptr++];
    let CardinalPoint = tape[ptr++];
    let ReferenceExtent = tape[ptr++];
    return new IfcMaterialProfileSetUsage(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent);
  }
  ToTape() {
    let args = [];
    args.push(this.ForProfileSet);
    args.push(this.CardinalPoint);
    args.push(this.ReferenceExtent);
    return args;
  }
};
var IfcMaterialProfileSetUsageTapering = class {
  constructor(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent, ForProfileEndSet, CardinalEndPoint) {
    this.expressID = expressID;
    this.type = type;
    this.ForProfileSet = ForProfileSet;
    this.CardinalPoint = CardinalPoint;
    this.ReferenceExtent = ReferenceExtent;
    this.ForProfileEndSet = ForProfileEndSet;
    this.CardinalEndPoint = CardinalEndPoint;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ForProfileSet = tape[ptr++];
    let CardinalPoint = tape[ptr++];
    let ReferenceExtent = tape[ptr++];
    let ForProfileEndSet = tape[ptr++];
    let CardinalEndPoint = tape[ptr++];
    return new IfcMaterialProfileSetUsageTapering(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent, ForProfileEndSet, CardinalEndPoint);
  }
  ToTape() {
    let args = [];
    args.push(this.ForProfileSet);
    args.push(this.CardinalPoint);
    args.push(this.ReferenceExtent);
    args.push(this.ForProfileEndSet);
    args.push(this.CardinalEndPoint);
    return args;
  }
};
var IfcMaterialProfileWithOffsets = class {
  constructor(expressID, type, Name, Description, Material, Profile, Priority, Category, OffsetValues) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Material = Material;
    this.Profile = Profile;
    this.Priority = Priority;
    this.Category = Category;
    this.OffsetValues = OffsetValues;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Material = tape[ptr++];
    let Profile = tape[ptr++];
    let Priority = tape[ptr++];
    let Category = tape[ptr++];
    let OffsetValues = tape[ptr++];
    return new IfcMaterialProfileWithOffsets(expressID, type, Name, Description, Material, Profile, Priority, Category, OffsetValues);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Material);
    args.push(this.Profile);
    args.push(this.Priority);
    args.push(this.Category);
    args.push(this.OffsetValues);
    return args;
  }
};
var IfcMaterialProperties = class {
  constructor(expressID, type, Name, Description, Properties2, Material) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Properties = Properties2;
    this.Material = Material;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Properties2 = tape[ptr++];
    let Material = tape[ptr++];
    return new IfcMaterialProperties(expressID, type, Name, Description, Properties2, Material);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Properties);
    args.push(this.Material);
    return args;
  }
};
var IfcMaterialRelationship = class {
  constructor(expressID, type, Name, Description, RelatingMaterial, RelatedMaterials, Expression) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingMaterial = RelatingMaterial;
    this.RelatedMaterials = RelatedMaterials;
    this.Expression = Expression;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingMaterial = tape[ptr++];
    let RelatedMaterials = tape[ptr++];
    let Expression = tape[ptr++];
    return new IfcMaterialRelationship(expressID, type, Name, Description, RelatingMaterial, RelatedMaterials, Expression);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingMaterial);
    args.push(this.RelatedMaterials);
    args.push(this.Expression);
    return args;
  }
};
var IfcMaterialUsageDefinition = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcMaterialUsageDefinition(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcMeasureWithUnit = class {
  constructor(expressID, type, ValueComponent, UnitComponent) {
    this.expressID = expressID;
    this.type = type;
    this.ValueComponent = ValueComponent;
    this.UnitComponent = UnitComponent;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ValueComponent = tape[ptr++];
    let UnitComponent = tape[ptr++];
    return new IfcMeasureWithUnit(expressID, type, ValueComponent, UnitComponent);
  }
  ToTape() {
    let args = [];
    args.push(this.ValueComponent);
    args.push(this.UnitComponent);
    return args;
  }
};
var IfcMechanicalFastener = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NominalDiameter, NominalLength, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.NominalDiameter = NominalDiameter;
    this.NominalLength = NominalLength;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let NominalLength = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMechanicalFastener(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NominalDiameter, NominalLength, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.NominalDiameter);
    args.push(this.NominalLength);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcMechanicalFastenerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, NominalLength) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.NominalDiameter = NominalDiameter;
    this.NominalLength = NominalLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let NominalLength = tape[ptr++];
    return new IfcMechanicalFastenerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, NominalLength);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    args.push(this.NominalDiameter);
    args.push(this.NominalLength);
    return args;
  }
};
var IfcMedicalDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMedicalDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcMedicalDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMedicalDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcMember = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcMemberStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMemberStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcMemberType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMemberType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcMetric = class {
  constructor(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, Benchmark, ValueSource, DataValue, ReferencePath) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.ConstraintGrade = ConstraintGrade;
    this.ConstraintSource = ConstraintSource;
    this.CreatingActor = CreatingActor;
    this.CreationTime = CreationTime;
    this.UserDefinedGrade = UserDefinedGrade;
    this.Benchmark = Benchmark;
    this.ValueSource = ValueSource;
    this.DataValue = DataValue;
    this.ReferencePath = ReferencePath;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConstraintGrade = tape[ptr++];
    let ConstraintSource = tape[ptr++];
    let CreatingActor = tape[ptr++];
    let CreationTime = tape[ptr++];
    let UserDefinedGrade = tape[ptr++];
    let Benchmark = tape[ptr++];
    let ValueSource = tape[ptr++];
    let DataValue = tape[ptr++];
    let ReferencePath = tape[ptr++];
    return new IfcMetric(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, Benchmark, ValueSource, DataValue, ReferencePath);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ConstraintGrade);
    args.push(this.ConstraintSource);
    args.push(this.CreatingActor);
    args.push(this.CreationTime);
    args.push(this.UserDefinedGrade);
    args.push(this.Benchmark);
    args.push(this.ValueSource);
    args.push(this.DataValue);
    args.push(this.ReferencePath);
    return args;
  }
};
var IfcMirroredProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.ParentProfile = ParentProfile;
    this.Operator = Operator;
    this.Label = Label;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let ParentProfile = tape[ptr++];
    let Operator = tape[ptr++];
    let Label = tape[ptr++];
    return new IfcMirroredProfileDef(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.ParentProfile);
    args.push(this.Operator);
    args.push(this.Label);
    return args;
  }
};
var IfcMonetaryUnit = class {
  constructor(expressID, type, Currency) {
    this.expressID = expressID;
    this.type = type;
    this.Currency = Currency;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Currency = tape[ptr++];
    return new IfcMonetaryUnit(expressID, type, Currency);
  }
  ToTape() {
    let args = [];
    args.push(this.Currency);
    return args;
  }
};
var IfcMotorConnection = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMotorConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcMotorConnectionType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMotorConnectionType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcNamedUnit = class {
  constructor(expressID, type, Dimensions, UnitType) {
    this.expressID = expressID;
    this.type = type;
    this.Dimensions = Dimensions;
    this.UnitType = UnitType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Dimensions = tape[ptr++];
    let UnitType = tape[ptr++];
    return new IfcNamedUnit(expressID, type, Dimensions, UnitType);
  }
  ToTape() {
    let args = [];
    args.push(this.Dimensions);
    args.push(this.UnitType);
    return args;
  }
};
var IfcObject = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    return new IfcObject(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    return args;
  }
};
var IfcObjectDefinition = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcObjectDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcObjectPlacement = class {
  constructor(expressID, type, PlacementRelTo) {
    this.expressID = expressID;
    this.type = type;
    this.PlacementRelTo = PlacementRelTo;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PlacementRelTo = tape[ptr++];
    return new IfcObjectPlacement(expressID, type, PlacementRelTo);
  }
  ToTape() {
    let args = [];
    args.push(this.PlacementRelTo);
    return args;
  }
};
var IfcObjective = class {
  constructor(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, BenchmarkValues, LogicalAggregator, ObjectiveQualifier, UserDefinedQualifier) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.ConstraintGrade = ConstraintGrade;
    this.ConstraintSource = ConstraintSource;
    this.CreatingActor = CreatingActor;
    this.CreationTime = CreationTime;
    this.UserDefinedGrade = UserDefinedGrade;
    this.BenchmarkValues = BenchmarkValues;
    this.LogicalAggregator = LogicalAggregator;
    this.ObjectiveQualifier = ObjectiveQualifier;
    this.UserDefinedQualifier = UserDefinedQualifier;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConstraintGrade = tape[ptr++];
    let ConstraintSource = tape[ptr++];
    let CreatingActor = tape[ptr++];
    let CreationTime = tape[ptr++];
    let UserDefinedGrade = tape[ptr++];
    let BenchmarkValues = tape[ptr++];
    let LogicalAggregator = tape[ptr++];
    let ObjectiveQualifier = tape[ptr++];
    let UserDefinedQualifier = tape[ptr++];
    return new IfcObjective(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, BenchmarkValues, LogicalAggregator, ObjectiveQualifier, UserDefinedQualifier);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ConstraintGrade);
    args.push(this.ConstraintSource);
    args.push(this.CreatingActor);
    args.push(this.CreationTime);
    args.push(this.UserDefinedGrade);
    args.push(this.BenchmarkValues);
    args.push(this.LogicalAggregator);
    args.push(this.ObjectiveQualifier);
    args.push(this.UserDefinedQualifier);
    return args;
  }
};
var IfcOccupant = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.TheActor = TheActor;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let TheActor = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcOccupant(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.TheActor);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcOffsetCurve = class {
  constructor(expressID, type, BasisCurve) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    return new IfcOffsetCurve(expressID, type, BasisCurve);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    return args;
  }
};
var IfcOffsetCurve2D = class {
  constructor(expressID, type, BasisCurve, Distance, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
    this.Distance = Distance;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    let Distance = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcOffsetCurve2D(expressID, type, BasisCurve, Distance, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    args.push(this.Distance);
    args.push(this.SelfIntersect);
    return args;
  }
};
var IfcOffsetCurve3D = class {
  constructor(expressID, type, BasisCurve, Distance, SelfIntersect, RefDirection) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
    this.Distance = Distance;
    this.SelfIntersect = SelfIntersect;
    this.RefDirection = RefDirection;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    let Distance = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    let RefDirection = tape[ptr++];
    return new IfcOffsetCurve3D(expressID, type, BasisCurve, Distance, SelfIntersect, RefDirection);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    args.push(this.Distance);
    args.push(this.SelfIntersect);
    args.push(this.RefDirection);
    return args;
  }
};
var IfcOffsetCurveByDistances = class {
  constructor(expressID, type, BasisCurve, OffsetValues, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
    this.OffsetValues = OffsetValues;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    let OffsetValues = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcOffsetCurveByDistances(expressID, type, BasisCurve, OffsetValues, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    args.push(this.OffsetValues);
    args.push(this.Tag);
    return args;
  }
};
var IfcOpenShell = class {
  constructor(expressID, type, CfsFaces) {
    this.expressID = expressID;
    this.type = type;
    this.CfsFaces = CfsFaces;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CfsFaces = tape[ptr++];
    return new IfcOpenShell(expressID, type, CfsFaces);
  }
  ToTape() {
    let args = [];
    args.push(this.CfsFaces);
    return args;
  }
};
var IfcOpeningElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcOpeningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcOpeningStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcOpeningStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcOrganization = class {
  constructor(expressID, type, Identification, Name, Description, Roles, Addresses) {
    this.expressID = expressID;
    this.type = type;
    this.Identification = Identification;
    this.Name = Name;
    this.Description = Description;
    this.Roles = Roles;
    this.Addresses = Addresses;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Roles = tape[ptr++];
    let Addresses = tape[ptr++];
    return new IfcOrganization(expressID, type, Identification, Name, Description, Roles, Addresses);
  }
  ToTape() {
    let args = [];
    args.push(this.Identification);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Roles);
    args.push(this.Addresses);
    return args;
  }
};
var IfcOrganizationRelationship = class {
  constructor(expressID, type, Name, Description, RelatingOrganization, RelatedOrganizations) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingOrganization = RelatingOrganization;
    this.RelatedOrganizations = RelatedOrganizations;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingOrganization = tape[ptr++];
    let RelatedOrganizations = tape[ptr++];
    return new IfcOrganizationRelationship(expressID, type, Name, Description, RelatingOrganization, RelatedOrganizations);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingOrganization);
    args.push(this.RelatedOrganizations);
    return args;
  }
};
var IfcOrientationExpression = class {
  constructor(expressID, type, LateralAxisDirection, VerticalAxisDirection) {
    this.expressID = expressID;
    this.type = type;
    this.LateralAxisDirection = LateralAxisDirection;
    this.VerticalAxisDirection = VerticalAxisDirection;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let LateralAxisDirection = tape[ptr++];
    let VerticalAxisDirection = tape[ptr++];
    return new IfcOrientationExpression(expressID, type, LateralAxisDirection, VerticalAxisDirection);
  }
  ToTape() {
    let args = [];
    args.push(this.LateralAxisDirection);
    args.push(this.VerticalAxisDirection);
    return args;
  }
};
var IfcOrientedEdge = class {
  constructor(expressID, type, EdgeStart, EdgeEnd, EdgeElement, Orientation) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeStart = EdgeStart;
    this.EdgeEnd = EdgeEnd;
    this.EdgeElement = EdgeElement;
    this.Orientation = Orientation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeStart = tape[ptr++];
    let EdgeEnd = tape[ptr++];
    let EdgeElement = tape[ptr++];
    let Orientation = tape[ptr++];
    return new IfcOrientedEdge(expressID, type, EdgeStart, EdgeEnd, EdgeElement, Orientation);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeStart);
    args.push(this.EdgeEnd);
    args.push(this.EdgeElement);
    args.push(this.Orientation);
    return args;
  }
};
var IfcOuterBoundaryCurve = class {
  constructor(expressID, type, Segments, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Segments = Segments;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Segments = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcOuterBoundaryCurve(expressID, type, Segments, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Segments);
    args.push(this.SelfIntersect);
    return args;
  }
};
var IfcOutlet = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcOutlet(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcOutletType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcOutletType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcOwnerHistory = class {
  constructor(expressID, type, OwningUser, OwningApplication, State, ChangeAction, LastModifiedDate, LastModifyingUser, LastModifyingApplication, CreationDate) {
    this.expressID = expressID;
    this.type = type;
    this.OwningUser = OwningUser;
    this.OwningApplication = OwningApplication;
    this.State = State;
    this.ChangeAction = ChangeAction;
    this.LastModifiedDate = LastModifiedDate;
    this.LastModifyingUser = LastModifyingUser;
    this.LastModifyingApplication = LastModifyingApplication;
    this.CreationDate = CreationDate;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let OwningUser = tape[ptr++];
    let OwningApplication = tape[ptr++];
    let State = tape[ptr++];
    let ChangeAction = tape[ptr++];
    let LastModifiedDate = tape[ptr++];
    let LastModifyingUser = tape[ptr++];
    let LastModifyingApplication = tape[ptr++];
    let CreationDate = tape[ptr++];
    return new IfcOwnerHistory(expressID, type, OwningUser, OwningApplication, State, ChangeAction, LastModifiedDate, LastModifyingUser, LastModifyingApplication, CreationDate);
  }
  ToTape() {
    let args = [];
    args.push(this.OwningUser);
    args.push(this.OwningApplication);
    args.push(this.State);
    args.push(this.ChangeAction);
    args.push(this.LastModifiedDate);
    args.push(this.LastModifyingUser);
    args.push(this.LastModifyingApplication);
    args.push(this.CreationDate);
    return args;
  }
};
var IfcParameterizedProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    return new IfcParameterizedProfileDef(expressID, type, ProfileType, ProfileName, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    return args;
  }
};
var IfcPath = class {
  constructor(expressID, type, EdgeList) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeList = EdgeList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeList = tape[ptr++];
    return new IfcPath(expressID, type, EdgeList);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeList);
    return args;
  }
};
var IfcPcurve = class {
  constructor(expressID, type, BasisSurface, ReferenceCurve) {
    this.expressID = expressID;
    this.type = type;
    this.BasisSurface = BasisSurface;
    this.ReferenceCurve = ReferenceCurve;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisSurface = tape[ptr++];
    let ReferenceCurve = tape[ptr++];
    return new IfcPcurve(expressID, type, BasisSurface, ReferenceCurve);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisSurface);
    args.push(this.ReferenceCurve);
    return args;
  }
};
var IfcPerformanceHistory = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LifeCyclePhase, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LifeCyclePhase = LifeCyclePhase;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LifeCyclePhase = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPerformanceHistory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LifeCyclePhase, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LifeCyclePhase);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcPermeableCoveringProperties = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.OperationType = OperationType;
    this.PanelPosition = PanelPosition;
    this.FrameDepth = FrameDepth;
    this.FrameThickness = FrameThickness;
    this.ShapeAspectStyle = ShapeAspectStyle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let OperationType = tape[ptr++];
    let PanelPosition = tape[ptr++];
    let FrameDepth = tape[ptr++];
    let FrameThickness = tape[ptr++];
    let ShapeAspectStyle = tape[ptr++];
    return new IfcPermeableCoveringProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.OperationType);
    args.push(this.PanelPosition);
    args.push(this.FrameDepth);
    args.push(this.FrameThickness);
    args.push(this.ShapeAspectStyle);
    return args;
  }
};
var IfcPermit = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.PredefinedType = PredefinedType;
    this.Status = Status;
    this.LongDescription = LongDescription;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Status = tape[ptr++];
    let LongDescription = tape[ptr++];
    return new IfcPermit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.PredefinedType);
    args.push(this.Status);
    args.push(this.LongDescription);
    return args;
  }
};
var IfcPerson = class {
  constructor(expressID, type, Identification, FamilyName, GivenName, MiddleNames, PrefixTitles, SuffixTitles, Roles, Addresses) {
    this.expressID = expressID;
    this.type = type;
    this.Identification = Identification;
    this.FamilyName = FamilyName;
    this.GivenName = GivenName;
    this.MiddleNames = MiddleNames;
    this.PrefixTitles = PrefixTitles;
    this.SuffixTitles = SuffixTitles;
    this.Roles = Roles;
    this.Addresses = Addresses;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Identification = tape[ptr++];
    let FamilyName = tape[ptr++];
    let GivenName = tape[ptr++];
    let MiddleNames = tape[ptr++];
    let PrefixTitles = tape[ptr++];
    let SuffixTitles = tape[ptr++];
    let Roles = tape[ptr++];
    let Addresses = tape[ptr++];
    return new IfcPerson(expressID, type, Identification, FamilyName, GivenName, MiddleNames, PrefixTitles, SuffixTitles, Roles, Addresses);
  }
  ToTape() {
    let args = [];
    args.push(this.Identification);
    args.push(this.FamilyName);
    args.push(this.GivenName);
    args.push(this.MiddleNames);
    args.push(this.PrefixTitles);
    args.push(this.SuffixTitles);
    args.push(this.Roles);
    args.push(this.Addresses);
    return args;
  }
};
var IfcPersonAndOrganization = class {
  constructor(expressID, type, ThePerson, TheOrganization, Roles) {
    this.expressID = expressID;
    this.type = type;
    this.ThePerson = ThePerson;
    this.TheOrganization = TheOrganization;
    this.Roles = Roles;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ThePerson = tape[ptr++];
    let TheOrganization = tape[ptr++];
    let Roles = tape[ptr++];
    return new IfcPersonAndOrganization(expressID, type, ThePerson, TheOrganization, Roles);
  }
  ToTape() {
    let args = [];
    args.push(this.ThePerson);
    args.push(this.TheOrganization);
    args.push(this.Roles);
    return args;
  }
};
var IfcPhysicalComplexQuantity = class {
  constructor(expressID, type, Name, Description, HasQuantities, Discrimination, Quality, Usage) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.HasQuantities = HasQuantities;
    this.Discrimination = Discrimination;
    this.Quality = Quality;
    this.Usage = Usage;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let HasQuantities = tape[ptr++];
    let Discrimination = tape[ptr++];
    let Quality = tape[ptr++];
    let Usage = tape[ptr++];
    return new IfcPhysicalComplexQuantity(expressID, type, Name, Description, HasQuantities, Discrimination, Quality, Usage);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.HasQuantities);
    args.push(this.Discrimination);
    args.push(this.Quality);
    args.push(this.Usage);
    return args;
  }
};
var IfcPhysicalQuantity = class {
  constructor(expressID, type, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPhysicalQuantity(expressID, type, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcPhysicalSimpleQuantity = class {
  constructor(expressID, type, Name, Description, Unit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    return new IfcPhysicalSimpleQuantity(expressID, type, Name, Description, Unit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Unit);
    return args;
  }
};
var IfcPile = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType, ConstructionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
    this.ConstructionType = ConstructionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let ConstructionType = tape[ptr++];
    return new IfcPile(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType, ConstructionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    args.push(this.ConstructionType);
    return args;
  }
};
var IfcPileType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPileType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcPipeFitting = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPipeFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcPipeFittingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPipeFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcPipeSegment = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPipeSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcPipeSegmentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPipeSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcPixelTexture = class {
  constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, Width, Height, ColourComponents, Pixel) {
    this.expressID = expressID;
    this.type = type;
    this.RepeatS = RepeatS;
    this.RepeatT = RepeatT;
    this.Mode = Mode;
    this.TextureTransform = TextureTransform;
    this.Parameter = Parameter;
    this.Width = Width;
    this.Height = Height;
    this.ColourComponents = ColourComponents;
    this.Pixel = Pixel;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RepeatS = tape[ptr++];
    let RepeatT = tape[ptr++];
    let Mode = tape[ptr++];
    let TextureTransform = tape[ptr++];
    let Parameter = tape[ptr++];
    let Width = tape[ptr++];
    let Height = tape[ptr++];
    let ColourComponents = tape[ptr++];
    let Pixel = tape[ptr++];
    return new IfcPixelTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, Width, Height, ColourComponents, Pixel);
  }
  ToTape() {
    let args = [];
    args.push(this.RepeatS);
    args.push(this.RepeatT);
    args.push(this.Mode);
    args.push(this.TextureTransform);
    args.push(this.Parameter);
    args.push(this.Width);
    args.push(this.Height);
    args.push(this.ColourComponents);
    args.push(this.Pixel);
    return args;
  }
};
var IfcPlacement = class {
  constructor(expressID, type, Location) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    return new IfcPlacement(expressID, type, Location);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    return args;
  }
};
var IfcPlanarBox = class {
  constructor(expressID, type, SizeInX, SizeInY, Placement) {
    this.expressID = expressID;
    this.type = type;
    this.SizeInX = SizeInX;
    this.SizeInY = SizeInY;
    this.Placement = Placement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SizeInX = tape[ptr++];
    let SizeInY = tape[ptr++];
    let Placement = tape[ptr++];
    return new IfcPlanarBox(expressID, type, SizeInX, SizeInY, Placement);
  }
  ToTape() {
    let args = [];
    args.push(this.SizeInX);
    args.push(this.SizeInY);
    args.push(this.Placement);
    return args;
  }
};
var IfcPlanarExtent = class {
  constructor(expressID, type, SizeInX, SizeInY) {
    this.expressID = expressID;
    this.type = type;
    this.SizeInX = SizeInX;
    this.SizeInY = SizeInY;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SizeInX = tape[ptr++];
    let SizeInY = tape[ptr++];
    return new IfcPlanarExtent(expressID, type, SizeInX, SizeInY);
  }
  ToTape() {
    let args = [];
    args.push(this.SizeInX);
    args.push(this.SizeInY);
    return args;
  }
};
var IfcPlane = class {
  constructor(expressID, type, Position) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    return new IfcPlane(expressID, type, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    return args;
  }
};
var IfcPlate = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPlate(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcPlateStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPlateStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcPlateType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPlateType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcPoint = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcPoint(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcPointOnCurve = class {
  constructor(expressID, type, BasisCurve, PointParameter) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
    this.PointParameter = PointParameter;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    let PointParameter = tape[ptr++];
    return new IfcPointOnCurve(expressID, type, BasisCurve, PointParameter);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    args.push(this.PointParameter);
    return args;
  }
};
var IfcPointOnSurface = class {
  constructor(expressID, type, BasisSurface, PointParameterU, PointParameterV) {
    this.expressID = expressID;
    this.type = type;
    this.BasisSurface = BasisSurface;
    this.PointParameterU = PointParameterU;
    this.PointParameterV = PointParameterV;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisSurface = tape[ptr++];
    let PointParameterU = tape[ptr++];
    let PointParameterV = tape[ptr++];
    return new IfcPointOnSurface(expressID, type, BasisSurface, PointParameterU, PointParameterV);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisSurface);
    args.push(this.PointParameterU);
    args.push(this.PointParameterV);
    return args;
  }
};
var IfcPolyLoop = class {
  constructor(expressID, type, Polygon) {
    this.expressID = expressID;
    this.type = type;
    this.Polygon = Polygon;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Polygon = tape[ptr++];
    return new IfcPolyLoop(expressID, type, Polygon);
  }
  ToTape() {
    let args = [];
    args.push(this.Polygon);
    return args;
  }
};
var IfcPolygonalBoundedHalfSpace = class {
  constructor(expressID, type, BaseSurface, AgreementFlag, Position, PolygonalBoundary) {
    this.expressID = expressID;
    this.type = type;
    this.BaseSurface = BaseSurface;
    this.AgreementFlag = AgreementFlag;
    this.Position = Position;
    this.PolygonalBoundary = PolygonalBoundary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BaseSurface = tape[ptr++];
    let AgreementFlag = tape[ptr++];
    let Position = tape[ptr++];
    let PolygonalBoundary = tape[ptr++];
    return new IfcPolygonalBoundedHalfSpace(expressID, type, BaseSurface, AgreementFlag, Position, PolygonalBoundary);
  }
  ToTape() {
    let args = [];
    args.push(this.BaseSurface);
    args.push(this.AgreementFlag);
    args.push(this.Position);
    args.push(this.PolygonalBoundary);
    return args;
  }
};
var IfcPolygonalFaceSet = class {
  constructor(expressID, type, Coordinates, Closed, Faces, PnIndex) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
    this.Closed = Closed;
    this.Faces = Faces;
    this.PnIndex = PnIndex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    let Closed = tape[ptr++];
    let Faces = tape[ptr++];
    let PnIndex = tape[ptr++];
    return new IfcPolygonalFaceSet(expressID, type, Coordinates, Closed, Faces, PnIndex);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    args.push(this.Closed);
    args.push(this.Faces);
    args.push(this.PnIndex);
    return args;
  }
};
var IfcPolyline = class {
  constructor(expressID, type, Points) {
    this.expressID = expressID;
    this.type = type;
    this.Points = Points;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Points = tape[ptr++];
    return new IfcPolyline(expressID, type, Points);
  }
  ToTape() {
    let args = [];
    args.push(this.Points);
    return args;
  }
};
var IfcPort = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcPort(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    return args;
  }
};
var IfcPositioningElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcPositioningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    return args;
  }
};
var IfcPostalAddress = class {
  constructor(expressID, type, Purpose, Description, UserDefinedPurpose, InternalLocation, AddressLines, PostalBox, Town, Region, PostalCode, Country) {
    this.expressID = expressID;
    this.type = type;
    this.Purpose = Purpose;
    this.Description = Description;
    this.UserDefinedPurpose = UserDefinedPurpose;
    this.InternalLocation = InternalLocation;
    this.AddressLines = AddressLines;
    this.PostalBox = PostalBox;
    this.Town = Town;
    this.Region = Region;
    this.PostalCode = PostalCode;
    this.Country = Country;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Purpose = tape[ptr++];
    let Description = tape[ptr++];
    let UserDefinedPurpose = tape[ptr++];
    let InternalLocation = tape[ptr++];
    let AddressLines = tape[ptr++];
    let PostalBox = tape[ptr++];
    let Town = tape[ptr++];
    let Region = tape[ptr++];
    let PostalCode = tape[ptr++];
    let Country = tape[ptr++];
    return new IfcPostalAddress(expressID, type, Purpose, Description, UserDefinedPurpose, InternalLocation, AddressLines, PostalBox, Town, Region, PostalCode, Country);
  }
  ToTape() {
    let args = [];
    args.push(this.Purpose);
    args.push(this.Description);
    args.push(this.UserDefinedPurpose);
    args.push(this.InternalLocation);
    args.push(this.AddressLines);
    args.push(this.PostalBox);
    args.push(this.Town);
    args.push(this.Region);
    args.push(this.PostalCode);
    args.push(this.Country);
    return args;
  }
};
var IfcPreDefinedColour = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcPreDefinedColour(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcPreDefinedCurveFont = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcPreDefinedCurveFont(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcPreDefinedItem = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcPreDefinedItem(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcPreDefinedProperties = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcPreDefinedProperties(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcPreDefinedPropertySet = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPreDefinedPropertySet(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcPreDefinedTextFont = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcPreDefinedTextFont(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcPresentationItem = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcPresentationItem(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcPresentationLayerAssignment = class {
  constructor(expressID, type, Name, Description, AssignedItems, Identifier) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.AssignedItems = AssignedItems;
    this.Identifier = Identifier;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let AssignedItems = tape[ptr++];
    let Identifier = tape[ptr++];
    return new IfcPresentationLayerAssignment(expressID, type, Name, Description, AssignedItems, Identifier);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.AssignedItems);
    args.push(this.Identifier);
    return args;
  }
};
var IfcPresentationLayerWithStyle = class {
  constructor(expressID, type, Name, Description, AssignedItems, Identifier, LayerOn, LayerFrozen, LayerBlocked, LayerStyles) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.AssignedItems = AssignedItems;
    this.Identifier = Identifier;
    this.LayerOn = LayerOn;
    this.LayerFrozen = LayerFrozen;
    this.LayerBlocked = LayerBlocked;
    this.LayerStyles = LayerStyles;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let AssignedItems = tape[ptr++];
    let Identifier = tape[ptr++];
    let LayerOn = tape[ptr++];
    let LayerFrozen = tape[ptr++];
    let LayerBlocked = tape[ptr++];
    let LayerStyles = tape[ptr++];
    return new IfcPresentationLayerWithStyle(expressID, type, Name, Description, AssignedItems, Identifier, LayerOn, LayerFrozen, LayerBlocked, LayerStyles);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.AssignedItems);
    args.push(this.Identifier);
    args.push(this.LayerOn);
    args.push(this.LayerFrozen);
    args.push(this.LayerBlocked);
    args.push(this.LayerStyles);
    return args;
  }
};
var IfcPresentationStyle = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcPresentationStyle(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcPresentationStyleAssignment = class {
  constructor(expressID, type, Styles) {
    this.expressID = expressID;
    this.type = type;
    this.Styles = Styles;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Styles = tape[ptr++];
    return new IfcPresentationStyleAssignment(expressID, type, Styles);
  }
  ToTape() {
    let args = [];
    args.push(this.Styles);
    return args;
  }
};
var IfcProcedure = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProcedure(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcProcedureType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ProcessType = ProcessType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ProcessType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProcedureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ProcessType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcProcess = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    return new IfcProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    return args;
  }
};
var IfcProduct = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    return args;
  }
};
var IfcProductDefinitionShape = class {
  constructor(expressID, type, Name, Description, Representations) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Representations = Representations;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Representations = tape[ptr++];
    return new IfcProductDefinitionShape(expressID, type, Name, Description, Representations);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Representations);
    return args;
  }
};
var IfcProductRepresentation = class {
  constructor(expressID, type, Name, Description, Representations) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Representations = Representations;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Representations = tape[ptr++];
    return new IfcProductRepresentation(expressID, type, Name, Description, Representations);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Representations);
    return args;
  }
};
var IfcProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    return new IfcProfileDef(expressID, type, ProfileType, ProfileName);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    return args;
  }
};
var IfcProfileProperties = class {
  constructor(expressID, type, Name, Description, Properties2, ProfileDefinition) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Properties = Properties2;
    this.ProfileDefinition = ProfileDefinition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Properties2 = tape[ptr++];
    let ProfileDefinition = tape[ptr++];
    return new IfcProfileProperties(expressID, type, Name, Description, Properties2, ProfileDefinition);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Properties);
    args.push(this.ProfileDefinition);
    return args;
  }
};
var IfcProject = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
    this.Phase = Phase;
    this.RepresentationContexts = RepresentationContexts;
    this.UnitsInContext = UnitsInContext;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    let Phase = tape[ptr++];
    let RepresentationContexts = tape[ptr++];
    let UnitsInContext = tape[ptr++];
    return new IfcProject(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.LongName);
    args.push(this.Phase);
    args.push(this.RepresentationContexts);
    args.push(this.UnitsInContext);
    return args;
  }
};
var IfcProjectLibrary = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
    this.Phase = Phase;
    this.RepresentationContexts = RepresentationContexts;
    this.UnitsInContext = UnitsInContext;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    let Phase = tape[ptr++];
    let RepresentationContexts = tape[ptr++];
    let UnitsInContext = tape[ptr++];
    return new IfcProjectLibrary(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.LongName);
    args.push(this.Phase);
    args.push(this.RepresentationContexts);
    args.push(this.UnitsInContext);
    return args;
  }
};
var IfcProjectOrder = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.PredefinedType = PredefinedType;
    this.Status = Status;
    this.LongDescription = LongDescription;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Status = tape[ptr++];
    let LongDescription = tape[ptr++];
    return new IfcProjectOrder(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.PredefinedType);
    args.push(this.Status);
    args.push(this.LongDescription);
    return args;
  }
};
var IfcProjectedCRS = class {
  constructor(expressID, type, Name, Description, GeodeticDatum, VerticalDatum, MapProjection, MapZone, MapUnit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.GeodeticDatum = GeodeticDatum;
    this.VerticalDatum = VerticalDatum;
    this.MapProjection = MapProjection;
    this.MapZone = MapZone;
    this.MapUnit = MapUnit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let GeodeticDatum = tape[ptr++];
    let VerticalDatum = tape[ptr++];
    let MapProjection = tape[ptr++];
    let MapZone = tape[ptr++];
    let MapUnit = tape[ptr++];
    return new IfcProjectedCRS(expressID, type, Name, Description, GeodeticDatum, VerticalDatum, MapProjection, MapZone, MapUnit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.GeodeticDatum);
    args.push(this.VerticalDatum);
    args.push(this.MapProjection);
    args.push(this.MapZone);
    args.push(this.MapUnit);
    return args;
  }
};
var IfcProjectionElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProjectionElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcProperty = class {
  constructor(expressID, type, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcProperty(expressID, type, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcPropertyAbstraction = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcPropertyAbstraction(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcPropertyBoundedValue = class {
  constructor(expressID, type, Name, Description, UpperBoundValue, LowerBoundValue, Unit, SetPointValue) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.UpperBoundValue = UpperBoundValue;
    this.LowerBoundValue = LowerBoundValue;
    this.Unit = Unit;
    this.SetPointValue = SetPointValue;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let UpperBoundValue = tape[ptr++];
    let LowerBoundValue = tape[ptr++];
    let Unit = tape[ptr++];
    let SetPointValue = tape[ptr++];
    return new IfcPropertyBoundedValue(expressID, type, Name, Description, UpperBoundValue, LowerBoundValue, Unit, SetPointValue);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.UpperBoundValue);
    args.push(this.LowerBoundValue);
    args.push(this.Unit);
    args.push(this.SetPointValue);
    return args;
  }
};
var IfcPropertyDefinition = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPropertyDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcPropertyDependencyRelationship = class {
  constructor(expressID, type, Name, Description, DependingProperty, DependantProperty, Expression) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.DependingProperty = DependingProperty;
    this.DependantProperty = DependantProperty;
    this.Expression = Expression;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let DependingProperty = tape[ptr++];
    let DependantProperty = tape[ptr++];
    let Expression = tape[ptr++];
    return new IfcPropertyDependencyRelationship(expressID, type, Name, Description, DependingProperty, DependantProperty, Expression);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.DependingProperty);
    args.push(this.DependantProperty);
    args.push(this.Expression);
    return args;
  }
};
var IfcPropertyEnumeratedValue = class {
  constructor(expressID, type, Name, Description, EnumerationValues, EnumerationReference) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.EnumerationValues = EnumerationValues;
    this.EnumerationReference = EnumerationReference;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let EnumerationValues = tape[ptr++];
    let EnumerationReference = tape[ptr++];
    return new IfcPropertyEnumeratedValue(expressID, type, Name, Description, EnumerationValues, EnumerationReference);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.EnumerationValues);
    args.push(this.EnumerationReference);
    return args;
  }
};
var IfcPropertyEnumeration = class {
  constructor(expressID, type, Name, EnumerationValues, Unit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.EnumerationValues = EnumerationValues;
    this.Unit = Unit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let EnumerationValues = tape[ptr++];
    let Unit = tape[ptr++];
    return new IfcPropertyEnumeration(expressID, type, Name, EnumerationValues, Unit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.EnumerationValues);
    args.push(this.Unit);
    return args;
  }
};
var IfcPropertyListValue = class {
  constructor(expressID, type, Name, Description, ListValues, Unit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.ListValues = ListValues;
    this.Unit = Unit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ListValues = tape[ptr++];
    let Unit = tape[ptr++];
    return new IfcPropertyListValue(expressID, type, Name, Description, ListValues, Unit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ListValues);
    args.push(this.Unit);
    return args;
  }
};
var IfcPropertyReferenceValue = class {
  constructor(expressID, type, Name, Description, UsageName, PropertyReference) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.UsageName = UsageName;
    this.PropertyReference = PropertyReference;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let UsageName = tape[ptr++];
    let PropertyReference = tape[ptr++];
    return new IfcPropertyReferenceValue(expressID, type, Name, Description, UsageName, PropertyReference);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.UsageName);
    args.push(this.PropertyReference);
    return args;
  }
};
var IfcPropertySet = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, HasProperties) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.HasProperties = HasProperties;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let HasProperties = tape[ptr++];
    return new IfcPropertySet(expressID, type, GlobalId, OwnerHistory, Name, Description, HasProperties);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.HasProperties);
    return args;
  }
};
var IfcPropertySetDefinition = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPropertySetDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcPropertySetTemplate = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, ApplicableEntity, HasPropertyTemplates) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.TemplateType = TemplateType;
    this.ApplicableEntity = ApplicableEntity;
    this.HasPropertyTemplates = HasPropertyTemplates;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let TemplateType = tape[ptr++];
    let ApplicableEntity = tape[ptr++];
    let HasPropertyTemplates = tape[ptr++];
    return new IfcPropertySetTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, ApplicableEntity, HasPropertyTemplates);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.TemplateType);
    args.push(this.ApplicableEntity);
    args.push(this.HasPropertyTemplates);
    return args;
  }
};
var IfcPropertySingleValue = class {
  constructor(expressID, type, Name, Description, NominalValue, Unit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.NominalValue = NominalValue;
    this.Unit = Unit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let NominalValue = tape[ptr++];
    let Unit = tape[ptr++];
    return new IfcPropertySingleValue(expressID, type, Name, Description, NominalValue, Unit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.NominalValue);
    args.push(this.Unit);
    return args;
  }
};
var IfcPropertyTableValue = class {
  constructor(expressID, type, Name, Description, DefiningValues, DefinedValues, Expression, DefiningUnit, DefinedUnit, CurveInterpolation) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.DefiningValues = DefiningValues;
    this.DefinedValues = DefinedValues;
    this.Expression = Expression;
    this.DefiningUnit = DefiningUnit;
    this.DefinedUnit = DefinedUnit;
    this.CurveInterpolation = CurveInterpolation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let DefiningValues = tape[ptr++];
    let DefinedValues = tape[ptr++];
    let Expression = tape[ptr++];
    let DefiningUnit = tape[ptr++];
    let DefinedUnit = tape[ptr++];
    let CurveInterpolation = tape[ptr++];
    return new IfcPropertyTableValue(expressID, type, Name, Description, DefiningValues, DefinedValues, Expression, DefiningUnit, DefinedUnit, CurveInterpolation);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.DefiningValues);
    args.push(this.DefinedValues);
    args.push(this.Expression);
    args.push(this.DefiningUnit);
    args.push(this.DefinedUnit);
    args.push(this.CurveInterpolation);
    return args;
  }
};
var IfcPropertyTemplate = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcPropertyTemplateDefinition = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPropertyTemplateDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcProtectiveDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProtectiveDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcProtectiveDeviceTrippingUnit = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProtectiveDeviceTrippingUnit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcProtectiveDeviceTrippingUnitType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProtectiveDeviceTrippingUnitType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcProtectiveDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProtectiveDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcProxy = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, ProxyType, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.ProxyType = ProxyType;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let ProxyType = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcProxy(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, ProxyType, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.ProxyType);
    args.push(this.Tag);
    return args;
  }
};
var IfcPump = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPump(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcPumpType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPumpType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcQuantityArea = class {
  constructor(expressID, type, Name, Description, Unit, AreaValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.AreaValue = AreaValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let AreaValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityArea(expressID, type, Name, Description, Unit, AreaValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Unit);
    args.push(this.AreaValue);
    args.push(this.Formula);
    return args;
  }
};
var IfcQuantityCount = class {
  constructor(expressID, type, Name, Description, Unit, CountValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.CountValue = CountValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let CountValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityCount(expressID, type, Name, Description, Unit, CountValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Unit);
    args.push(this.CountValue);
    args.push(this.Formula);
    return args;
  }
};
var IfcQuantityLength = class {
  constructor(expressID, type, Name, Description, Unit, LengthValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.LengthValue = LengthValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let LengthValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityLength(expressID, type, Name, Description, Unit, LengthValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Unit);
    args.push(this.LengthValue);
    args.push(this.Formula);
    return args;
  }
};
var IfcQuantitySet = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcQuantitySet(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcQuantityTime = class {
  constructor(expressID, type, Name, Description, Unit, TimeValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.TimeValue = TimeValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let TimeValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityTime(expressID, type, Name, Description, Unit, TimeValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Unit);
    args.push(this.TimeValue);
    args.push(this.Formula);
    return args;
  }
};
var IfcQuantityVolume = class {
  constructor(expressID, type, Name, Description, Unit, VolumeValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.VolumeValue = VolumeValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let VolumeValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityVolume(expressID, type, Name, Description, Unit, VolumeValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Unit);
    args.push(this.VolumeValue);
    args.push(this.Formula);
    return args;
  }
};
var IfcQuantityWeight = class {
  constructor(expressID, type, Name, Description, Unit, WeightValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.WeightValue = WeightValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let WeightValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityWeight(expressID, type, Name, Description, Unit, WeightValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Unit);
    args.push(this.WeightValue);
    args.push(this.Formula);
    return args;
  }
};
var IfcRailing = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRailing(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcRailingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRailingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcRamp = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRamp(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcRampFlight = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRampFlight(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcRampFlightType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRampFlightType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcRampType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRampType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcRationalBSplineCurveWithKnots = class {
  constructor(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec, WeightsData) {
    this.expressID = expressID;
    this.type = type;
    this.Degree = Degree;
    this.ControlPointsList = ControlPointsList;
    this.CurveForm = CurveForm;
    this.ClosedCurve = ClosedCurve;
    this.SelfIntersect = SelfIntersect;
    this.KnotMultiplicities = KnotMultiplicities;
    this.Knots = Knots;
    this.KnotSpec = KnotSpec;
    this.WeightsData = WeightsData;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Degree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let CurveForm = tape[ptr++];
    let ClosedCurve = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    let KnotMultiplicities = tape[ptr++];
    let Knots = tape[ptr++];
    let KnotSpec = tape[ptr++];
    let WeightsData = tape[ptr++];
    return new IfcRationalBSplineCurveWithKnots(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec, WeightsData);
  }
  ToTape() {
    let args = [];
    args.push(this.Degree);
    args.push(this.ControlPointsList);
    args.push(this.CurveForm);
    args.push(this.ClosedCurve);
    args.push(this.SelfIntersect);
    args.push(this.KnotMultiplicities);
    args.push(this.Knots);
    args.push(this.KnotSpec);
    args.push(this.WeightsData);
    return args;
  }
};
var IfcRationalBSplineSurfaceWithKnots = class {
  constructor(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec, WeightsData) {
    this.expressID = expressID;
    this.type = type;
    this.UDegree = UDegree;
    this.VDegree = VDegree;
    this.ControlPointsList = ControlPointsList;
    this.SurfaceForm = SurfaceForm;
    this.UClosed = UClosed;
    this.VClosed = VClosed;
    this.SelfIntersect = SelfIntersect;
    this.UMultiplicities = UMultiplicities;
    this.VMultiplicities = VMultiplicities;
    this.UKnots = UKnots;
    this.VKnots = VKnots;
    this.KnotSpec = KnotSpec;
    this.WeightsData = WeightsData;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let UDegree = tape[ptr++];
    let VDegree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let SurfaceForm = tape[ptr++];
    let UClosed = tape[ptr++];
    let VClosed = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    let UMultiplicities = tape[ptr++];
    let VMultiplicities = tape[ptr++];
    let UKnots = tape[ptr++];
    let VKnots = tape[ptr++];
    let KnotSpec = tape[ptr++];
    let WeightsData = tape[ptr++];
    return new IfcRationalBSplineSurfaceWithKnots(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec, WeightsData);
  }
  ToTape() {
    let args = [];
    args.push(this.UDegree);
    args.push(this.VDegree);
    args.push(this.ControlPointsList);
    args.push(this.SurfaceForm);
    args.push(this.UClosed);
    args.push(this.VClosed);
    args.push(this.SelfIntersect);
    args.push(this.UMultiplicities);
    args.push(this.VMultiplicities);
    args.push(this.UKnots);
    args.push(this.VKnots);
    args.push(this.KnotSpec);
    args.push(this.WeightsData);
    return args;
  }
};
var IfcRectangleHollowProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, WallThickness, InnerFilletRadius, OuterFilletRadius) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.XDim = XDim;
    this.YDim = YDim;
    this.WallThickness = WallThickness;
    this.InnerFilletRadius = InnerFilletRadius;
    this.OuterFilletRadius = OuterFilletRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let XDim = tape[ptr++];
    let YDim = tape[ptr++];
    let WallThickness = tape[ptr++];
    let InnerFilletRadius = tape[ptr++];
    let OuterFilletRadius = tape[ptr++];
    return new IfcRectangleHollowProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, WallThickness, InnerFilletRadius, OuterFilletRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.XDim);
    args.push(this.YDim);
    args.push(this.WallThickness);
    args.push(this.InnerFilletRadius);
    args.push(this.OuterFilletRadius);
    return args;
  }
};
var IfcRectangleProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, XDim, YDim) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.XDim = XDim;
    this.YDim = YDim;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let XDim = tape[ptr++];
    let YDim = tape[ptr++];
    return new IfcRectangleProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.XDim);
    args.push(this.YDim);
    return args;
  }
};
var IfcRectangularPyramid = class {
  constructor(expressID, type, Position, XLength, YLength, Height) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.XLength = XLength;
    this.YLength = YLength;
    this.Height = Height;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let XLength = tape[ptr++];
    let YLength = tape[ptr++];
    let Height = tape[ptr++];
    return new IfcRectangularPyramid(expressID, type, Position, XLength, YLength, Height);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    args.push(this.XLength);
    args.push(this.YLength);
    args.push(this.Height);
    return args;
  }
};
var IfcRectangularTrimmedSurface = class {
  constructor(expressID, type, BasisSurface, U1, V1, U2, V2, Usense, Vsense) {
    this.expressID = expressID;
    this.type = type;
    this.BasisSurface = BasisSurface;
    this.U1 = U1;
    this.V1 = V1;
    this.U2 = U2;
    this.V2 = V2;
    this.Usense = Usense;
    this.Vsense = Vsense;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisSurface = tape[ptr++];
    let U1 = tape[ptr++];
    let V1 = tape[ptr++];
    let U2 = tape[ptr++];
    let V2 = tape[ptr++];
    let Usense = tape[ptr++];
    let Vsense = tape[ptr++];
    return new IfcRectangularTrimmedSurface(expressID, type, BasisSurface, U1, V1, U2, V2, Usense, Vsense);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisSurface);
    args.push(this.U1);
    args.push(this.V1);
    args.push(this.U2);
    args.push(this.V2);
    args.push(this.Usense);
    args.push(this.Vsense);
    return args;
  }
};
var IfcRecurrencePattern = class {
  constructor(expressID, type, RecurrenceType, DayComponent, WeekdayComponent, MonthComponent, Position, Interval, Occurrences, TimePeriods) {
    this.expressID = expressID;
    this.type = type;
    this.RecurrenceType = RecurrenceType;
    this.DayComponent = DayComponent;
    this.WeekdayComponent = WeekdayComponent;
    this.MonthComponent = MonthComponent;
    this.Position = Position;
    this.Interval = Interval;
    this.Occurrences = Occurrences;
    this.TimePeriods = TimePeriods;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RecurrenceType = tape[ptr++];
    let DayComponent = tape[ptr++];
    let WeekdayComponent = tape[ptr++];
    let MonthComponent = tape[ptr++];
    let Position = tape[ptr++];
    let Interval = tape[ptr++];
    let Occurrences = tape[ptr++];
    let TimePeriods = tape[ptr++];
    return new IfcRecurrencePattern(expressID, type, RecurrenceType, DayComponent, WeekdayComponent, MonthComponent, Position, Interval, Occurrences, TimePeriods);
  }
  ToTape() {
    let args = [];
    args.push(this.RecurrenceType);
    args.push(this.DayComponent);
    args.push(this.WeekdayComponent);
    args.push(this.MonthComponent);
    args.push(this.Position);
    args.push(this.Interval);
    args.push(this.Occurrences);
    args.push(this.TimePeriods);
    return args;
  }
};
var IfcReference = class {
  constructor(expressID, type, TypeIdentifier, AttributeIdentifier, InstanceName, ListPositions, InnerReference) {
    this.expressID = expressID;
    this.type = type;
    this.TypeIdentifier = TypeIdentifier;
    this.AttributeIdentifier = AttributeIdentifier;
    this.InstanceName = InstanceName;
    this.ListPositions = ListPositions;
    this.InnerReference = InnerReference;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TypeIdentifier = tape[ptr++];
    let AttributeIdentifier = tape[ptr++];
    let InstanceName = tape[ptr++];
    let ListPositions = tape[ptr++];
    let InnerReference = tape[ptr++];
    return new IfcReference(expressID, type, TypeIdentifier, AttributeIdentifier, InstanceName, ListPositions, InnerReference);
  }
  ToTape() {
    let args = [];
    args.push(this.TypeIdentifier);
    args.push(this.AttributeIdentifier);
    args.push(this.InstanceName);
    args.push(this.ListPositions);
    args.push(this.InnerReference);
    return args;
  }
};
var IfcReferent = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, RestartDistance) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.PredefinedType = PredefinedType;
    this.RestartDistance = RestartDistance;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let RestartDistance = tape[ptr++];
    return new IfcReferent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, RestartDistance);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.PredefinedType);
    args.push(this.RestartDistance);
    return args;
  }
};
var IfcRegularTimeSeries = class {
  constructor(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, TimeStep, Values) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.StartTime = StartTime;
    this.EndTime = EndTime;
    this.TimeSeriesDataType = TimeSeriesDataType;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.Unit = Unit;
    this.TimeStep = TimeStep;
    this.Values = Values;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let StartTime = tape[ptr++];
    let EndTime = tape[ptr++];
    let TimeSeriesDataType = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let Unit = tape[ptr++];
    let TimeStep = tape[ptr++];
    let Values = tape[ptr++];
    return new IfcRegularTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, TimeStep, Values);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.StartTime);
    args.push(this.EndTime);
    args.push(this.TimeSeriesDataType);
    args.push(this.DataOrigin);
    args.push(this.UserDefinedDataOrigin);
    args.push(this.Unit);
    args.push(this.TimeStep);
    args.push(this.Values);
    return args;
  }
};
var IfcReinforcementBarProperties = class {
  constructor(expressID, type, TotalCrossSectionArea, SteelGrade, BarSurface, EffectiveDepth, NominalBarDiameter, BarCount) {
    this.expressID = expressID;
    this.type = type;
    this.TotalCrossSectionArea = TotalCrossSectionArea;
    this.SteelGrade = SteelGrade;
    this.BarSurface = BarSurface;
    this.EffectiveDepth = EffectiveDepth;
    this.NominalBarDiameter = NominalBarDiameter;
    this.BarCount = BarCount;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TotalCrossSectionArea = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let BarSurface = tape[ptr++];
    let EffectiveDepth = tape[ptr++];
    let NominalBarDiameter = tape[ptr++];
    let BarCount = tape[ptr++];
    return new IfcReinforcementBarProperties(expressID, type, TotalCrossSectionArea, SteelGrade, BarSurface, EffectiveDepth, NominalBarDiameter, BarCount);
  }
  ToTape() {
    let args = [];
    args.push(this.TotalCrossSectionArea);
    args.push(this.SteelGrade);
    args.push(this.BarSurface);
    args.push(this.EffectiveDepth);
    args.push(this.NominalBarDiameter);
    args.push(this.BarCount);
    return args;
  }
};
var IfcReinforcementDefinitionProperties = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, DefinitionType, ReinforcementSectionDefinitions) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.DefinitionType = DefinitionType;
    this.ReinforcementSectionDefinitions = ReinforcementSectionDefinitions;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let DefinitionType = tape[ptr++];
    let ReinforcementSectionDefinitions = tape[ptr++];
    return new IfcReinforcementDefinitionProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, DefinitionType, ReinforcementSectionDefinitions);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.DefinitionType);
    args.push(this.ReinforcementSectionDefinitions);
    return args;
  }
};
var IfcReinforcingBar = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, NominalDiameter, CrossSectionArea, BarLength, PredefinedType, BarSurface) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
    this.NominalDiameter = NominalDiameter;
    this.CrossSectionArea = CrossSectionArea;
    this.BarLength = BarLength;
    this.PredefinedType = PredefinedType;
    this.BarSurface = BarSurface;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let CrossSectionArea = tape[ptr++];
    let BarLength = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let BarSurface = tape[ptr++];
    return new IfcReinforcingBar(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, NominalDiameter, CrossSectionArea, BarLength, PredefinedType, BarSurface);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.SteelGrade);
    args.push(this.NominalDiameter);
    args.push(this.CrossSectionArea);
    args.push(this.BarLength);
    args.push(this.PredefinedType);
    args.push(this.BarSurface);
    return args;
  }
};
var IfcReinforcingBarType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, BarLength, BarSurface, BendingShapeCode, BendingParameters) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.NominalDiameter = NominalDiameter;
    this.CrossSectionArea = CrossSectionArea;
    this.BarLength = BarLength;
    this.BarSurface = BarSurface;
    this.BendingShapeCode = BendingShapeCode;
    this.BendingParameters = BendingParameters;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let CrossSectionArea = tape[ptr++];
    let BarLength = tape[ptr++];
    let BarSurface = tape[ptr++];
    let BendingShapeCode = tape[ptr++];
    let BendingParameters = tape[ptr++];
    return new IfcReinforcingBarType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, BarLength, BarSurface, BendingShapeCode, BendingParameters);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    args.push(this.NominalDiameter);
    args.push(this.CrossSectionArea);
    args.push(this.BarLength);
    args.push(this.BarSurface);
    args.push(this.BendingShapeCode);
    args.push(this.BendingParameters);
    return args;
  }
};
var IfcReinforcingElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    return new IfcReinforcingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.SteelGrade);
    return args;
  }
};
var IfcReinforcingElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcReinforcingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcReinforcingMesh = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
    this.MeshLength = MeshLength;
    this.MeshWidth = MeshWidth;
    this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter;
    this.TransverseBarNominalDiameter = TransverseBarNominalDiameter;
    this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea;
    this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea;
    this.LongitudinalBarSpacing = LongitudinalBarSpacing;
    this.TransverseBarSpacing = TransverseBarSpacing;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let MeshLength = tape[ptr++];
    let MeshWidth = tape[ptr++];
    let LongitudinalBarNominalDiameter = tape[ptr++];
    let TransverseBarNominalDiameter = tape[ptr++];
    let LongitudinalBarCrossSectionArea = tape[ptr++];
    let TransverseBarCrossSectionArea = tape[ptr++];
    let LongitudinalBarSpacing = tape[ptr++];
    let TransverseBarSpacing = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcReinforcingMesh(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.SteelGrade);
    args.push(this.MeshLength);
    args.push(this.MeshWidth);
    args.push(this.LongitudinalBarNominalDiameter);
    args.push(this.TransverseBarNominalDiameter);
    args.push(this.LongitudinalBarCrossSectionArea);
    args.push(this.TransverseBarCrossSectionArea);
    args.push(this.LongitudinalBarSpacing);
    args.push(this.TransverseBarSpacing);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcReinforcingMeshType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, BendingShapeCode, BendingParameters) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.MeshLength = MeshLength;
    this.MeshWidth = MeshWidth;
    this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter;
    this.TransverseBarNominalDiameter = TransverseBarNominalDiameter;
    this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea;
    this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea;
    this.LongitudinalBarSpacing = LongitudinalBarSpacing;
    this.TransverseBarSpacing = TransverseBarSpacing;
    this.BendingShapeCode = BendingShapeCode;
    this.BendingParameters = BendingParameters;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let MeshLength = tape[ptr++];
    let MeshWidth = tape[ptr++];
    let LongitudinalBarNominalDiameter = tape[ptr++];
    let TransverseBarNominalDiameter = tape[ptr++];
    let LongitudinalBarCrossSectionArea = tape[ptr++];
    let TransverseBarCrossSectionArea = tape[ptr++];
    let LongitudinalBarSpacing = tape[ptr++];
    let TransverseBarSpacing = tape[ptr++];
    let BendingShapeCode = tape[ptr++];
    let BendingParameters = tape[ptr++];
    return new IfcReinforcingMeshType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, BendingShapeCode, BendingParameters);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    args.push(this.MeshLength);
    args.push(this.MeshWidth);
    args.push(this.LongitudinalBarNominalDiameter);
    args.push(this.TransverseBarNominalDiameter);
    args.push(this.LongitudinalBarCrossSectionArea);
    args.push(this.TransverseBarCrossSectionArea);
    args.push(this.LongitudinalBarSpacing);
    args.push(this.TransverseBarSpacing);
    args.push(this.BendingShapeCode);
    args.push(this.BendingParameters);
    return args;
  }
};
var IfcRelAggregates = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingObject = RelatingObject;
    this.RelatedObjects = RelatedObjects;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingObject = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    return new IfcRelAggregates(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingObject);
    args.push(this.RelatedObjects);
    return args;
  }
};
var IfcRelAssigns = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    return new IfcRelAssigns(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatedObjectsType);
    return args;
  }
};
var IfcRelAssignsToActor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingActor, ActingRole) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingActor = RelatingActor;
    this.ActingRole = ActingRole;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingActor = tape[ptr++];
    let ActingRole = tape[ptr++];
    return new IfcRelAssignsToActor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingActor, ActingRole);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatedObjectsType);
    args.push(this.RelatingActor);
    args.push(this.ActingRole);
    return args;
  }
};
var IfcRelAssignsToControl = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingControl) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingControl = RelatingControl;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingControl = tape[ptr++];
    return new IfcRelAssignsToControl(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingControl);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatedObjectsType);
    args.push(this.RelatingControl);
    return args;
  }
};
var IfcRelAssignsToGroup = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingGroup = RelatingGroup;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingGroup = tape[ptr++];
    return new IfcRelAssignsToGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatedObjectsType);
    args.push(this.RelatingGroup);
    return args;
  }
};
var IfcRelAssignsToGroupByFactor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup, Factor) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingGroup = RelatingGroup;
    this.Factor = Factor;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingGroup = tape[ptr++];
    let Factor = tape[ptr++];
    return new IfcRelAssignsToGroupByFactor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup, Factor);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatedObjectsType);
    args.push(this.RelatingGroup);
    args.push(this.Factor);
    return args;
  }
};
var IfcRelAssignsToProcess = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProcess, QuantityInProcess) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingProcess = RelatingProcess;
    this.QuantityInProcess = QuantityInProcess;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingProcess = tape[ptr++];
    let QuantityInProcess = tape[ptr++];
    return new IfcRelAssignsToProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProcess, QuantityInProcess);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatedObjectsType);
    args.push(this.RelatingProcess);
    args.push(this.QuantityInProcess);
    return args;
  }
};
var IfcRelAssignsToProduct = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProduct) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingProduct = RelatingProduct;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingProduct = tape[ptr++];
    return new IfcRelAssignsToProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProduct);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatedObjectsType);
    args.push(this.RelatingProduct);
    return args;
  }
};
var IfcRelAssignsToResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingResource) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingResource = RelatingResource;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingResource = tape[ptr++];
    return new IfcRelAssignsToResource(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingResource);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatedObjectsType);
    args.push(this.RelatingResource);
    return args;
  }
};
var IfcRelAssociates = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    return new IfcRelAssociates(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    return args;
  }
};
var IfcRelAssociatesApproval = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingApproval) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingApproval = RelatingApproval;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingApproval = tape[ptr++];
    return new IfcRelAssociatesApproval(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingApproval);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatingApproval);
    return args;
  }
};
var IfcRelAssociatesClassification = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingClassification) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingClassification = RelatingClassification;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingClassification = tape[ptr++];
    return new IfcRelAssociatesClassification(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingClassification);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatingClassification);
    return args;
  }
};
var IfcRelAssociatesConstraint = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, Intent, RelatingConstraint) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.Intent = Intent;
    this.RelatingConstraint = RelatingConstraint;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let Intent = tape[ptr++];
    let RelatingConstraint = tape[ptr++];
    return new IfcRelAssociatesConstraint(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, Intent, RelatingConstraint);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.Intent);
    args.push(this.RelatingConstraint);
    return args;
  }
};
var IfcRelAssociatesDocument = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingDocument) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingDocument = RelatingDocument;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingDocument = tape[ptr++];
    return new IfcRelAssociatesDocument(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingDocument);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatingDocument);
    return args;
  }
};
var IfcRelAssociatesLibrary = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingLibrary) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingLibrary = RelatingLibrary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingLibrary = tape[ptr++];
    return new IfcRelAssociatesLibrary(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingLibrary);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatingLibrary);
    return args;
  }
};
var IfcRelAssociatesMaterial = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingMaterial) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingMaterial = RelatingMaterial;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingMaterial = tape[ptr++];
    return new IfcRelAssociatesMaterial(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingMaterial);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatingMaterial);
    return args;
  }
};
var IfcRelConnects = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcRelConnects(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcRelConnectsElements = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ConnectionGeometry = ConnectionGeometry;
    this.RelatingElement = RelatingElement;
    this.RelatedElement = RelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedElement = tape[ptr++];
    return new IfcRelConnectsElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ConnectionGeometry);
    args.push(this.RelatingElement);
    args.push(this.RelatedElement);
    return args;
  }
};
var IfcRelConnectsPathElements = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RelatingPriorities, RelatedPriorities, RelatedConnectionType, RelatingConnectionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ConnectionGeometry = ConnectionGeometry;
    this.RelatingElement = RelatingElement;
    this.RelatedElement = RelatedElement;
    this.RelatingPriorities = RelatingPriorities;
    this.RelatedPriorities = RelatedPriorities;
    this.RelatedConnectionType = RelatedConnectionType;
    this.RelatingConnectionType = RelatingConnectionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedElement = tape[ptr++];
    let RelatingPriorities = tape[ptr++];
    let RelatedPriorities = tape[ptr++];
    let RelatedConnectionType = tape[ptr++];
    let RelatingConnectionType = tape[ptr++];
    return new IfcRelConnectsPathElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RelatingPriorities, RelatedPriorities, RelatedConnectionType, RelatingConnectionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ConnectionGeometry);
    args.push(this.RelatingElement);
    args.push(this.RelatedElement);
    args.push(this.RelatingPriorities);
    args.push(this.RelatedPriorities);
    args.push(this.RelatedConnectionType);
    args.push(this.RelatingConnectionType);
    return args;
  }
};
var IfcRelConnectsPortToElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingPort = RelatingPort;
    this.RelatedElement = RelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingPort = tape[ptr++];
    let RelatedElement = tape[ptr++];
    return new IfcRelConnectsPortToElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingPort);
    args.push(this.RelatedElement);
    return args;
  }
};
var IfcRelConnectsPorts = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedPort, RealizingElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingPort = RelatingPort;
    this.RelatedPort = RelatedPort;
    this.RealizingElement = RealizingElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingPort = tape[ptr++];
    let RelatedPort = tape[ptr++];
    let RealizingElement = tape[ptr++];
    return new IfcRelConnectsPorts(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedPort, RealizingElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingPort);
    args.push(this.RelatedPort);
    args.push(this.RealizingElement);
    return args;
  }
};
var IfcRelConnectsStructuralActivity = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedStructuralActivity) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingElement = RelatingElement;
    this.RelatedStructuralActivity = RelatedStructuralActivity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedStructuralActivity = tape[ptr++];
    return new IfcRelConnectsStructuralActivity(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedStructuralActivity);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingElement);
    args.push(this.RelatedStructuralActivity);
    return args;
  }
};
var IfcRelConnectsStructuralMember = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingStructuralMember = RelatingStructuralMember;
    this.RelatedStructuralConnection = RelatedStructuralConnection;
    this.AppliedCondition = AppliedCondition;
    this.AdditionalConditions = AdditionalConditions;
    this.SupportedLength = SupportedLength;
    this.ConditionCoordinateSystem = ConditionCoordinateSystem;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingStructuralMember = tape[ptr++];
    let RelatedStructuralConnection = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    let AdditionalConditions = tape[ptr++];
    let SupportedLength = tape[ptr++];
    let ConditionCoordinateSystem = tape[ptr++];
    return new IfcRelConnectsStructuralMember(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingStructuralMember);
    args.push(this.RelatedStructuralConnection);
    args.push(this.AppliedCondition);
    args.push(this.AdditionalConditions);
    args.push(this.SupportedLength);
    args.push(this.ConditionCoordinateSystem);
    return args;
  }
};
var IfcRelConnectsWithEccentricity = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem, ConnectionConstraint) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingStructuralMember = RelatingStructuralMember;
    this.RelatedStructuralConnection = RelatedStructuralConnection;
    this.AppliedCondition = AppliedCondition;
    this.AdditionalConditions = AdditionalConditions;
    this.SupportedLength = SupportedLength;
    this.ConditionCoordinateSystem = ConditionCoordinateSystem;
    this.ConnectionConstraint = ConnectionConstraint;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingStructuralMember = tape[ptr++];
    let RelatedStructuralConnection = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    let AdditionalConditions = tape[ptr++];
    let SupportedLength = tape[ptr++];
    let ConditionCoordinateSystem = tape[ptr++];
    let ConnectionConstraint = tape[ptr++];
    return new IfcRelConnectsWithEccentricity(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem, ConnectionConstraint);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingStructuralMember);
    args.push(this.RelatedStructuralConnection);
    args.push(this.AppliedCondition);
    args.push(this.AdditionalConditions);
    args.push(this.SupportedLength);
    args.push(this.ConditionCoordinateSystem);
    args.push(this.ConnectionConstraint);
    return args;
  }
};
var IfcRelConnectsWithRealizingElements = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RealizingElements, ConnectionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ConnectionGeometry = ConnectionGeometry;
    this.RelatingElement = RelatingElement;
    this.RelatedElement = RelatedElement;
    this.RealizingElements = RealizingElements;
    this.ConnectionType = ConnectionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedElement = tape[ptr++];
    let RealizingElements = tape[ptr++];
    let ConnectionType = tape[ptr++];
    return new IfcRelConnectsWithRealizingElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RealizingElements, ConnectionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ConnectionGeometry);
    args.push(this.RelatingElement);
    args.push(this.RelatedElement);
    args.push(this.RealizingElements);
    args.push(this.ConnectionType);
    return args;
  }
};
var IfcRelContainedInSpatialStructure = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedElements = RelatedElements;
    this.RelatingStructure = RelatingStructure;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedElements = tape[ptr++];
    let RelatingStructure = tape[ptr++];
    return new IfcRelContainedInSpatialStructure(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedElements);
    args.push(this.RelatingStructure);
    return args;
  }
};
var IfcRelCoversBldgElements = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedCoverings) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingBuildingElement = RelatingBuildingElement;
    this.RelatedCoverings = RelatedCoverings;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingBuildingElement = tape[ptr++];
    let RelatedCoverings = tape[ptr++];
    return new IfcRelCoversBldgElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedCoverings);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingBuildingElement);
    args.push(this.RelatedCoverings);
    return args;
  }
};
var IfcRelCoversSpaces = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedCoverings) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingSpace = RelatingSpace;
    this.RelatedCoverings = RelatedCoverings;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingSpace = tape[ptr++];
    let RelatedCoverings = tape[ptr++];
    return new IfcRelCoversSpaces(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedCoverings);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingSpace);
    args.push(this.RelatedCoverings);
    return args;
  }
};
var IfcRelDeclares = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingContext, RelatedDefinitions) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingContext = RelatingContext;
    this.RelatedDefinitions = RelatedDefinitions;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingContext = tape[ptr++];
    let RelatedDefinitions = tape[ptr++];
    return new IfcRelDeclares(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingContext, RelatedDefinitions);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingContext);
    args.push(this.RelatedDefinitions);
    return args;
  }
};
var IfcRelDecomposes = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcRelDecomposes(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcRelDefines = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcRelDefines(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcRelDefinesByObject = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingObject) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingObject = RelatingObject;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingObject = tape[ptr++];
    return new IfcRelDefinesByObject(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingObject);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatingObject);
    return args;
  }
};
var IfcRelDefinesByProperties = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingPropertyDefinition) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingPropertyDefinition = RelatingPropertyDefinition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingPropertyDefinition = tape[ptr++];
    return new IfcRelDefinesByProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingPropertyDefinition);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatingPropertyDefinition);
    return args;
  }
};
var IfcRelDefinesByTemplate = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedPropertySets, RelatingTemplate) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedPropertySets = RelatedPropertySets;
    this.RelatingTemplate = RelatingTemplate;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedPropertySets = tape[ptr++];
    let RelatingTemplate = tape[ptr++];
    return new IfcRelDefinesByTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedPropertySets, RelatingTemplate);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedPropertySets);
    args.push(this.RelatingTemplate);
    return args;
  }
};
var IfcRelDefinesByType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingType = RelatingType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingType = tape[ptr++];
    return new IfcRelDefinesByType(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatingType);
    return args;
  }
};
var IfcRelFillsElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingOpeningElement, RelatedBuildingElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingOpeningElement = RelatingOpeningElement;
    this.RelatedBuildingElement = RelatedBuildingElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingOpeningElement = tape[ptr++];
    let RelatedBuildingElement = tape[ptr++];
    return new IfcRelFillsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingOpeningElement, RelatedBuildingElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingOpeningElement);
    args.push(this.RelatedBuildingElement);
    return args;
  }
};
var IfcRelFlowControlElements = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedControlElements, RelatingFlowElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedControlElements = RelatedControlElements;
    this.RelatingFlowElement = RelatingFlowElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedControlElements = tape[ptr++];
    let RelatingFlowElement = tape[ptr++];
    return new IfcRelFlowControlElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedControlElements, RelatingFlowElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedControlElements);
    args.push(this.RelatingFlowElement);
    return args;
  }
};
var IfcRelInterferesElements = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedElement, InterferenceGeometry, InterferenceType, ImpliedOrder) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingElement = RelatingElement;
    this.RelatedElement = RelatedElement;
    this.InterferenceGeometry = InterferenceGeometry;
    this.InterferenceType = InterferenceType;
    this.ImpliedOrder = ImpliedOrder;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedElement = tape[ptr++];
    let InterferenceGeometry = tape[ptr++];
    let InterferenceType = tape[ptr++];
    let ImpliedOrder = tape[ptr++];
    return new IfcRelInterferesElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedElement, InterferenceGeometry, InterferenceType, ImpliedOrder);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingElement);
    args.push(this.RelatedElement);
    args.push(this.InterferenceGeometry);
    args.push(this.InterferenceType);
    args.push(this.ImpliedOrder);
    return args;
  }
};
var IfcRelNests = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingObject = RelatingObject;
    this.RelatedObjects = RelatedObjects;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingObject = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    return new IfcRelNests(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingObject);
    args.push(this.RelatedObjects);
    return args;
  }
};
var IfcRelPositions = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPositioningElement, RelatedProducts) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingPositioningElement = RelatingPositioningElement;
    this.RelatedProducts = RelatedProducts;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingPositioningElement = tape[ptr++];
    let RelatedProducts = tape[ptr++];
    return new IfcRelPositions(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPositioningElement, RelatedProducts);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingPositioningElement);
    args.push(this.RelatedProducts);
    return args;
  }
};
var IfcRelProjectsElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedFeatureElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingElement = RelatingElement;
    this.RelatedFeatureElement = RelatedFeatureElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedFeatureElement = tape[ptr++];
    return new IfcRelProjectsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedFeatureElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingElement);
    args.push(this.RelatedFeatureElement);
    return args;
  }
};
var IfcRelReferencedInSpatialStructure = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedElements = RelatedElements;
    this.RelatingStructure = RelatingStructure;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedElements = tape[ptr++];
    let RelatingStructure = tape[ptr++];
    return new IfcRelReferencedInSpatialStructure(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedElements);
    args.push(this.RelatingStructure);
    return args;
  }
};
var IfcRelSequence = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingProcess, RelatedProcess, TimeLag, SequenceType, UserDefinedSequenceType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingProcess = RelatingProcess;
    this.RelatedProcess = RelatedProcess;
    this.TimeLag = TimeLag;
    this.SequenceType = SequenceType;
    this.UserDefinedSequenceType = UserDefinedSequenceType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingProcess = tape[ptr++];
    let RelatedProcess = tape[ptr++];
    let TimeLag = tape[ptr++];
    let SequenceType = tape[ptr++];
    let UserDefinedSequenceType = tape[ptr++];
    return new IfcRelSequence(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingProcess, RelatedProcess, TimeLag, SequenceType, UserDefinedSequenceType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingProcess);
    args.push(this.RelatedProcess);
    args.push(this.TimeLag);
    args.push(this.SequenceType);
    args.push(this.UserDefinedSequenceType);
    return args;
  }
};
var IfcRelServicesBuildings = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSystem, RelatedBuildings) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingSystem = RelatingSystem;
    this.RelatedBuildings = RelatedBuildings;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingSystem = tape[ptr++];
    let RelatedBuildings = tape[ptr++];
    return new IfcRelServicesBuildings(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSystem, RelatedBuildings);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingSystem);
    args.push(this.RelatedBuildings);
    return args;
  }
};
var IfcRelSpaceBoundary = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingSpace = RelatingSpace;
    this.RelatedBuildingElement = RelatedBuildingElement;
    this.ConnectionGeometry = ConnectionGeometry;
    this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
    this.InternalOrExternalBoundary = InternalOrExternalBoundary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingSpace = tape[ptr++];
    let RelatedBuildingElement = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let PhysicalOrVirtualBoundary = tape[ptr++];
    let InternalOrExternalBoundary = tape[ptr++];
    return new IfcRelSpaceBoundary(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingSpace);
    args.push(this.RelatedBuildingElement);
    args.push(this.ConnectionGeometry);
    args.push(this.PhysicalOrVirtualBoundary);
    args.push(this.InternalOrExternalBoundary);
    return args;
  }
};
var IfcRelSpaceBoundary1stLevel = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingSpace = RelatingSpace;
    this.RelatedBuildingElement = RelatedBuildingElement;
    this.ConnectionGeometry = ConnectionGeometry;
    this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
    this.InternalOrExternalBoundary = InternalOrExternalBoundary;
    this.ParentBoundary = ParentBoundary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingSpace = tape[ptr++];
    let RelatedBuildingElement = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let PhysicalOrVirtualBoundary = tape[ptr++];
    let InternalOrExternalBoundary = tape[ptr++];
    let ParentBoundary = tape[ptr++];
    return new IfcRelSpaceBoundary1stLevel(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingSpace);
    args.push(this.RelatedBuildingElement);
    args.push(this.ConnectionGeometry);
    args.push(this.PhysicalOrVirtualBoundary);
    args.push(this.InternalOrExternalBoundary);
    args.push(this.ParentBoundary);
    return args;
  }
};
var IfcRelSpaceBoundary2ndLevel = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary, CorrespondingBoundary) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingSpace = RelatingSpace;
    this.RelatedBuildingElement = RelatedBuildingElement;
    this.ConnectionGeometry = ConnectionGeometry;
    this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
    this.InternalOrExternalBoundary = InternalOrExternalBoundary;
    this.ParentBoundary = ParentBoundary;
    this.CorrespondingBoundary = CorrespondingBoundary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingSpace = tape[ptr++];
    let RelatedBuildingElement = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let PhysicalOrVirtualBoundary = tape[ptr++];
    let InternalOrExternalBoundary = tape[ptr++];
    let ParentBoundary = tape[ptr++];
    let CorrespondingBoundary = tape[ptr++];
    return new IfcRelSpaceBoundary2ndLevel(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary, CorrespondingBoundary);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingSpace);
    args.push(this.RelatedBuildingElement);
    args.push(this.ConnectionGeometry);
    args.push(this.PhysicalOrVirtualBoundary);
    args.push(this.InternalOrExternalBoundary);
    args.push(this.ParentBoundary);
    args.push(this.CorrespondingBoundary);
    return args;
  }
};
var IfcRelVoidsElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedOpeningElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingBuildingElement = RelatingBuildingElement;
    this.RelatedOpeningElement = RelatedOpeningElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingBuildingElement = tape[ptr++];
    let RelatedOpeningElement = tape[ptr++];
    return new IfcRelVoidsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedOpeningElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingBuildingElement);
    args.push(this.RelatedOpeningElement);
    return args;
  }
};
var IfcRelationship = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcRelationship(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcReparametrisedCompositeCurveSegment = class {
  constructor(expressID, type, Transition, SameSense, ParentCurve, ParamLength) {
    this.expressID = expressID;
    this.type = type;
    this.Transition = Transition;
    this.SameSense = SameSense;
    this.ParentCurve = ParentCurve;
    this.ParamLength = ParamLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Transition = tape[ptr++];
    let SameSense = tape[ptr++];
    let ParentCurve = tape[ptr++];
    let ParamLength = tape[ptr++];
    return new IfcReparametrisedCompositeCurveSegment(expressID, type, Transition, SameSense, ParentCurve, ParamLength);
  }
  ToTape() {
    let args = [];
    args.push(this.Transition);
    args.push(this.SameSense);
    args.push(this.ParentCurve);
    args.push(this.ParamLength);
    return args;
  }
};
var IfcRepresentation = class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    args.push(this.RepresentationIdentifier);
    args.push(this.RepresentationType);
    args.push(this.Items);
    return args;
  }
};
var IfcRepresentationContext = class {
  constructor(expressID, type, ContextIdentifier, ContextType) {
    this.expressID = expressID;
    this.type = type;
    this.ContextIdentifier = ContextIdentifier;
    this.ContextType = ContextType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextIdentifier = tape[ptr++];
    let ContextType = tape[ptr++];
    return new IfcRepresentationContext(expressID, type, ContextIdentifier, ContextType);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextIdentifier);
    args.push(this.ContextType);
    return args;
  }
};
var IfcRepresentationItem = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcRepresentationItem(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcRepresentationMap = class {
  constructor(expressID, type, MappingOrigin, MappedRepresentation) {
    this.expressID = expressID;
    this.type = type;
    this.MappingOrigin = MappingOrigin;
    this.MappedRepresentation = MappedRepresentation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MappingOrigin = tape[ptr++];
    let MappedRepresentation = tape[ptr++];
    return new IfcRepresentationMap(expressID, type, MappingOrigin, MappedRepresentation);
  }
  ToTape() {
    let args = [];
    args.push(this.MappingOrigin);
    args.push(this.MappedRepresentation);
    return args;
  }
};
var IfcResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    return new IfcResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    return args;
  }
};
var IfcResourceApprovalRelationship = class {
  constructor(expressID, type, Name, Description, RelatedResourceObjects, RelatingApproval) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatedResourceObjects = RelatedResourceObjects;
    this.RelatingApproval = RelatingApproval;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedResourceObjects = tape[ptr++];
    let RelatingApproval = tape[ptr++];
    return new IfcResourceApprovalRelationship(expressID, type, Name, Description, RelatedResourceObjects, RelatingApproval);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedResourceObjects);
    args.push(this.RelatingApproval);
    return args;
  }
};
var IfcResourceConstraintRelationship = class {
  constructor(expressID, type, Name, Description, RelatingConstraint, RelatedResourceObjects) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingConstraint = RelatingConstraint;
    this.RelatedResourceObjects = RelatedResourceObjects;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingConstraint = tape[ptr++];
    let RelatedResourceObjects = tape[ptr++];
    return new IfcResourceConstraintRelationship(expressID, type, Name, Description, RelatingConstraint, RelatedResourceObjects);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingConstraint);
    args.push(this.RelatedResourceObjects);
    return args;
  }
};
var IfcResourceLevelRelationship = class {
  constructor(expressID, type, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcResourceLevelRelationship(expressID, type, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcResourceTime = class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ScheduleWork, ScheduleUsage, ScheduleStart, ScheduleFinish, ScheduleContour, LevelingDelay, IsOverAllocated, StatusTime, ActualWork, ActualUsage, ActualStart, ActualFinish, RemainingWork, RemainingUsage, Completion) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.ScheduleWork = ScheduleWork;
    this.ScheduleUsage = ScheduleUsage;
    this.ScheduleStart = ScheduleStart;
    this.ScheduleFinish = ScheduleFinish;
    this.ScheduleContour = ScheduleContour;
    this.LevelingDelay = LevelingDelay;
    this.IsOverAllocated = IsOverAllocated;
    this.StatusTime = StatusTime;
    this.ActualWork = ActualWork;
    this.ActualUsage = ActualUsage;
    this.ActualStart = ActualStart;
    this.ActualFinish = ActualFinish;
    this.RemainingWork = RemainingWork;
    this.RemainingUsage = RemainingUsage;
    this.Completion = Completion;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let ScheduleWork = tape[ptr++];
    let ScheduleUsage = tape[ptr++];
    let ScheduleStart = tape[ptr++];
    let ScheduleFinish = tape[ptr++];
    let ScheduleContour = tape[ptr++];
    let LevelingDelay = tape[ptr++];
    let IsOverAllocated = tape[ptr++];
    let StatusTime = tape[ptr++];
    let ActualWork = tape[ptr++];
    let ActualUsage = tape[ptr++];
    let ActualStart = tape[ptr++];
    let ActualFinish = tape[ptr++];
    let RemainingWork = tape[ptr++];
    let RemainingUsage = tape[ptr++];
    let Completion = tape[ptr++];
    return new IfcResourceTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ScheduleWork, ScheduleUsage, ScheduleStart, ScheduleFinish, ScheduleContour, LevelingDelay, IsOverAllocated, StatusTime, ActualWork, ActualUsage, ActualStart, ActualFinish, RemainingWork, RemainingUsage, Completion);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.DataOrigin);
    args.push(this.UserDefinedDataOrigin);
    args.push(this.ScheduleWork);
    args.push(this.ScheduleUsage);
    args.push(this.ScheduleStart);
    args.push(this.ScheduleFinish);
    args.push(this.ScheduleContour);
    args.push(this.LevelingDelay);
    args.push(this.IsOverAllocated);
    args.push(this.StatusTime);
    args.push(this.ActualWork);
    args.push(this.ActualUsage);
    args.push(this.ActualStart);
    args.push(this.ActualFinish);
    args.push(this.RemainingWork);
    args.push(this.RemainingUsage);
    args.push(this.Completion);
    return args;
  }
};
var IfcRevolvedAreaSolid = class {
  constructor(expressID, type, SweptArea, Position, Axis, Angle) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.Axis = Axis;
    this.Angle = Angle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let Axis = tape[ptr++];
    let Angle = tape[ptr++];
    return new IfcRevolvedAreaSolid(expressID, type, SweptArea, Position, Axis, Angle);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    args.push(this.Position);
    args.push(this.Axis);
    args.push(this.Angle);
    return args;
  }
};
var IfcRevolvedAreaSolidTapered = class {
  constructor(expressID, type, SweptArea, Position, Axis, Angle, EndSweptArea) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.Axis = Axis;
    this.Angle = Angle;
    this.EndSweptArea = EndSweptArea;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let Axis = tape[ptr++];
    let Angle = tape[ptr++];
    let EndSweptArea = tape[ptr++];
    return new IfcRevolvedAreaSolidTapered(expressID, type, SweptArea, Position, Axis, Angle, EndSweptArea);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    args.push(this.Position);
    args.push(this.Axis);
    args.push(this.Angle);
    args.push(this.EndSweptArea);
    return args;
  }
};
var IfcRightCircularCone = class {
  constructor(expressID, type, Position, Height, BottomRadius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Height = Height;
    this.BottomRadius = BottomRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Height = tape[ptr++];
    let BottomRadius = tape[ptr++];
    return new IfcRightCircularCone(expressID, type, Position, Height, BottomRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    args.push(this.Height);
    args.push(this.BottomRadius);
    return args;
  }
};
var IfcRightCircularCylinder = class {
  constructor(expressID, type, Position, Height, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Height = Height;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Height = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcRightCircularCylinder(expressID, type, Position, Height, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    args.push(this.Height);
    args.push(this.Radius);
    return args;
  }
};
var IfcRoof = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRoof(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcRoofType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRoofType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcRoot = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcRoot(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcRoundedRectangleProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, RoundingRadius) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.XDim = XDim;
    this.YDim = YDim;
    this.RoundingRadius = RoundingRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let XDim = tape[ptr++];
    let YDim = tape[ptr++];
    let RoundingRadius = tape[ptr++];
    return new IfcRoundedRectangleProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, RoundingRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.XDim);
    args.push(this.YDim);
    args.push(this.RoundingRadius);
    return args;
  }
};
var IfcSIUnit = class {
  constructor(expressID, type, Dimensions, UnitType, Prefix, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Dimensions = Dimensions;
    this.UnitType = UnitType;
    this.Prefix = Prefix;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Dimensions = tape[ptr++];
    let UnitType = tape[ptr++];
    let Prefix = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcSIUnit(expressID, type, Dimensions, UnitType, Prefix, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Dimensions);
    args.push(this.UnitType);
    args.push(this.Prefix);
    args.push(this.Name);
    return args;
  }
};
var IfcSanitaryTerminal = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSanitaryTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSanitaryTerminalType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSanitaryTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSchedulingTime = class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    return new IfcSchedulingTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.DataOrigin);
    args.push(this.UserDefinedDataOrigin);
    return args;
  }
};
var IfcSeamCurve = class {
  constructor(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation) {
    this.expressID = expressID;
    this.type = type;
    this.Curve3D = Curve3D;
    this.AssociatedGeometry = AssociatedGeometry;
    this.MasterRepresentation = MasterRepresentation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Curve3D = tape[ptr++];
    let AssociatedGeometry = tape[ptr++];
    let MasterRepresentation = tape[ptr++];
    return new IfcSeamCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation);
  }
  ToTape() {
    let args = [];
    args.push(this.Curve3D);
    args.push(this.AssociatedGeometry);
    args.push(this.MasterRepresentation);
    return args;
  }
};
var IfcSectionProperties = class {
  constructor(expressID, type, SectionType, StartProfile, EndProfile) {
    this.expressID = expressID;
    this.type = type;
    this.SectionType = SectionType;
    this.StartProfile = StartProfile;
    this.EndProfile = EndProfile;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SectionType = tape[ptr++];
    let StartProfile = tape[ptr++];
    let EndProfile = tape[ptr++];
    return new IfcSectionProperties(expressID, type, SectionType, StartProfile, EndProfile);
  }
  ToTape() {
    let args = [];
    args.push(this.SectionType);
    args.push(this.StartProfile);
    args.push(this.EndProfile);
    return args;
  }
};
var IfcSectionReinforcementProperties = class {
  constructor(expressID, type, LongitudinalStartPosition, LongitudinalEndPosition, TransversePosition, ReinforcementRole, SectionDefinition, CrossSectionReinforcementDefinitions) {
    this.expressID = expressID;
    this.type = type;
    this.LongitudinalStartPosition = LongitudinalStartPosition;
    this.LongitudinalEndPosition = LongitudinalEndPosition;
    this.TransversePosition = TransversePosition;
    this.ReinforcementRole = ReinforcementRole;
    this.SectionDefinition = SectionDefinition;
    this.CrossSectionReinforcementDefinitions = CrossSectionReinforcementDefinitions;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let LongitudinalStartPosition = tape[ptr++];
    let LongitudinalEndPosition = tape[ptr++];
    let TransversePosition = tape[ptr++];
    let ReinforcementRole = tape[ptr++];
    let SectionDefinition = tape[ptr++];
    let CrossSectionReinforcementDefinitions = tape[ptr++];
    return new IfcSectionReinforcementProperties(expressID, type, LongitudinalStartPosition, LongitudinalEndPosition, TransversePosition, ReinforcementRole, SectionDefinition, CrossSectionReinforcementDefinitions);
  }
  ToTape() {
    let args = [];
    args.push(this.LongitudinalStartPosition);
    args.push(this.LongitudinalEndPosition);
    args.push(this.TransversePosition);
    args.push(this.ReinforcementRole);
    args.push(this.SectionDefinition);
    args.push(this.CrossSectionReinforcementDefinitions);
    return args;
  }
};
var IfcSectionedSolid = class {
  constructor(expressID, type, Directrix, CrossSections) {
    this.expressID = expressID;
    this.type = type;
    this.Directrix = Directrix;
    this.CrossSections = CrossSections;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Directrix = tape[ptr++];
    let CrossSections = tape[ptr++];
    return new IfcSectionedSolid(expressID, type, Directrix, CrossSections);
  }
  ToTape() {
    let args = [];
    args.push(this.Directrix);
    args.push(this.CrossSections);
    return args;
  }
};
var IfcSectionedSolidHorizontal = class {
  constructor(expressID, type, Directrix, CrossSections, CrossSectionPositions, FixedAxisVertical) {
    this.expressID = expressID;
    this.type = type;
    this.Directrix = Directrix;
    this.CrossSections = CrossSections;
    this.CrossSectionPositions = CrossSectionPositions;
    this.FixedAxisVertical = FixedAxisVertical;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Directrix = tape[ptr++];
    let CrossSections = tape[ptr++];
    let CrossSectionPositions = tape[ptr++];
    let FixedAxisVertical = tape[ptr++];
    return new IfcSectionedSolidHorizontal(expressID, type, Directrix, CrossSections, CrossSectionPositions, FixedAxisVertical);
  }
  ToTape() {
    let args = [];
    args.push(this.Directrix);
    args.push(this.CrossSections);
    args.push(this.CrossSectionPositions);
    args.push(this.FixedAxisVertical);
    return args;
  }
};
var IfcSectionedSpine = class {
  constructor(expressID, type, SpineCurve, CrossSections, CrossSectionPositions) {
    this.expressID = expressID;
    this.type = type;
    this.SpineCurve = SpineCurve;
    this.CrossSections = CrossSections;
    this.CrossSectionPositions = CrossSectionPositions;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SpineCurve = tape[ptr++];
    let CrossSections = tape[ptr++];
    let CrossSectionPositions = tape[ptr++];
    return new IfcSectionedSpine(expressID, type, SpineCurve, CrossSections, CrossSectionPositions);
  }
  ToTape() {
    let args = [];
    args.push(this.SpineCurve);
    args.push(this.CrossSections);
    args.push(this.CrossSectionPositions);
    return args;
  }
};
var IfcSensor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSensor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSensorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSensorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcShadingDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcShadingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcShadingDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcShadingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcShapeAspect = class {
  constructor(expressID, type, ShapeRepresentations, Name, Description, ProductDefinitional, PartOfProductDefinitionShape) {
    this.expressID = expressID;
    this.type = type;
    this.ShapeRepresentations = ShapeRepresentations;
    this.Name = Name;
    this.Description = Description;
    this.ProductDefinitional = ProductDefinitional;
    this.PartOfProductDefinitionShape = PartOfProductDefinitionShape;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ShapeRepresentations = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ProductDefinitional = tape[ptr++];
    let PartOfProductDefinitionShape = tape[ptr++];
    return new IfcShapeAspect(expressID, type, ShapeRepresentations, Name, Description, ProductDefinitional, PartOfProductDefinitionShape);
  }
  ToTape() {
    let args = [];
    args.push(this.ShapeRepresentations);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ProductDefinitional);
    args.push(this.PartOfProductDefinitionShape);
    return args;
  }
};
var IfcShapeModel = class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcShapeModel(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    args.push(this.RepresentationIdentifier);
    args.push(this.RepresentationType);
    args.push(this.Items);
    return args;
  }
};
var IfcShapeRepresentation = class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcShapeRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    args.push(this.RepresentationIdentifier);
    args.push(this.RepresentationType);
    args.push(this.Items);
    return args;
  }
};
var IfcShellBasedSurfaceModel = class {
  constructor(expressID, type, SbsmBoundary) {
    this.expressID = expressID;
    this.type = type;
    this.SbsmBoundary = SbsmBoundary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SbsmBoundary = tape[ptr++];
    return new IfcShellBasedSurfaceModel(expressID, type, SbsmBoundary);
  }
  ToTape() {
    let args = [];
    args.push(this.SbsmBoundary);
    return args;
  }
};
var IfcSimpleProperty = class {
  constructor(expressID, type, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcSimpleProperty(expressID, type, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcSimplePropertyTemplate = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, PrimaryMeasureType, SecondaryMeasureType, Enumerators, PrimaryUnit, SecondaryUnit, Expression, AccessState) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.TemplateType = TemplateType;
    this.PrimaryMeasureType = PrimaryMeasureType;
    this.SecondaryMeasureType = SecondaryMeasureType;
    this.Enumerators = Enumerators;
    this.PrimaryUnit = PrimaryUnit;
    this.SecondaryUnit = SecondaryUnit;
    this.Expression = Expression;
    this.AccessState = AccessState;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let TemplateType = tape[ptr++];
    let PrimaryMeasureType = tape[ptr++];
    let SecondaryMeasureType = tape[ptr++];
    let Enumerators = tape[ptr++];
    let PrimaryUnit = tape[ptr++];
    let SecondaryUnit = tape[ptr++];
    let Expression = tape[ptr++];
    let AccessState = tape[ptr++];
    return new IfcSimplePropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, PrimaryMeasureType, SecondaryMeasureType, Enumerators, PrimaryUnit, SecondaryUnit, Expression, AccessState);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.TemplateType);
    args.push(this.PrimaryMeasureType);
    args.push(this.SecondaryMeasureType);
    args.push(this.Enumerators);
    args.push(this.PrimaryUnit);
    args.push(this.SecondaryUnit);
    args.push(this.Expression);
    args.push(this.AccessState);
    return args;
  }
};
var IfcSite = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, RefLatitude, RefLongitude, RefElevation, LandTitleNumber, SiteAddress) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.RefLatitude = RefLatitude;
    this.RefLongitude = RefLongitude;
    this.RefElevation = RefElevation;
    this.LandTitleNumber = LandTitleNumber;
    this.SiteAddress = SiteAddress;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let RefLatitude = tape[ptr++];
    let RefLongitude = tape[ptr++];
    let RefElevation = tape[ptr++];
    let LandTitleNumber = tape[ptr++];
    let SiteAddress = tape[ptr++];
    return new IfcSite(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, RefLatitude, RefLongitude, RefElevation, LandTitleNumber, SiteAddress);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.CompositionType);
    args.push(this.RefLatitude);
    args.push(this.RefLongitude);
    args.push(this.RefElevation);
    args.push(this.LandTitleNumber);
    args.push(this.SiteAddress);
    return args;
  }
};
var IfcSlab = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSlab(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSlabElementedCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSlabElementedCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSlabStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSlabStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSlabType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSlabType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSlippageConnectionCondition = class {
  constructor(expressID, type, Name, SlippageX, SlippageY, SlippageZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.SlippageX = SlippageX;
    this.SlippageY = SlippageY;
    this.SlippageZ = SlippageZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let SlippageX = tape[ptr++];
    let SlippageY = tape[ptr++];
    let SlippageZ = tape[ptr++];
    return new IfcSlippageConnectionCondition(expressID, type, Name, SlippageX, SlippageY, SlippageZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.SlippageX);
    args.push(this.SlippageY);
    args.push(this.SlippageZ);
    return args;
  }
};
var IfcSolarDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSolarDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSolarDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSolarDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSolidModel = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcSolidModel(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcSpace = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType, ElevationWithFlooring) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.PredefinedType = PredefinedType;
    this.ElevationWithFlooring = ElevationWithFlooring;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let ElevationWithFlooring = tape[ptr++];
    return new IfcSpace(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType, ElevationWithFlooring);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.CompositionType);
    args.push(this.PredefinedType);
    args.push(this.ElevationWithFlooring);
    return args;
  }
};
var IfcSpaceHeater = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSpaceHeater(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSpaceHeaterType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSpaceHeaterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSpaceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcSpaceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    args.push(this.LongName);
    return args;
  }
};
var IfcSpatialElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcSpatialElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    return args;
  }
};
var IfcSpatialElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcSpatialElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcSpatialStructureElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    return new IfcSpatialStructureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.CompositionType);
    return args;
  }
};
var IfcSpatialStructureElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcSpatialStructureElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcSpatialZone = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSpatialZone(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSpatialZoneType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcSpatialZoneType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    args.push(this.LongName);
    return args;
  }
};
var IfcSphere = class {
  constructor(expressID, type, Position, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcSphere(expressID, type, Position, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    args.push(this.Radius);
    return args;
  }
};
var IfcSphericalSurface = class {
  constructor(expressID, type, Position, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcSphericalSurface(expressID, type, Position, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    args.push(this.Radius);
    return args;
  }
};
var IfcStackTerminal = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStackTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStackTerminalType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStackTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStair = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStair(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStairFlight = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NumberOfRisers, NumberOfTreads, RiserHeight, TreadLength, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.NumberOfRisers = NumberOfRisers;
    this.NumberOfTreads = NumberOfTreads;
    this.RiserHeight = RiserHeight;
    this.TreadLength = TreadLength;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let NumberOfRisers = tape[ptr++];
    let NumberOfTreads = tape[ptr++];
    let RiserHeight = tape[ptr++];
    let TreadLength = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStairFlight(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NumberOfRisers, NumberOfTreads, RiserHeight, TreadLength, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.NumberOfRisers);
    args.push(this.NumberOfTreads);
    args.push(this.RiserHeight);
    args.push(this.TreadLength);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStairFlightType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStairFlightType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStairType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStairType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStructuralAction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    return new IfcStructuralAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    args.push(this.DestabilizingLoad);
    return args;
  }
};
var IfcStructuralActivity = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    return new IfcStructuralActivity(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    return args;
  }
};
var IfcStructuralAnalysisModel = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, OrientationOf2DPlane, LoadedBy, HasResults, SharedPlacement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.PredefinedType = PredefinedType;
    this.OrientationOf2DPlane = OrientationOf2DPlane;
    this.LoadedBy = LoadedBy;
    this.HasResults = HasResults;
    this.SharedPlacement = SharedPlacement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let OrientationOf2DPlane = tape[ptr++];
    let LoadedBy = tape[ptr++];
    let HasResults = tape[ptr++];
    let SharedPlacement = tape[ptr++];
    return new IfcStructuralAnalysisModel(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, OrientationOf2DPlane, LoadedBy, HasResults, SharedPlacement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.PredefinedType);
    args.push(this.OrientationOf2DPlane);
    args.push(this.LoadedBy);
    args.push(this.HasResults);
    args.push(this.SharedPlacement);
    return args;
  }
};
var IfcStructuralConnection = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedCondition = AppliedCondition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    return new IfcStructuralConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedCondition);
    return args;
  }
};
var IfcStructuralConnectionCondition = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcStructuralConnectionCondition(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcStructuralCurveAction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
    this.ProjectedOrTrue = ProjectedOrTrue;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    let ProjectedOrTrue = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralCurveAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    args.push(this.DestabilizingLoad);
    args.push(this.ProjectedOrTrue);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStructuralCurveConnection = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, Axis) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedCondition = AppliedCondition;
    this.Axis = Axis;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    let Axis = tape[ptr++];
    return new IfcStructuralCurveConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, Axis);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedCondition);
    args.push(this.Axis);
    return args;
  }
};
var IfcStructuralCurveMember = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.PredefinedType = PredefinedType;
    this.Axis = Axis;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Axis = tape[ptr++];
    return new IfcStructuralCurveMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.PredefinedType);
    args.push(this.Axis);
    return args;
  }
};
var IfcStructuralCurveMemberVarying = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.PredefinedType = PredefinedType;
    this.Axis = Axis;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Axis = tape[ptr++];
    return new IfcStructuralCurveMemberVarying(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.PredefinedType);
    args.push(this.Axis);
    return args;
  }
};
var IfcStructuralCurveReaction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralCurveReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStructuralItem = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcStructuralItem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    return args;
  }
};
var IfcStructuralLinearAction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
    this.ProjectedOrTrue = ProjectedOrTrue;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    let ProjectedOrTrue = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralLinearAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    args.push(this.DestabilizingLoad);
    args.push(this.ProjectedOrTrue);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStructuralLoad = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcStructuralLoad(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcStructuralLoadCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose, SelfWeightCoefficients) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.PredefinedType = PredefinedType;
    this.ActionType = ActionType;
    this.ActionSource = ActionSource;
    this.Coefficient = Coefficient;
    this.Purpose = Purpose;
    this.SelfWeightCoefficients = SelfWeightCoefficients;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let ActionType = tape[ptr++];
    let ActionSource = tape[ptr++];
    let Coefficient = tape[ptr++];
    let Purpose = tape[ptr++];
    let SelfWeightCoefficients = tape[ptr++];
    return new IfcStructuralLoadCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose, SelfWeightCoefficients);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.PredefinedType);
    args.push(this.ActionType);
    args.push(this.ActionSource);
    args.push(this.Coefficient);
    args.push(this.Purpose);
    args.push(this.SelfWeightCoefficients);
    return args;
  }
};
var IfcStructuralLoadConfiguration = class {
  constructor(expressID, type, Name, Values, Locations) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Values = Values;
    this.Locations = Locations;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Values = tape[ptr++];
    let Locations = tape[ptr++];
    return new IfcStructuralLoadConfiguration(expressID, type, Name, Values, Locations);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Values);
    args.push(this.Locations);
    return args;
  }
};
var IfcStructuralLoadGroup = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.PredefinedType = PredefinedType;
    this.ActionType = ActionType;
    this.ActionSource = ActionSource;
    this.Coefficient = Coefficient;
    this.Purpose = Purpose;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let ActionType = tape[ptr++];
    let ActionSource = tape[ptr++];
    let Coefficient = tape[ptr++];
    let Purpose = tape[ptr++];
    return new IfcStructuralLoadGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.PredefinedType);
    args.push(this.ActionType);
    args.push(this.ActionSource);
    args.push(this.Coefficient);
    args.push(this.Purpose);
    return args;
  }
};
var IfcStructuralLoadLinearForce = class {
  constructor(expressID, type, Name, LinearForceX, LinearForceY, LinearForceZ, LinearMomentX, LinearMomentY, LinearMomentZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LinearForceX = LinearForceX;
    this.LinearForceY = LinearForceY;
    this.LinearForceZ = LinearForceZ;
    this.LinearMomentX = LinearMomentX;
    this.LinearMomentY = LinearMomentY;
    this.LinearMomentZ = LinearMomentZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LinearForceX = tape[ptr++];
    let LinearForceY = tape[ptr++];
    let LinearForceZ = tape[ptr++];
    let LinearMomentX = tape[ptr++];
    let LinearMomentY = tape[ptr++];
    let LinearMomentZ = tape[ptr++];
    return new IfcStructuralLoadLinearForce(expressID, type, Name, LinearForceX, LinearForceY, LinearForceZ, LinearMomentX, LinearMomentY, LinearMomentZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.LinearForceX);
    args.push(this.LinearForceY);
    args.push(this.LinearForceZ);
    args.push(this.LinearMomentX);
    args.push(this.LinearMomentY);
    args.push(this.LinearMomentZ);
    return args;
  }
};
var IfcStructuralLoadOrResult = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcStructuralLoadOrResult(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcStructuralLoadPlanarForce = class {
  constructor(expressID, type, Name, PlanarForceX, PlanarForceY, PlanarForceZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.PlanarForceX = PlanarForceX;
    this.PlanarForceY = PlanarForceY;
    this.PlanarForceZ = PlanarForceZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let PlanarForceX = tape[ptr++];
    let PlanarForceY = tape[ptr++];
    let PlanarForceZ = tape[ptr++];
    return new IfcStructuralLoadPlanarForce(expressID, type, Name, PlanarForceX, PlanarForceY, PlanarForceZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.PlanarForceX);
    args.push(this.PlanarForceY);
    args.push(this.PlanarForceZ);
    return args;
  }
};
var IfcStructuralLoadSingleDisplacement = class {
  constructor(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DisplacementX = DisplacementX;
    this.DisplacementY = DisplacementY;
    this.DisplacementZ = DisplacementZ;
    this.RotationalDisplacementRX = RotationalDisplacementRX;
    this.RotationalDisplacementRY = RotationalDisplacementRY;
    this.RotationalDisplacementRZ = RotationalDisplacementRZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DisplacementX = tape[ptr++];
    let DisplacementY = tape[ptr++];
    let DisplacementZ = tape[ptr++];
    let RotationalDisplacementRX = tape[ptr++];
    let RotationalDisplacementRY = tape[ptr++];
    let RotationalDisplacementRZ = tape[ptr++];
    return new IfcStructuralLoadSingleDisplacement(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.DisplacementX);
    args.push(this.DisplacementY);
    args.push(this.DisplacementZ);
    args.push(this.RotationalDisplacementRX);
    args.push(this.RotationalDisplacementRY);
    args.push(this.RotationalDisplacementRZ);
    return args;
  }
};
var IfcStructuralLoadSingleDisplacementDistortion = class {
  constructor(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ, Distortion) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DisplacementX = DisplacementX;
    this.DisplacementY = DisplacementY;
    this.DisplacementZ = DisplacementZ;
    this.RotationalDisplacementRX = RotationalDisplacementRX;
    this.RotationalDisplacementRY = RotationalDisplacementRY;
    this.RotationalDisplacementRZ = RotationalDisplacementRZ;
    this.Distortion = Distortion;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DisplacementX = tape[ptr++];
    let DisplacementY = tape[ptr++];
    let DisplacementZ = tape[ptr++];
    let RotationalDisplacementRX = tape[ptr++];
    let RotationalDisplacementRY = tape[ptr++];
    let RotationalDisplacementRZ = tape[ptr++];
    let Distortion = tape[ptr++];
    return new IfcStructuralLoadSingleDisplacementDistortion(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ, Distortion);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.DisplacementX);
    args.push(this.DisplacementY);
    args.push(this.DisplacementZ);
    args.push(this.RotationalDisplacementRX);
    args.push(this.RotationalDisplacementRY);
    args.push(this.RotationalDisplacementRZ);
    args.push(this.Distortion);
    return args;
  }
};
var IfcStructuralLoadSingleForce = class {
  constructor(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.ForceX = ForceX;
    this.ForceY = ForceY;
    this.ForceZ = ForceZ;
    this.MomentX = MomentX;
    this.MomentY = MomentY;
    this.MomentZ = MomentZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let ForceX = tape[ptr++];
    let ForceY = tape[ptr++];
    let ForceZ = tape[ptr++];
    let MomentX = tape[ptr++];
    let MomentY = tape[ptr++];
    let MomentZ = tape[ptr++];
    return new IfcStructuralLoadSingleForce(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.ForceX);
    args.push(this.ForceY);
    args.push(this.ForceZ);
    args.push(this.MomentX);
    args.push(this.MomentY);
    args.push(this.MomentZ);
    return args;
  }
};
var IfcStructuralLoadSingleForceWarping = class {
  constructor(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ, WarpingMoment) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.ForceX = ForceX;
    this.ForceY = ForceY;
    this.ForceZ = ForceZ;
    this.MomentX = MomentX;
    this.MomentY = MomentY;
    this.MomentZ = MomentZ;
    this.WarpingMoment = WarpingMoment;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let ForceX = tape[ptr++];
    let ForceY = tape[ptr++];
    let ForceZ = tape[ptr++];
    let MomentX = tape[ptr++];
    let MomentY = tape[ptr++];
    let MomentZ = tape[ptr++];
    let WarpingMoment = tape[ptr++];
    return new IfcStructuralLoadSingleForceWarping(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ, WarpingMoment);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.ForceX);
    args.push(this.ForceY);
    args.push(this.ForceZ);
    args.push(this.MomentX);
    args.push(this.MomentY);
    args.push(this.MomentZ);
    args.push(this.WarpingMoment);
    return args;
  }
};
var IfcStructuralLoadStatic = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcStructuralLoadStatic(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcStructuralLoadTemperature = class {
  constructor(expressID, type, Name, DeltaTConstant, DeltaTY, DeltaTZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DeltaTConstant = DeltaTConstant;
    this.DeltaTY = DeltaTY;
    this.DeltaTZ = DeltaTZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DeltaTConstant = tape[ptr++];
    let DeltaTY = tape[ptr++];
    let DeltaTZ = tape[ptr++];
    return new IfcStructuralLoadTemperature(expressID, type, Name, DeltaTConstant, DeltaTY, DeltaTZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.DeltaTConstant);
    args.push(this.DeltaTY);
    args.push(this.DeltaTZ);
    return args;
  }
};
var IfcStructuralMember = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcStructuralMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    return args;
  }
};
var IfcStructuralPlanarAction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
    this.ProjectedOrTrue = ProjectedOrTrue;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    let ProjectedOrTrue = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralPlanarAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    args.push(this.DestabilizingLoad);
    args.push(this.ProjectedOrTrue);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStructuralPointAction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    return new IfcStructuralPointAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    args.push(this.DestabilizingLoad);
    return args;
  }
};
var IfcStructuralPointConnection = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, ConditionCoordinateSystem) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedCondition = AppliedCondition;
    this.ConditionCoordinateSystem = ConditionCoordinateSystem;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    let ConditionCoordinateSystem = tape[ptr++];
    return new IfcStructuralPointConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, ConditionCoordinateSystem);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedCondition);
    args.push(this.ConditionCoordinateSystem);
    return args;
  }
};
var IfcStructuralPointReaction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    return new IfcStructuralPointReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    return args;
  }
};
var IfcStructuralReaction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    return new IfcStructuralReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    return args;
  }
};
var IfcStructuralResultGroup = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheoryType, ResultForLoadGroup, IsLinear) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.TheoryType = TheoryType;
    this.ResultForLoadGroup = ResultForLoadGroup;
    this.IsLinear = IsLinear;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let TheoryType = tape[ptr++];
    let ResultForLoadGroup = tape[ptr++];
    let IsLinear = tape[ptr++];
    return new IfcStructuralResultGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheoryType, ResultForLoadGroup, IsLinear);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.TheoryType);
    args.push(this.ResultForLoadGroup);
    args.push(this.IsLinear);
    return args;
  }
};
var IfcStructuralSurfaceAction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
    this.ProjectedOrTrue = ProjectedOrTrue;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    let ProjectedOrTrue = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralSurfaceAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    args.push(this.DestabilizingLoad);
    args.push(this.ProjectedOrTrue);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStructuralSurfaceConnection = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedCondition = AppliedCondition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    return new IfcStructuralSurfaceConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedCondition);
    return args;
  }
};
var IfcStructuralSurfaceMember = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.PredefinedType = PredefinedType;
    this.Thickness = Thickness;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Thickness = tape[ptr++];
    return new IfcStructuralSurfaceMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.PredefinedType);
    args.push(this.Thickness);
    return args;
  }
};
var IfcStructuralSurfaceMemberVarying = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.PredefinedType = PredefinedType;
    this.Thickness = Thickness;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Thickness = tape[ptr++];
    return new IfcStructuralSurfaceMemberVarying(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.PredefinedType);
    args.push(this.Thickness);
    return args;
  }
};
var IfcStructuralSurfaceReaction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralSurfaceReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStyleModel = class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcStyleModel(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    args.push(this.RepresentationIdentifier);
    args.push(this.RepresentationType);
    args.push(this.Items);
    return args;
  }
};
var IfcStyledItem = class {
  constructor(expressID, type, Item, Styles, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Item = Item;
    this.Styles = Styles;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Item = tape[ptr++];
    let Styles = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcStyledItem(expressID, type, Item, Styles, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Item);
    args.push(this.Styles);
    args.push(this.Name);
    return args;
  }
};
var IfcStyledRepresentation = class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcStyledRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    args.push(this.RepresentationIdentifier);
    args.push(this.RepresentationType);
    args.push(this.Items);
    return args;
  }
};
var IfcSubContractResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSubContractResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.Usage);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSubContractResourceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSubContractResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ResourceType);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSubedge = class {
  constructor(expressID, type, EdgeStart, EdgeEnd, ParentEdge) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeStart = EdgeStart;
    this.EdgeEnd = EdgeEnd;
    this.ParentEdge = ParentEdge;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeStart = tape[ptr++];
    let EdgeEnd = tape[ptr++];
    let ParentEdge = tape[ptr++];
    return new IfcSubedge(expressID, type, EdgeStart, EdgeEnd, ParentEdge);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeStart);
    args.push(this.EdgeEnd);
    args.push(this.ParentEdge);
    return args;
  }
};
var IfcSurface = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcSurface(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcSurfaceCurve = class {
  constructor(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation) {
    this.expressID = expressID;
    this.type = type;
    this.Curve3D = Curve3D;
    this.AssociatedGeometry = AssociatedGeometry;
    this.MasterRepresentation = MasterRepresentation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Curve3D = tape[ptr++];
    let AssociatedGeometry = tape[ptr++];
    let MasterRepresentation = tape[ptr++];
    return new IfcSurfaceCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation);
  }
  ToTape() {
    let args = [];
    args.push(this.Curve3D);
    args.push(this.AssociatedGeometry);
    args.push(this.MasterRepresentation);
    return args;
  }
};
var IfcSurfaceCurveSweptAreaSolid = class {
  constructor(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, ReferenceSurface) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.Directrix = Directrix;
    this.StartParam = StartParam;
    this.EndParam = EndParam;
    this.ReferenceSurface = ReferenceSurface;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let Directrix = tape[ptr++];
    let StartParam = tape[ptr++];
    let EndParam = tape[ptr++];
    let ReferenceSurface = tape[ptr++];
    return new IfcSurfaceCurveSweptAreaSolid(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, ReferenceSurface);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    args.push(this.Position);
    args.push(this.Directrix);
    args.push(this.StartParam);
    args.push(this.EndParam);
    args.push(this.ReferenceSurface);
    return args;
  }
};
var IfcSurfaceFeature = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSurfaceFeature(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSurfaceOfLinearExtrusion = class {
  constructor(expressID, type, SweptCurve, Position, ExtrudedDirection, Depth) {
    this.expressID = expressID;
    this.type = type;
    this.SweptCurve = SweptCurve;
    this.Position = Position;
    this.ExtrudedDirection = ExtrudedDirection;
    this.Depth = Depth;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptCurve = tape[ptr++];
    let Position = tape[ptr++];
    let ExtrudedDirection = tape[ptr++];
    let Depth = tape[ptr++];
    return new IfcSurfaceOfLinearExtrusion(expressID, type, SweptCurve, Position, ExtrudedDirection, Depth);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptCurve);
    args.push(this.Position);
    args.push(this.ExtrudedDirection);
    args.push(this.Depth);
    return args;
  }
};
var IfcSurfaceOfRevolution = class {
  constructor(expressID, type, SweptCurve, Position, AxisPosition) {
    this.expressID = expressID;
    this.type = type;
    this.SweptCurve = SweptCurve;
    this.Position = Position;
    this.AxisPosition = AxisPosition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptCurve = tape[ptr++];
    let Position = tape[ptr++];
    let AxisPosition = tape[ptr++];
    return new IfcSurfaceOfRevolution(expressID, type, SweptCurve, Position, AxisPosition);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptCurve);
    args.push(this.Position);
    args.push(this.AxisPosition);
    return args;
  }
};
var IfcSurfaceReinforcementArea = class {
  constructor(expressID, type, Name, SurfaceReinforcement1, SurfaceReinforcement2, ShearReinforcement) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.SurfaceReinforcement1 = SurfaceReinforcement1;
    this.SurfaceReinforcement2 = SurfaceReinforcement2;
    this.ShearReinforcement = ShearReinforcement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let SurfaceReinforcement1 = tape[ptr++];
    let SurfaceReinforcement2 = tape[ptr++];
    let ShearReinforcement = tape[ptr++];
    return new IfcSurfaceReinforcementArea(expressID, type, Name, SurfaceReinforcement1, SurfaceReinforcement2, ShearReinforcement);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.SurfaceReinforcement1);
    args.push(this.SurfaceReinforcement2);
    args.push(this.ShearReinforcement);
    return args;
  }
};
var IfcSurfaceStyle = class {
  constructor(expressID, type, Name, Side, Styles) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Side = Side;
    this.Styles = Styles;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Side = tape[ptr++];
    let Styles = tape[ptr++];
    return new IfcSurfaceStyle(expressID, type, Name, Side, Styles);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Side);
    args.push(this.Styles);
    return args;
  }
};
var IfcSurfaceStyleLighting = class {
  constructor(expressID, type, DiffuseTransmissionColour, DiffuseReflectionColour, TransmissionColour, ReflectanceColour) {
    this.expressID = expressID;
    this.type = type;
    this.DiffuseTransmissionColour = DiffuseTransmissionColour;
    this.DiffuseReflectionColour = DiffuseReflectionColour;
    this.TransmissionColour = TransmissionColour;
    this.ReflectanceColour = ReflectanceColour;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let DiffuseTransmissionColour = tape[ptr++];
    let DiffuseReflectionColour = tape[ptr++];
    let TransmissionColour = tape[ptr++];
    let ReflectanceColour = tape[ptr++];
    return new IfcSurfaceStyleLighting(expressID, type, DiffuseTransmissionColour, DiffuseReflectionColour, TransmissionColour, ReflectanceColour);
  }
  ToTape() {
    let args = [];
    args.push(this.DiffuseTransmissionColour);
    args.push(this.DiffuseReflectionColour);
    args.push(this.TransmissionColour);
    args.push(this.ReflectanceColour);
    return args;
  }
};
var IfcSurfaceStyleRefraction = class {
  constructor(expressID, type, RefractionIndex, DispersionFactor) {
    this.expressID = expressID;
    this.type = type;
    this.RefractionIndex = RefractionIndex;
    this.DispersionFactor = DispersionFactor;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RefractionIndex = tape[ptr++];
    let DispersionFactor = tape[ptr++];
    return new IfcSurfaceStyleRefraction(expressID, type, RefractionIndex, DispersionFactor);
  }
  ToTape() {
    let args = [];
    args.push(this.RefractionIndex);
    args.push(this.DispersionFactor);
    return args;
  }
};
var IfcSurfaceStyleRendering = class {
  constructor(expressID, type, SurfaceColour, Transparency, DiffuseColour, TransmissionColour, DiffuseTransmissionColour, ReflectionColour, SpecularColour, SpecularHighlight, ReflectanceMethod) {
    this.expressID = expressID;
    this.type = type;
    this.SurfaceColour = SurfaceColour;
    this.Transparency = Transparency;
    this.DiffuseColour = DiffuseColour;
    this.TransmissionColour = TransmissionColour;
    this.DiffuseTransmissionColour = DiffuseTransmissionColour;
    this.ReflectionColour = ReflectionColour;
    this.SpecularColour = SpecularColour;
    this.SpecularHighlight = SpecularHighlight;
    this.ReflectanceMethod = ReflectanceMethod;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SurfaceColour = tape[ptr++];
    let Transparency = tape[ptr++];
    let DiffuseColour = tape[ptr++];
    let TransmissionColour = tape[ptr++];
    let DiffuseTransmissionColour = tape[ptr++];
    let ReflectionColour = tape[ptr++];
    let SpecularColour = tape[ptr++];
    let SpecularHighlight = tape[ptr++];
    let ReflectanceMethod = tape[ptr++];
    return new IfcSurfaceStyleRendering(expressID, type, SurfaceColour, Transparency, DiffuseColour, TransmissionColour, DiffuseTransmissionColour, ReflectionColour, SpecularColour, SpecularHighlight, ReflectanceMethod);
  }
  ToTape() {
    let args = [];
    args.push(this.SurfaceColour);
    args.push(this.Transparency);
    args.push(this.DiffuseColour);
    args.push(this.TransmissionColour);
    args.push(this.DiffuseTransmissionColour);
    args.push(this.ReflectionColour);
    args.push(this.SpecularColour);
    args.push(this.SpecularHighlight);
    args.push(this.ReflectanceMethod);
    return args;
  }
};
var IfcSurfaceStyleShading = class {
  constructor(expressID, type, SurfaceColour, Transparency) {
    this.expressID = expressID;
    this.type = type;
    this.SurfaceColour = SurfaceColour;
    this.Transparency = Transparency;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SurfaceColour = tape[ptr++];
    let Transparency = tape[ptr++];
    return new IfcSurfaceStyleShading(expressID, type, SurfaceColour, Transparency);
  }
  ToTape() {
    let args = [];
    args.push(this.SurfaceColour);
    args.push(this.Transparency);
    return args;
  }
};
var IfcSurfaceStyleWithTextures = class {
  constructor(expressID, type, Textures) {
    this.expressID = expressID;
    this.type = type;
    this.Textures = Textures;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Textures = tape[ptr++];
    return new IfcSurfaceStyleWithTextures(expressID, type, Textures);
  }
  ToTape() {
    let args = [];
    args.push(this.Textures);
    return args;
  }
};
var IfcSurfaceTexture = class {
  constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter) {
    this.expressID = expressID;
    this.type = type;
    this.RepeatS = RepeatS;
    this.RepeatT = RepeatT;
    this.Mode = Mode;
    this.TextureTransform = TextureTransform;
    this.Parameter = Parameter;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RepeatS = tape[ptr++];
    let RepeatT = tape[ptr++];
    let Mode = tape[ptr++];
    let TextureTransform = tape[ptr++];
    let Parameter = tape[ptr++];
    return new IfcSurfaceTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter);
  }
  ToTape() {
    let args = [];
    args.push(this.RepeatS);
    args.push(this.RepeatT);
    args.push(this.Mode);
    args.push(this.TextureTransform);
    args.push(this.Parameter);
    return args;
  }
};
var IfcSweptAreaSolid = class {
  constructor(expressID, type, SweptArea, Position) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    return new IfcSweptAreaSolid(expressID, type, SweptArea, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    args.push(this.Position);
    return args;
  }
};
var IfcSweptDiskSolid = class {
  constructor(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam) {
    this.expressID = expressID;
    this.type = type;
    this.Directrix = Directrix;
    this.Radius = Radius;
    this.InnerRadius = InnerRadius;
    this.StartParam = StartParam;
    this.EndParam = EndParam;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Directrix = tape[ptr++];
    let Radius = tape[ptr++];
    let InnerRadius = tape[ptr++];
    let StartParam = tape[ptr++];
    let EndParam = tape[ptr++];
    return new IfcSweptDiskSolid(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam);
  }
  ToTape() {
    let args = [];
    args.push(this.Directrix);
    args.push(this.Radius);
    args.push(this.InnerRadius);
    args.push(this.StartParam);
    args.push(this.EndParam);
    return args;
  }
};
var IfcSweptDiskSolidPolygonal = class {
  constructor(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam, FilletRadius) {
    this.expressID = expressID;
    this.type = type;
    this.Directrix = Directrix;
    this.Radius = Radius;
    this.InnerRadius = InnerRadius;
    this.StartParam = StartParam;
    this.EndParam = EndParam;
    this.FilletRadius = FilletRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Directrix = tape[ptr++];
    let Radius = tape[ptr++];
    let InnerRadius = tape[ptr++];
    let StartParam = tape[ptr++];
    let EndParam = tape[ptr++];
    let FilletRadius = tape[ptr++];
    return new IfcSweptDiskSolidPolygonal(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam, FilletRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.Directrix);
    args.push(this.Radius);
    args.push(this.InnerRadius);
    args.push(this.StartParam);
    args.push(this.EndParam);
    args.push(this.FilletRadius);
    return args;
  }
};
var IfcSweptSurface = class {
  constructor(expressID, type, SweptCurve, Position) {
    this.expressID = expressID;
    this.type = type;
    this.SweptCurve = SweptCurve;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptCurve = tape[ptr++];
    let Position = tape[ptr++];
    return new IfcSweptSurface(expressID, type, SweptCurve, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptCurve);
    args.push(this.Position);
    return args;
  }
};
var IfcSwitchingDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSwitchingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSwitchingDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSwitchingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSystem = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    return new IfcSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    return args;
  }
};
var IfcSystemFurnitureElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSystemFurnitureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSystemFurnitureElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSystemFurnitureElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTShapeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, WebEdgeRadius, WebSlope, FlangeSlope) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Depth = Depth;
    this.FlangeWidth = FlangeWidth;
    this.WebThickness = WebThickness;
    this.FlangeThickness = FlangeThickness;
    this.FilletRadius = FilletRadius;
    this.FlangeEdgeRadius = FlangeEdgeRadius;
    this.WebEdgeRadius = WebEdgeRadius;
    this.WebSlope = WebSlope;
    this.FlangeSlope = FlangeSlope;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Depth = tape[ptr++];
    let FlangeWidth = tape[ptr++];
    let WebThickness = tape[ptr++];
    let FlangeThickness = tape[ptr++];
    let FilletRadius = tape[ptr++];
    let FlangeEdgeRadius = tape[ptr++];
    let WebEdgeRadius = tape[ptr++];
    let WebSlope = tape[ptr++];
    let FlangeSlope = tape[ptr++];
    return new IfcTShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, WebEdgeRadius, WebSlope, FlangeSlope);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.Depth);
    args.push(this.FlangeWidth);
    args.push(this.WebThickness);
    args.push(this.FlangeThickness);
    args.push(this.FilletRadius);
    args.push(this.FlangeEdgeRadius);
    args.push(this.WebEdgeRadius);
    args.push(this.WebSlope);
    args.push(this.FlangeSlope);
    return args;
  }
};
var IfcTable = class {
  constructor(expressID, type, Name, Rows, Columns) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Rows = Rows;
    this.Columns = Columns;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Rows = tape[ptr++];
    let Columns = tape[ptr++];
    return new IfcTable(expressID, type, Name, Rows, Columns);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Rows);
    args.push(this.Columns);
    return args;
  }
};
var IfcTableColumn = class {
  constructor(expressID, type, Identifier, Name, Description, Unit, ReferencePath) {
    this.expressID = expressID;
    this.type = type;
    this.Identifier = Identifier;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.ReferencePath = ReferencePath;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Identifier = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let ReferencePath = tape[ptr++];
    return new IfcTableColumn(expressID, type, Identifier, Name, Description, Unit, ReferencePath);
  }
  ToTape() {
    let args = [];
    args.push(this.Identifier);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Unit);
    args.push(this.ReferencePath);
    return args;
  }
};
var IfcTableRow = class {
  constructor(expressID, type, RowCells, IsHeading) {
    this.expressID = expressID;
    this.type = type;
    this.RowCells = RowCells;
    this.IsHeading = IsHeading;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RowCells = tape[ptr++];
    let IsHeading = tape[ptr++];
    return new IfcTableRow(expressID, type, RowCells, IsHeading);
  }
  ToTape() {
    let args = [];
    args.push(this.RowCells);
    args.push(this.IsHeading);
    return args;
  }
};
var IfcTank = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTank(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTankType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTankType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTask = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Status, WorkMethod, IsMilestone, Priority, TaskTime, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Status = Status;
    this.WorkMethod = WorkMethod;
    this.IsMilestone = IsMilestone;
    this.Priority = Priority;
    this.TaskTime = TaskTime;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Status = tape[ptr++];
    let WorkMethod = tape[ptr++];
    let IsMilestone = tape[ptr++];
    let Priority = tape[ptr++];
    let TaskTime = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTask(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Status, WorkMethod, IsMilestone, Priority, TaskTime, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.Status);
    args.push(this.WorkMethod);
    args.push(this.IsMilestone);
    args.push(this.Priority);
    args.push(this.TaskTime);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTaskTime = class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.DurationType = DurationType;
    this.ScheduleDuration = ScheduleDuration;
    this.ScheduleStart = ScheduleStart;
    this.ScheduleFinish = ScheduleFinish;
    this.EarlyStart = EarlyStart;
    this.EarlyFinish = EarlyFinish;
    this.LateStart = LateStart;
    this.LateFinish = LateFinish;
    this.FreeFloat = FreeFloat;
    this.TotalFloat = TotalFloat;
    this.IsCritical = IsCritical;
    this.StatusTime = StatusTime;
    this.ActualDuration = ActualDuration;
    this.ActualStart = ActualStart;
    this.ActualFinish = ActualFinish;
    this.RemainingTime = RemainingTime;
    this.Completion = Completion;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let DurationType = tape[ptr++];
    let ScheduleDuration = tape[ptr++];
    let ScheduleStart = tape[ptr++];
    let ScheduleFinish = tape[ptr++];
    let EarlyStart = tape[ptr++];
    let EarlyFinish = tape[ptr++];
    let LateStart = tape[ptr++];
    let LateFinish = tape[ptr++];
    let FreeFloat = tape[ptr++];
    let TotalFloat = tape[ptr++];
    let IsCritical = tape[ptr++];
    let StatusTime = tape[ptr++];
    let ActualDuration = tape[ptr++];
    let ActualStart = tape[ptr++];
    let ActualFinish = tape[ptr++];
    let RemainingTime = tape[ptr++];
    let Completion = tape[ptr++];
    return new IfcTaskTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.DataOrigin);
    args.push(this.UserDefinedDataOrigin);
    args.push(this.DurationType);
    args.push(this.ScheduleDuration);
    args.push(this.ScheduleStart);
    args.push(this.ScheduleFinish);
    args.push(this.EarlyStart);
    args.push(this.EarlyFinish);
    args.push(this.LateStart);
    args.push(this.LateFinish);
    args.push(this.FreeFloat);
    args.push(this.TotalFloat);
    args.push(this.IsCritical);
    args.push(this.StatusTime);
    args.push(this.ActualDuration);
    args.push(this.ActualStart);
    args.push(this.ActualFinish);
    args.push(this.RemainingTime);
    args.push(this.Completion);
    return args;
  }
};
var IfcTaskTimeRecurring = class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion, Recurrence) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.DurationType = DurationType;
    this.ScheduleDuration = ScheduleDuration;
    this.ScheduleStart = ScheduleStart;
    this.ScheduleFinish = ScheduleFinish;
    this.EarlyStart = EarlyStart;
    this.EarlyFinish = EarlyFinish;
    this.LateStart = LateStart;
    this.LateFinish = LateFinish;
    this.FreeFloat = FreeFloat;
    this.TotalFloat = TotalFloat;
    this.IsCritical = IsCritical;
    this.StatusTime = StatusTime;
    this.ActualDuration = ActualDuration;
    this.ActualStart = ActualStart;
    this.ActualFinish = ActualFinish;
    this.RemainingTime = RemainingTime;
    this.Completion = Completion;
    this.Recurrence = Recurrence;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let DurationType = tape[ptr++];
    let ScheduleDuration = tape[ptr++];
    let ScheduleStart = tape[ptr++];
    let ScheduleFinish = tape[ptr++];
    let EarlyStart = tape[ptr++];
    let EarlyFinish = tape[ptr++];
    let LateStart = tape[ptr++];
    let LateFinish = tape[ptr++];
    let FreeFloat = tape[ptr++];
    let TotalFloat = tape[ptr++];
    let IsCritical = tape[ptr++];
    let StatusTime = tape[ptr++];
    let ActualDuration = tape[ptr++];
    let ActualStart = tape[ptr++];
    let ActualFinish = tape[ptr++];
    let RemainingTime = tape[ptr++];
    let Completion = tape[ptr++];
    let Recurrence = tape[ptr++];
    return new IfcTaskTimeRecurring(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion, Recurrence);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.DataOrigin);
    args.push(this.UserDefinedDataOrigin);
    args.push(this.DurationType);
    args.push(this.ScheduleDuration);
    args.push(this.ScheduleStart);
    args.push(this.ScheduleFinish);
    args.push(this.EarlyStart);
    args.push(this.EarlyFinish);
    args.push(this.LateStart);
    args.push(this.LateFinish);
    args.push(this.FreeFloat);
    args.push(this.TotalFloat);
    args.push(this.IsCritical);
    args.push(this.StatusTime);
    args.push(this.ActualDuration);
    args.push(this.ActualStart);
    args.push(this.ActualFinish);
    args.push(this.RemainingTime);
    args.push(this.Completion);
    args.push(this.Recurrence);
    return args;
  }
};
var IfcTaskType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, WorkMethod) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ProcessType = ProcessType;
    this.PredefinedType = PredefinedType;
    this.WorkMethod = WorkMethod;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ProcessType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let WorkMethod = tape[ptr++];
    return new IfcTaskType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, WorkMethod);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ProcessType);
    args.push(this.PredefinedType);
    args.push(this.WorkMethod);
    return args;
  }
};
var IfcTelecomAddress = class {
  constructor(expressID, type, Purpose, Description, UserDefinedPurpose, TelephoneNumbers, FacsimileNumbers, PagerNumber, ElectronicMailAddresses, WWWHomePageURL, MessagingIDs) {
    this.expressID = expressID;
    this.type = type;
    this.Purpose = Purpose;
    this.Description = Description;
    this.UserDefinedPurpose = UserDefinedPurpose;
    this.TelephoneNumbers = TelephoneNumbers;
    this.FacsimileNumbers = FacsimileNumbers;
    this.PagerNumber = PagerNumber;
    this.ElectronicMailAddresses = ElectronicMailAddresses;
    this.WWWHomePageURL = WWWHomePageURL;
    this.MessagingIDs = MessagingIDs;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Purpose = tape[ptr++];
    let Description = tape[ptr++];
    let UserDefinedPurpose = tape[ptr++];
    let TelephoneNumbers = tape[ptr++];
    let FacsimileNumbers = tape[ptr++];
    let PagerNumber = tape[ptr++];
    let ElectronicMailAddresses = tape[ptr++];
    let WWWHomePageURL = tape[ptr++];
    let MessagingIDs = tape[ptr++];
    return new IfcTelecomAddress(expressID, type, Purpose, Description, UserDefinedPurpose, TelephoneNumbers, FacsimileNumbers, PagerNumber, ElectronicMailAddresses, WWWHomePageURL, MessagingIDs);
  }
  ToTape() {
    let args = [];
    args.push(this.Purpose);
    args.push(this.Description);
    args.push(this.UserDefinedPurpose);
    args.push(this.TelephoneNumbers);
    args.push(this.FacsimileNumbers);
    args.push(this.PagerNumber);
    args.push(this.ElectronicMailAddresses);
    args.push(this.WWWHomePageURL);
    args.push(this.MessagingIDs);
    return args;
  }
};
var IfcTendon = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType, NominalDiameter, CrossSectionArea, TensionForce, PreStress, FrictionCoefficient, AnchorageSlip, MinCurvatureRadius) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
    this.PredefinedType = PredefinedType;
    this.NominalDiameter = NominalDiameter;
    this.CrossSectionArea = CrossSectionArea;
    this.TensionForce = TensionForce;
    this.PreStress = PreStress;
    this.FrictionCoefficient = FrictionCoefficient;
    this.AnchorageSlip = AnchorageSlip;
    this.MinCurvatureRadius = MinCurvatureRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let CrossSectionArea = tape[ptr++];
    let TensionForce = tape[ptr++];
    let PreStress = tape[ptr++];
    let FrictionCoefficient = tape[ptr++];
    let AnchorageSlip = tape[ptr++];
    let MinCurvatureRadius = tape[ptr++];
    return new IfcTendon(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType, NominalDiameter, CrossSectionArea, TensionForce, PreStress, FrictionCoefficient, AnchorageSlip, MinCurvatureRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.SteelGrade);
    args.push(this.PredefinedType);
    args.push(this.NominalDiameter);
    args.push(this.CrossSectionArea);
    args.push(this.TensionForce);
    args.push(this.PreStress);
    args.push(this.FrictionCoefficient);
    args.push(this.AnchorageSlip);
    args.push(this.MinCurvatureRadius);
    return args;
  }
};
var IfcTendonAnchor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTendonAnchor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.SteelGrade);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTendonAnchorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTendonAnchorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTendonConduit = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTendonConduit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.SteelGrade);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTendonConduitType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTendonConduitType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTendonType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, SheathDiameter) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.NominalDiameter = NominalDiameter;
    this.CrossSectionArea = CrossSectionArea;
    this.SheathDiameter = SheathDiameter;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let CrossSectionArea = tape[ptr++];
    let SheathDiameter = tape[ptr++];
    return new IfcTendonType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, SheathDiameter);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    args.push(this.NominalDiameter);
    args.push(this.CrossSectionArea);
    args.push(this.SheathDiameter);
    return args;
  }
};
var IfcTessellatedFaceSet = class {
  constructor(expressID, type, Coordinates) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    return new IfcTessellatedFaceSet(expressID, type, Coordinates);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    return args;
  }
};
var IfcTessellatedItem = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcTessellatedItem(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcTextLiteral = class {
  constructor(expressID, type, Literal, Placement, Path) {
    this.expressID = expressID;
    this.type = type;
    this.Literal = Literal;
    this.Placement = Placement;
    this.Path = Path;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Literal = tape[ptr++];
    let Placement = tape[ptr++];
    let Path = tape[ptr++];
    return new IfcTextLiteral(expressID, type, Literal, Placement, Path);
  }
  ToTape() {
    let args = [];
    args.push(this.Literal);
    args.push(this.Placement);
    args.push(this.Path);
    return args;
  }
};
var IfcTextLiteralWithExtent = class {
  constructor(expressID, type, Literal, Placement, Path, Extent, BoxAlignment) {
    this.expressID = expressID;
    this.type = type;
    this.Literal = Literal;
    this.Placement = Placement;
    this.Path = Path;
    this.Extent = Extent;
    this.BoxAlignment = BoxAlignment;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Literal = tape[ptr++];
    let Placement = tape[ptr++];
    let Path = tape[ptr++];
    let Extent = tape[ptr++];
    let BoxAlignment = tape[ptr++];
    return new IfcTextLiteralWithExtent(expressID, type, Literal, Placement, Path, Extent, BoxAlignment);
  }
  ToTape() {
    let args = [];
    args.push(this.Literal);
    args.push(this.Placement);
    args.push(this.Path);
    args.push(this.Extent);
    args.push(this.BoxAlignment);
    return args;
  }
};
var IfcTextStyle = class {
  constructor(expressID, type, Name, TextCharacterAppearance, TextStyle, TextFontStyle, ModelOrDraughting) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TextCharacterAppearance = TextCharacterAppearance;
    this.TextStyle = TextStyle;
    this.TextFontStyle = TextFontStyle;
    this.ModelOrDraughting = ModelOrDraughting;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TextCharacterAppearance = tape[ptr++];
    let TextStyle = tape[ptr++];
    let TextFontStyle = tape[ptr++];
    let ModelOrDraughting = tape[ptr++];
    return new IfcTextStyle(expressID, type, Name, TextCharacterAppearance, TextStyle, TextFontStyle, ModelOrDraughting);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.TextCharacterAppearance);
    args.push(this.TextStyle);
    args.push(this.TextFontStyle);
    args.push(this.ModelOrDraughting);
    return args;
  }
};
var IfcTextStyleFontModel = class {
  constructor(expressID, type, Name, FontFamily, FontStyle, FontVariant, FontWeight, FontSize) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.FontFamily = FontFamily;
    this.FontStyle = FontStyle;
    this.FontVariant = FontVariant;
    this.FontWeight = FontWeight;
    this.FontSize = FontSize;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let FontFamily = tape[ptr++];
    let FontStyle = tape[ptr++];
    let FontVariant = tape[ptr++];
    let FontWeight = tape[ptr++];
    let FontSize = tape[ptr++];
    return new IfcTextStyleFontModel(expressID, type, Name, FontFamily, FontStyle, FontVariant, FontWeight, FontSize);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.FontFamily);
    args.push(this.FontStyle);
    args.push(this.FontVariant);
    args.push(this.FontWeight);
    args.push(this.FontSize);
    return args;
  }
};
var IfcTextStyleForDefinedFont = class {
  constructor(expressID, type, Colour, BackgroundColour) {
    this.expressID = expressID;
    this.type = type;
    this.Colour = Colour;
    this.BackgroundColour = BackgroundColour;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Colour = tape[ptr++];
    let BackgroundColour = tape[ptr++];
    return new IfcTextStyleForDefinedFont(expressID, type, Colour, BackgroundColour);
  }
  ToTape() {
    let args = [];
    args.push(this.Colour);
    args.push(this.BackgroundColour);
    return args;
  }
};
var IfcTextStyleTextModel = class {
  constructor(expressID, type, TextIndent, TextAlign, TextDecoration, LetterSpacing, WordSpacing, TextTransform, LineHeight) {
    this.expressID = expressID;
    this.type = type;
    this.TextIndent = TextIndent;
    this.TextAlign = TextAlign;
    this.TextDecoration = TextDecoration;
    this.LetterSpacing = LetterSpacing;
    this.WordSpacing = WordSpacing;
    this.TextTransform = TextTransform;
    this.LineHeight = LineHeight;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TextIndent = tape[ptr++];
    let TextAlign = tape[ptr++];
    let TextDecoration = tape[ptr++];
    let LetterSpacing = tape[ptr++];
    let WordSpacing = tape[ptr++];
    let TextTransform = tape[ptr++];
    let LineHeight = tape[ptr++];
    return new IfcTextStyleTextModel(expressID, type, TextIndent, TextAlign, TextDecoration, LetterSpacing, WordSpacing, TextTransform, LineHeight);
  }
  ToTape() {
    let args = [];
    args.push(this.TextIndent);
    args.push(this.TextAlign);
    args.push(this.TextDecoration);
    args.push(this.LetterSpacing);
    args.push(this.WordSpacing);
    args.push(this.TextTransform);
    args.push(this.LineHeight);
    return args;
  }
};
var IfcTextureCoordinate = class {
  constructor(expressID, type, Maps) {
    this.expressID = expressID;
    this.type = type;
    this.Maps = Maps;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Maps = tape[ptr++];
    return new IfcTextureCoordinate(expressID, type, Maps);
  }
  ToTape() {
    let args = [];
    args.push(this.Maps);
    return args;
  }
};
var IfcTextureCoordinateGenerator = class {
  constructor(expressID, type, Maps, Mode, Parameter) {
    this.expressID = expressID;
    this.type = type;
    this.Maps = Maps;
    this.Mode = Mode;
    this.Parameter = Parameter;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Maps = tape[ptr++];
    let Mode = tape[ptr++];
    let Parameter = tape[ptr++];
    return new IfcTextureCoordinateGenerator(expressID, type, Maps, Mode, Parameter);
  }
  ToTape() {
    let args = [];
    args.push(this.Maps);
    args.push(this.Mode);
    args.push(this.Parameter);
    return args;
  }
};
var IfcTextureMap = class {
  constructor(expressID, type, Maps, Vertices, MappedTo) {
    this.expressID = expressID;
    this.type = type;
    this.Maps = Maps;
    this.Vertices = Vertices;
    this.MappedTo = MappedTo;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Maps = tape[ptr++];
    let Vertices = tape[ptr++];
    let MappedTo = tape[ptr++];
    return new IfcTextureMap(expressID, type, Maps, Vertices, MappedTo);
  }
  ToTape() {
    let args = [];
    args.push(this.Maps);
    args.push(this.Vertices);
    args.push(this.MappedTo);
    return args;
  }
};
var IfcTextureVertex = class {
  constructor(expressID, type, Coordinates) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    return new IfcTextureVertex(expressID, type, Coordinates);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    return args;
  }
};
var IfcTextureVertexList = class {
  constructor(expressID, type, TexCoordsList) {
    this.expressID = expressID;
    this.type = type;
    this.TexCoordsList = TexCoordsList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TexCoordsList = tape[ptr++];
    return new IfcTextureVertexList(expressID, type, TexCoordsList);
  }
  ToTape() {
    let args = [];
    args.push(this.TexCoordsList);
    return args;
  }
};
var IfcTimePeriod = class {
  constructor(expressID, type, StartTime, EndTime) {
    this.expressID = expressID;
    this.type = type;
    this.StartTime = StartTime;
    this.EndTime = EndTime;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartTime = tape[ptr++];
    let EndTime = tape[ptr++];
    return new IfcTimePeriod(expressID, type, StartTime, EndTime);
  }
  ToTape() {
    let args = [];
    args.push(this.StartTime);
    args.push(this.EndTime);
    return args;
  }
};
var IfcTimeSeries = class {
  constructor(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.StartTime = StartTime;
    this.EndTime = EndTime;
    this.TimeSeriesDataType = TimeSeriesDataType;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.Unit = Unit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let StartTime = tape[ptr++];
    let EndTime = tape[ptr++];
    let TimeSeriesDataType = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let Unit = tape[ptr++];
    return new IfcTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.StartTime);
    args.push(this.EndTime);
    args.push(this.TimeSeriesDataType);
    args.push(this.DataOrigin);
    args.push(this.UserDefinedDataOrigin);
    args.push(this.Unit);
    return args;
  }
};
var IfcTimeSeriesValue = class {
  constructor(expressID, type, ListValues) {
    this.expressID = expressID;
    this.type = type;
    this.ListValues = ListValues;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ListValues = tape[ptr++];
    return new IfcTimeSeriesValue(expressID, type, ListValues);
  }
  ToTape() {
    let args = [];
    args.push(this.ListValues);
    return args;
  }
};
var IfcTopologicalRepresentationItem = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcTopologicalRepresentationItem(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcTopologyRepresentation = class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcTopologyRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    args.push(this.RepresentationIdentifier);
    args.push(this.RepresentationType);
    args.push(this.Items);
    return args;
  }
};
var IfcToroidalSurface = class {
  constructor(expressID, type, Position, MajorRadius, MinorRadius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.MajorRadius = MajorRadius;
    this.MinorRadius = MinorRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let MajorRadius = tape[ptr++];
    let MinorRadius = tape[ptr++];
    return new IfcToroidalSurface(expressID, type, Position, MajorRadius, MinorRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    args.push(this.MajorRadius);
    args.push(this.MinorRadius);
    return args;
  }
};
var IfcTransformer = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTransformer(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTransformerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTransformerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTransitionCurveSegment2D = class {
  constructor(expressID, type, StartPoint, StartDirection, SegmentLength, StartRadius, EndRadius, IsStartRadiusCCW, IsEndRadiusCCW, TransitionCurveType) {
    this.expressID = expressID;
    this.type = type;
    this.StartPoint = StartPoint;
    this.StartDirection = StartDirection;
    this.SegmentLength = SegmentLength;
    this.StartRadius = StartRadius;
    this.EndRadius = EndRadius;
    this.IsStartRadiusCCW = IsStartRadiusCCW;
    this.IsEndRadiusCCW = IsEndRadiusCCW;
    this.TransitionCurveType = TransitionCurveType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartPoint = tape[ptr++];
    let StartDirection = tape[ptr++];
    let SegmentLength = tape[ptr++];
    let StartRadius = tape[ptr++];
    let EndRadius = tape[ptr++];
    let IsStartRadiusCCW = tape[ptr++];
    let IsEndRadiusCCW = tape[ptr++];
    let TransitionCurveType = tape[ptr++];
    return new IfcTransitionCurveSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength, StartRadius, EndRadius, IsStartRadiusCCW, IsEndRadiusCCW, TransitionCurveType);
  }
  ToTape() {
    let args = [];
    args.push(this.StartPoint);
    args.push(this.StartDirection);
    args.push(this.SegmentLength);
    args.push(this.StartRadius);
    args.push(this.EndRadius);
    args.push(this.IsStartRadiusCCW);
    args.push(this.IsEndRadiusCCW);
    args.push(this.TransitionCurveType);
    return args;
  }
};
var IfcTransportElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTransportElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTransportElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTransportElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTrapeziumProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, BottomXDim, TopXDim, YDim, TopXOffset) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.BottomXDim = BottomXDim;
    this.TopXDim = TopXDim;
    this.YDim = YDim;
    this.TopXOffset = TopXOffset;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let BottomXDim = tape[ptr++];
    let TopXDim = tape[ptr++];
    let YDim = tape[ptr++];
    let TopXOffset = tape[ptr++];
    return new IfcTrapeziumProfileDef(expressID, type, ProfileType, ProfileName, Position, BottomXDim, TopXDim, YDim, TopXOffset);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.BottomXDim);
    args.push(this.TopXDim);
    args.push(this.YDim);
    args.push(this.TopXOffset);
    return args;
  }
};
var IfcTriangulatedFaceSet = class {
  constructor(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
    this.Normals = Normals;
    this.Closed = Closed;
    this.CoordIndex = CoordIndex;
    this.PnIndex = PnIndex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    let Normals = tape[ptr++];
    let Closed = tape[ptr++];
    let CoordIndex = tape[ptr++];
    let PnIndex = tape[ptr++];
    return new IfcTriangulatedFaceSet(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    args.push(this.Normals);
    args.push(this.Closed);
    args.push(this.CoordIndex);
    args.push(this.PnIndex);
    return args;
  }
};
var IfcTriangulatedIrregularNetwork = class {
  constructor(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex, Flags) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
    this.Normals = Normals;
    this.Closed = Closed;
    this.CoordIndex = CoordIndex;
    this.PnIndex = PnIndex;
    this.Flags = Flags;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    let Normals = tape[ptr++];
    let Closed = tape[ptr++];
    let CoordIndex = tape[ptr++];
    let PnIndex = tape[ptr++];
    let Flags = tape[ptr++];
    return new IfcTriangulatedIrregularNetwork(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex, Flags);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    args.push(this.Normals);
    args.push(this.Closed);
    args.push(this.CoordIndex);
    args.push(this.PnIndex);
    args.push(this.Flags);
    return args;
  }
};
var IfcTrimmedCurve = class {
  constructor(expressID, type, BasisCurve, Trim1, Trim2, SenseAgreement, MasterRepresentation) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
    this.Trim1 = Trim1;
    this.Trim2 = Trim2;
    this.SenseAgreement = SenseAgreement;
    this.MasterRepresentation = MasterRepresentation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    let Trim1 = tape[ptr++];
    let Trim2 = tape[ptr++];
    let SenseAgreement = tape[ptr++];
    let MasterRepresentation = tape[ptr++];
    return new IfcTrimmedCurve(expressID, type, BasisCurve, Trim1, Trim2, SenseAgreement, MasterRepresentation);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    args.push(this.Trim1);
    args.push(this.Trim2);
    args.push(this.SenseAgreement);
    args.push(this.MasterRepresentation);
    return args;
  }
};
var IfcTubeBundle = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTubeBundle(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTubeBundleType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTubeBundleType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTypeObject = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    return new IfcTypeObject(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    return args;
  }
};
var IfcTypeProcess = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ProcessType = ProcessType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ProcessType = tape[ptr++];
    return new IfcTypeProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ProcessType);
    return args;
  }
};
var IfcTypeProduct = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcTypeProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    return args;
  }
};
var IfcTypeResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    return new IfcTypeResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ResourceType);
    return args;
  }
};
var IfcUShapeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius, FlangeSlope) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Depth = Depth;
    this.FlangeWidth = FlangeWidth;
    this.WebThickness = WebThickness;
    this.FlangeThickness = FlangeThickness;
    this.FilletRadius = FilletRadius;
    this.EdgeRadius = EdgeRadius;
    this.FlangeSlope = FlangeSlope;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Depth = tape[ptr++];
    let FlangeWidth = tape[ptr++];
    let WebThickness = tape[ptr++];
    let FlangeThickness = tape[ptr++];
    let FilletRadius = tape[ptr++];
    let EdgeRadius = tape[ptr++];
    let FlangeSlope = tape[ptr++];
    return new IfcUShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius, FlangeSlope);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.Depth);
    args.push(this.FlangeWidth);
    args.push(this.WebThickness);
    args.push(this.FlangeThickness);
    args.push(this.FilletRadius);
    args.push(this.EdgeRadius);
    args.push(this.FlangeSlope);
    return args;
  }
};
var IfcUnitAssignment = class {
  constructor(expressID, type, Units) {
    this.expressID = expressID;
    this.type = type;
    this.Units = Units;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Units = tape[ptr++];
    return new IfcUnitAssignment(expressID, type, Units);
  }
  ToTape() {
    let args = [];
    args.push(this.Units);
    return args;
  }
};
var IfcUnitaryControlElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcUnitaryControlElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcUnitaryControlElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcUnitaryControlElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcUnitaryEquipment = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcUnitaryEquipment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcUnitaryEquipmentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcUnitaryEquipmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcValve = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcValve(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcValveType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcValveType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcVector = class {
  constructor(expressID, type, Orientation, Magnitude) {
    this.expressID = expressID;
    this.type = type;
    this.Orientation = Orientation;
    this.Magnitude = Magnitude;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Orientation = tape[ptr++];
    let Magnitude = tape[ptr++];
    return new IfcVector(expressID, type, Orientation, Magnitude);
  }
  ToTape() {
    let args = [];
    args.push(this.Orientation);
    args.push(this.Magnitude);
    return args;
  }
};
var IfcVertex = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcVertex(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcVertexLoop = class {
  constructor(expressID, type, LoopVertex) {
    this.expressID = expressID;
    this.type = type;
    this.LoopVertex = LoopVertex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let LoopVertex = tape[ptr++];
    return new IfcVertexLoop(expressID, type, LoopVertex);
  }
  ToTape() {
    let args = [];
    args.push(this.LoopVertex);
    return args;
  }
};
var IfcVertexPoint = class {
  constructor(expressID, type, VertexGeometry) {
    this.expressID = expressID;
    this.type = type;
    this.VertexGeometry = VertexGeometry;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let VertexGeometry = tape[ptr++];
    return new IfcVertexPoint(expressID, type, VertexGeometry);
  }
  ToTape() {
    let args = [];
    args.push(this.VertexGeometry);
    return args;
  }
};
var IfcVibrationDamper = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcVibrationDamper(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcVibrationDamperType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcVibrationDamperType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcVibrationIsolator = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcVibrationIsolator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcVibrationIsolatorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcVibrationIsolatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcVirtualElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcVirtualElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcVirtualGridIntersection = class {
  constructor(expressID, type, IntersectingAxes, OffsetDistances) {
    this.expressID = expressID;
    this.type = type;
    this.IntersectingAxes = IntersectingAxes;
    this.OffsetDistances = OffsetDistances;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let IntersectingAxes = tape[ptr++];
    let OffsetDistances = tape[ptr++];
    return new IfcVirtualGridIntersection(expressID, type, IntersectingAxes, OffsetDistances);
  }
  ToTape() {
    let args = [];
    args.push(this.IntersectingAxes);
    args.push(this.OffsetDistances);
    return args;
  }
};
var IfcVoidingFeature = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcVoidingFeature(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcWall = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWall(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcWallElementedCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWallElementedCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcWallStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWallStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcWallType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWallType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcWasteTerminal = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWasteTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcWasteTerminalType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWasteTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcWindow = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.OverallHeight = OverallHeight;
    this.OverallWidth = OverallWidth;
    this.PredefinedType = PredefinedType;
    this.PartitioningType = PartitioningType;
    this.UserDefinedPartitioningType = UserDefinedPartitioningType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let OverallHeight = tape[ptr++];
    let OverallWidth = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let PartitioningType = tape[ptr++];
    let UserDefinedPartitioningType = tape[ptr++];
    return new IfcWindow(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.OverallHeight);
    args.push(this.OverallWidth);
    args.push(this.PredefinedType);
    args.push(this.PartitioningType);
    args.push(this.UserDefinedPartitioningType);
    return args;
  }
};
var IfcWindowLiningProperties = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, TransomThickness, MullionThickness, FirstTransomOffset, SecondTransomOffset, FirstMullionOffset, SecondMullionOffset, ShapeAspectStyle, LiningOffset, LiningToPanelOffsetX, LiningToPanelOffsetY) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.LiningDepth = LiningDepth;
    this.LiningThickness = LiningThickness;
    this.TransomThickness = TransomThickness;
    this.MullionThickness = MullionThickness;
    this.FirstTransomOffset = FirstTransomOffset;
    this.SecondTransomOffset = SecondTransomOffset;
    this.FirstMullionOffset = FirstMullionOffset;
    this.SecondMullionOffset = SecondMullionOffset;
    this.ShapeAspectStyle = ShapeAspectStyle;
    this.LiningOffset = LiningOffset;
    this.LiningToPanelOffsetX = LiningToPanelOffsetX;
    this.LiningToPanelOffsetY = LiningToPanelOffsetY;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let LiningDepth = tape[ptr++];
    let LiningThickness = tape[ptr++];
    let TransomThickness = tape[ptr++];
    let MullionThickness = tape[ptr++];
    let FirstTransomOffset = tape[ptr++];
    let SecondTransomOffset = tape[ptr++];
    let FirstMullionOffset = tape[ptr++];
    let SecondMullionOffset = tape[ptr++];
    let ShapeAspectStyle = tape[ptr++];
    let LiningOffset = tape[ptr++];
    let LiningToPanelOffsetX = tape[ptr++];
    let LiningToPanelOffsetY = tape[ptr++];
    return new IfcWindowLiningProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, TransomThickness, MullionThickness, FirstTransomOffset, SecondTransomOffset, FirstMullionOffset, SecondMullionOffset, ShapeAspectStyle, LiningOffset, LiningToPanelOffsetX, LiningToPanelOffsetY);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.LiningDepth);
    args.push(this.LiningThickness);
    args.push(this.TransomThickness);
    args.push(this.MullionThickness);
    args.push(this.FirstTransomOffset);
    args.push(this.SecondTransomOffset);
    args.push(this.FirstMullionOffset);
    args.push(this.SecondMullionOffset);
    args.push(this.ShapeAspectStyle);
    args.push(this.LiningOffset);
    args.push(this.LiningToPanelOffsetX);
    args.push(this.LiningToPanelOffsetY);
    return args;
  }
};
var IfcWindowPanelProperties = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.OperationType = OperationType;
    this.PanelPosition = PanelPosition;
    this.FrameDepth = FrameDepth;
    this.FrameThickness = FrameThickness;
    this.ShapeAspectStyle = ShapeAspectStyle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let OperationType = tape[ptr++];
    let PanelPosition = tape[ptr++];
    let FrameDepth = tape[ptr++];
    let FrameThickness = tape[ptr++];
    let ShapeAspectStyle = tape[ptr++];
    return new IfcWindowPanelProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.OperationType);
    args.push(this.PanelPosition);
    args.push(this.FrameDepth);
    args.push(this.FrameThickness);
    args.push(this.ShapeAspectStyle);
    return args;
  }
};
var IfcWindowStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.OverallHeight = OverallHeight;
    this.OverallWidth = OverallWidth;
    this.PredefinedType = PredefinedType;
    this.PartitioningType = PartitioningType;
    this.UserDefinedPartitioningType = UserDefinedPartitioningType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let OverallHeight = tape[ptr++];
    let OverallWidth = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let PartitioningType = tape[ptr++];
    let UserDefinedPartitioningType = tape[ptr++];
    return new IfcWindowStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.OverallHeight);
    args.push(this.OverallWidth);
    args.push(this.PredefinedType);
    args.push(this.PartitioningType);
    args.push(this.UserDefinedPartitioningType);
    return args;
  }
};
var IfcWindowStyle = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ConstructionType, OperationType, ParameterTakesPrecedence, Sizeable) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ConstructionType = ConstructionType;
    this.OperationType = OperationType;
    this.ParameterTakesPrecedence = ParameterTakesPrecedence;
    this.Sizeable = Sizeable;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ConstructionType = tape[ptr++];
    let OperationType = tape[ptr++];
    let ParameterTakesPrecedence = tape[ptr++];
    let Sizeable = tape[ptr++];
    return new IfcWindowStyle(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ConstructionType, OperationType, ParameterTakesPrecedence, Sizeable);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ConstructionType);
    args.push(this.OperationType);
    args.push(this.ParameterTakesPrecedence);
    args.push(this.Sizeable);
    return args;
  }
};
var IfcWindowType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, PartitioningType, ParameterTakesPrecedence, UserDefinedPartitioningType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.PartitioningType = PartitioningType;
    this.ParameterTakesPrecedence = ParameterTakesPrecedence;
    this.UserDefinedPartitioningType = UserDefinedPartitioningType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let PartitioningType = tape[ptr++];
    let ParameterTakesPrecedence = tape[ptr++];
    let UserDefinedPartitioningType = tape[ptr++];
    return new IfcWindowType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, PartitioningType, ParameterTakesPrecedence, UserDefinedPartitioningType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    args.push(this.PartitioningType);
    args.push(this.ParameterTakesPrecedence);
    args.push(this.UserDefinedPartitioningType);
    return args;
  }
};
var IfcWorkCalendar = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, WorkingTimes, ExceptionTimes, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.WorkingTimes = WorkingTimes;
    this.ExceptionTimes = ExceptionTimes;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let WorkingTimes = tape[ptr++];
    let ExceptionTimes = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWorkCalendar(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, WorkingTimes, ExceptionTimes, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.WorkingTimes);
    args.push(this.ExceptionTimes);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcWorkControl = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.CreationDate = CreationDate;
    this.Creators = Creators;
    this.Purpose = Purpose;
    this.Duration = Duration;
    this.TotalFloat = TotalFloat;
    this.StartTime = StartTime;
    this.FinishTime = FinishTime;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let CreationDate = tape[ptr++];
    let Creators = tape[ptr++];
    let Purpose = tape[ptr++];
    let Duration = tape[ptr++];
    let TotalFloat = tape[ptr++];
    let StartTime = tape[ptr++];
    let FinishTime = tape[ptr++];
    return new IfcWorkControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.CreationDate);
    args.push(this.Creators);
    args.push(this.Purpose);
    args.push(this.Duration);
    args.push(this.TotalFloat);
    args.push(this.StartTime);
    args.push(this.FinishTime);
    return args;
  }
};
var IfcWorkPlan = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.CreationDate = CreationDate;
    this.Creators = Creators;
    this.Purpose = Purpose;
    this.Duration = Duration;
    this.TotalFloat = TotalFloat;
    this.StartTime = StartTime;
    this.FinishTime = FinishTime;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let CreationDate = tape[ptr++];
    let Creators = tape[ptr++];
    let Purpose = tape[ptr++];
    let Duration = tape[ptr++];
    let TotalFloat = tape[ptr++];
    let StartTime = tape[ptr++];
    let FinishTime = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWorkPlan(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.CreationDate);
    args.push(this.Creators);
    args.push(this.Purpose);
    args.push(this.Duration);
    args.push(this.TotalFloat);
    args.push(this.StartTime);
    args.push(this.FinishTime);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcWorkSchedule = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.CreationDate = CreationDate;
    this.Creators = Creators;
    this.Purpose = Purpose;
    this.Duration = Duration;
    this.TotalFloat = TotalFloat;
    this.StartTime = StartTime;
    this.FinishTime = FinishTime;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let CreationDate = tape[ptr++];
    let Creators = tape[ptr++];
    let Purpose = tape[ptr++];
    let Duration = tape[ptr++];
    let TotalFloat = tape[ptr++];
    let StartTime = tape[ptr++];
    let FinishTime = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWorkSchedule(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.CreationDate);
    args.push(this.Creators);
    args.push(this.Purpose);
    args.push(this.Duration);
    args.push(this.TotalFloat);
    args.push(this.StartTime);
    args.push(this.FinishTime);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcWorkTime = class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, RecurrencePattern, Start, Finish) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.RecurrencePattern = RecurrencePattern;
    this.Start = Start;
    this.Finish = Finish;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let RecurrencePattern = tape[ptr++];
    let Start = tape[ptr++];
    let Finish = tape[ptr++];
    return new IfcWorkTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, RecurrencePattern, Start, Finish);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.DataOrigin);
    args.push(this.UserDefinedDataOrigin);
    args.push(this.RecurrencePattern);
    args.push(this.Start);
    args.push(this.Finish);
    return args;
  }
};
var IfcZShapeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Depth = Depth;
    this.FlangeWidth = FlangeWidth;
    this.WebThickness = WebThickness;
    this.FlangeThickness = FlangeThickness;
    this.FilletRadius = FilletRadius;
    this.EdgeRadius = EdgeRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Depth = tape[ptr++];
    let FlangeWidth = tape[ptr++];
    let WebThickness = tape[ptr++];
    let FlangeThickness = tape[ptr++];
    let FilletRadius = tape[ptr++];
    let EdgeRadius = tape[ptr++];
    return new IfcZShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.Depth);
    args.push(this.FlangeWidth);
    args.push(this.WebThickness);
    args.push(this.FlangeThickness);
    args.push(this.FilletRadius);
    args.push(this.EdgeRadius);
    return args;
  }
};
var IfcZone = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcZone(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.LongName);
    return args;
  }
};

// dist/helpers/ifc-elements.ts
var IfcElements2 = {
  103090709: "IFCPROJECT",
  4097777520: "IFCSITE",
  4031249490: "IFCBUILDING",
  3124254112: "IFCBUILDINGSTOREY",
  3856911033: "IFCSPACE",
  1674181508: "IFCANNOTATION",
  25142252: "IFCCONTROLLER",
  32344328: "IFCBOILER",
  76236018: "IFCLAMP",
  90941305: "IFCPUMP",
  177149247: "IFCAIRTERMINALBOX",
  182646315: "IFCFLOWINSTRUMENT",
  263784265: "IFCFURNISHINGELEMENT",
  264262732: "IFCELECTRICGENERATOR",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  310824031: "IFCPIPEFITTING",
  331165859: "IFCSTAIR",
  342316401: "IFCDUCTFITTING",
  377706215: "IFCMECHANICALFASTENER",
  395920057: "IFCDOOR",
  402227799: "IFCELECTRICMOTOR",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  484807127: "IFCEVAPORATOR",
  486154966: "IFCWINDOWSTANDARDCASE",
  629592764: "IFCLIGHTFIXTURE",
  630975310: "IFCUNITARYCONTROLELEMENT",
  635142910: "IFCCABLECARRIERFITTING",
  639361253: "IFCCOIL",
  647756555: "IFCFASTENER",
  707683696: "IFCFLOWSTORAGEDEVICE",
  738039164: "IFCPROTECTIVEDEVICE",
  753842376: "IFCBEAM",
  812556717: "IFCTANK",
  819412036: "IFCFILTER",
  843113511: "IFCCOLUMN",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  900683007: "IFCFOOTING",
  905975707: "IFCCOLUMNSTANDARDCASE",
  926996030: "IFCVOIDINGFEATURE",
  979691226: "IFCREINFORCINGBAR",
  987401354: "IFCFLOWSEGMENT",
  1003880860: "IFCELECTRICTIMECONTROL",
  1051757585: "IFCCABLEFITTING",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  1073191201: "IFCMEMBER",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  1156407060: "IFCPLATESTANDARDCASE",
  1162798199: "IFCSWITCHINGDEVICE",
  1329646415: "IFCSHADINGDEVICE",
  1335981549: "IFCDISCRETEACCESSORY",
  1360408905: "IFCDUCTSILENCER",
  1404847402: "IFCSTACKTERMINAL",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  1437502449: "IFCMEDICALDEVICE",
  1509553395: "IFCFURNITURE",
  1529196076: "IFCSLAB",
  1620046519: "IFCTRANSPORTELEMENT",
  1634111441: "IFCAIRTERMINAL",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  1677625105: "IFCCIVILELEMENT",
  1687234759: "IFCPILE",
  1904799276: "IFCELECTRICAPPLIANCE",
  1911478936: "IFCMEMBERSTANDARDCASE",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  1973544240: "IFCCOVERING",
  1999602285: "IFCSPACEHEATER",
  2016517767: "IFCROOF",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  2058353004: "IFCFLOWCONTROLLER",
  2068733104: "IFCHUMIDIFIER",
  2176052936: "IFCJUNCTIONBOX",
  2188021234: "IFCFLOWMETER",
  2223149337: "IFCFLOWTERMINAL",
  2262370178: "IFCRAILING",
  2272882330: "IFCCONDENSER",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  2320036040: "IFCREINFORCINGMESH",
  2347447852: "IFCTENDONANCHOR",
  2391383451: "IFCVIBRATIONISOLATOR",
  2391406946: "IFCWALL",
  2474470126: "IFCMOTORCONNECTION",
  2769231204: "IFCVIRTUALELEMENT",
  2814081492: "IFCENGINE",
  2906023776: "IFCBEAMSTANDARDCASE",
  2938176219: "IFCBURNER",
  2979338954: "IFCBUILDINGELEMENTPART",
  3024970846: "IFCRAMP",
  3026737570: "IFCTUBEBUNDLE",
  3027962421: "IFCSLABSTANDARDCASE",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  3053780830: "IFCSANITARYTERMINAL",
  3079942009: "IFCOPENINGSTANDARDCASE",
  3087945054: "IFCALARM",
  3101698114: "IFCSURFACEFEATURE",
  3127900445: "IFCSLABELEMENTEDCASE",
  3132237377: "IFCFLOWMOVINGDEVICE",
  3171933400: "IFCPLATE",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  3242481149: "IFCDOORSTANDARDCASE",
  3283111854: "IFCRAMPFLIGHT",
  3296154744: "IFCCHIMNEY",
  3304561284: "IFCWINDOW",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  3319311131: "IFCHEATEXCHANGER",
  3415622556: "IFCFAN",
  3420628829: "IFCSOLARDEVICE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  3495092785: "IFCCURTAINWALL",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  3512223829: "IFCWALLSTANDARDCASE",
  3518393246: "IFCDUCTSEGMENT",
  3571504051: "IFCCOMPRESSOR",
  3588315303: "IFCOPENINGELEMENT",
  3612865200: "IFCPIPESEGMENT",
  3640358203: "IFCCOOLINGTOWER",
  3651124850: "IFCPROJECTIONELEMENT",
  3694346114: "IFCOUTLET",
  3747195512: "IFCEVAPORATIVECOOLER",
  3758799889: "IFCCABLECARRIERSEGMENT",
  3824725483: "IFCTENDON",
  3825984169: "IFCTRANSFORMER",
  3902619387: "IFCCHILLER",
  4074379575: "IFCDAMPER",
  4086658281: "IFCSENSOR",
  4123344466: "IFCELEMENTASSEMBLY",
  4136498852: "IFCCOOLEDBEAM",
  4156078855: "IFCWALLELEMENTEDCASE",
  4175244083: "IFCINTERCEPTOR",
  4207607924: "IFCVALVE",
  4217484030: "IFCCABLESEGMENT",
  4237592921: "IFCWASTETERMINAL",
  4252922144: "IFCSTAIRFLIGHT",
  4278956645: "IFCFLOWFITTING",
  4288193352: "IFCACTUATOR",
  4292641817: "IFCUNITARYEQUIPMENT",
  3009204131: "IFCGRID"
};

// dist/helpers/types-map.ts
var IfcTypesMap$1 = {
  3821786052: "IFCACTIONREQUEST",
  2296667514: "IFCACTOR",
  3630933823: "IFCACTORROLE",
  4288193352: "IFCACTUATOR",
  2874132201: "IFCACTUATORTYPE",
  618182010: "IFCADDRESS",
  1635779807: "IFCADVANCEDBREP",
  2603310189: "IFCADVANCEDBREPWITHVOIDS",
  3406155212: "IFCADVANCEDFACE",
  1634111441: "IFCAIRTERMINAL",
  177149247: "IFCAIRTERMINALBOX",
  1411407467: "IFCAIRTERMINALBOXTYPE",
  3352864051: "IFCAIRTERMINALTYPE",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  1871374353: "IFCAIRTOAIRHEATRECOVERYTYPE",
  3087945054: "IFCALARM",
  3001207471: "IFCALARMTYPE",
  325726236: "IFCALIGNMENT",
  749761778: "IFCALIGNMENT2DHORIZONTAL",
  3199563722: "IFCALIGNMENT2DHORIZONTALSEGMENT",
  2483840362: "IFCALIGNMENT2DSEGMENT",
  3379348081: "IFCALIGNMENT2DVERSEGCIRCULARARC",
  3239324667: "IFCALIGNMENT2DVERSEGLINE",
  4263986512: "IFCALIGNMENT2DVERSEGPARABOLICARC",
  53199957: "IFCALIGNMENT2DVERTICAL",
  2029264950: "IFCALIGNMENT2DVERTICALSEGMENT",
  3512275521: "IFCALIGNMENTCURVE",
  1674181508: "IFCANNOTATION",
  669184980: "IFCANNOTATIONFILLAREA",
  639542469: "IFCAPPLICATION",
  411424972: "IFCAPPLIEDVALUE",
  130549933: "IFCAPPROVAL",
  3869604511: "IFCAPPROVALRELATIONSHIP",
  3798115385: "IFCARBITRARYCLOSEDPROFILEDEF",
  1310608509: "IFCARBITRARYOPENPROFILEDEF",
  2705031697: "IFCARBITRARYPROFILEDEFWITHVOIDS",
  3460190687: "IFCASSET",
  3207858831: "IFCASYMMETRICISHAPEPROFILEDEF",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  1532957894: "IFCAUDIOVISUALAPPLIANCETYPE",
  4261334040: "IFCAXIS1PLACEMENT",
  3125803723: "IFCAXIS2PLACEMENT2D",
  2740243338: "IFCAXIS2PLACEMENT3D",
  1967976161: "IFCBSPLINECURVE",
  2461110595: "IFCBSPLINECURVEWITHKNOTS",
  2887950389: "IFCBSPLINESURFACE",
  167062518: "IFCBSPLINESURFACEWITHKNOTS",
  753842376: "IFCBEAM",
  2906023776: "IFCBEAMSTANDARDCASE",
  819618141: "IFCBEAMTYPE",
  4196446775: "IFCBEARING",
  3649138523: "IFCBEARINGTYPE",
  616511568: "IFCBLOBTEXTURE",
  1334484129: "IFCBLOCK",
  32344328: "IFCBOILER",
  231477066: "IFCBOILERTYPE",
  3649129432: "IFCBOOLEANCLIPPINGRESULT",
  2736907675: "IFCBOOLEANRESULT",
  4037036970: "IFCBOUNDARYCONDITION",
  1136057603: "IFCBOUNDARYCURVE",
  1560379544: "IFCBOUNDARYEDGECONDITION",
  3367102660: "IFCBOUNDARYFACECONDITION",
  1387855156: "IFCBOUNDARYNODECONDITION",
  2069777674: "IFCBOUNDARYNODECONDITIONWARPING",
  1260505505: "IFCBOUNDEDCURVE",
  4182860854: "IFCBOUNDEDSURFACE",
  2581212453: "IFCBOUNDINGBOX",
  2713105998: "IFCBOXEDHALFSPACE",
  644574406: "IFCBRIDGE",
  963979645: "IFCBRIDGEPART",
  4031249490: "IFCBUILDING",
  3299480353: "IFCBUILDINGELEMENT",
  2979338954: "IFCBUILDINGELEMENTPART",
  39481116: "IFCBUILDINGELEMENTPARTTYPE",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  1909888760: "IFCBUILDINGELEMENTPROXYTYPE",
  1950629157: "IFCBUILDINGELEMENTTYPE",
  3124254112: "IFCBUILDINGSTOREY",
  1177604601: "IFCBUILDINGSYSTEM",
  2938176219: "IFCBURNER",
  2188180465: "IFCBURNERTYPE",
  2898889636: "IFCCSHAPEPROFILEDEF",
  635142910: "IFCCABLECARRIERFITTING",
  395041908: "IFCCABLECARRIERFITTINGTYPE",
  3758799889: "IFCCABLECARRIERSEGMENT",
  3293546465: "IFCCABLECARRIERSEGMENTTYPE",
  1051757585: "IFCCABLEFITTING",
  2674252688: "IFCCABLEFITTINGTYPE",
  4217484030: "IFCCABLESEGMENT",
  1285652485: "IFCCABLESEGMENTTYPE",
  3999819293: "IFCCAISSONFOUNDATION",
  3203706013: "IFCCAISSONFOUNDATIONTYPE",
  1123145078: "IFCCARTESIANPOINT",
  574549367: "IFCCARTESIANPOINTLIST",
  1675464909: "IFCCARTESIANPOINTLIST2D",
  2059837836: "IFCCARTESIANPOINTLIST3D",
  59481748: "IFCCARTESIANTRANSFORMATIONOPERATOR",
  3749851601: "IFCCARTESIANTRANSFORMATIONOPERATOR2D",
  3486308946: "IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",
  3331915920: "IFCCARTESIANTRANSFORMATIONOPERATOR3D",
  1416205885: "IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",
  3150382593: "IFCCENTERLINEPROFILEDEF",
  3902619387: "IFCCHILLER",
  2951183804: "IFCCHILLERTYPE",
  3296154744: "IFCCHIMNEY",
  2197970202: "IFCCHIMNEYTYPE",
  2611217952: "IFCCIRCLE",
  2937912522: "IFCCIRCLEHOLLOWPROFILEDEF",
  1383045692: "IFCCIRCLEPROFILEDEF",
  1062206242: "IFCCIRCULARARCSEGMENT2D",
  1677625105: "IFCCIVILELEMENT",
  3893394355: "IFCCIVILELEMENTTYPE",
  747523909: "IFCCLASSIFICATION",
  647927063: "IFCCLASSIFICATIONREFERENCE",
  2205249479: "IFCCLOSEDSHELL",
  639361253: "IFCCOIL",
  2301859152: "IFCCOILTYPE",
  776857604: "IFCCOLOURRGB",
  3285139300: "IFCCOLOURRGBLIST",
  3264961684: "IFCCOLOURSPECIFICATION",
  843113511: "IFCCOLUMN",
  905975707: "IFCCOLUMNSTANDARDCASE",
  300633059: "IFCCOLUMNTYPE",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  400855858: "IFCCOMMUNICATIONSAPPLIANCETYPE",
  2542286263: "IFCCOMPLEXPROPERTY",
  3875453745: "IFCCOMPLEXPROPERTYTEMPLATE",
  3732776249: "IFCCOMPOSITECURVE",
  15328376: "IFCCOMPOSITECURVEONSURFACE",
  2485617015: "IFCCOMPOSITECURVESEGMENT",
  1485152156: "IFCCOMPOSITEPROFILEDEF",
  3571504051: "IFCCOMPRESSOR",
  3850581409: "IFCCOMPRESSORTYPE",
  2272882330: "IFCCONDENSER",
  2816379211: "IFCCONDENSERTYPE",
  2510884976: "IFCCONIC",
  370225590: "IFCCONNECTEDFACESET",
  1981873012: "IFCCONNECTIONCURVEGEOMETRY",
  2859738748: "IFCCONNECTIONGEOMETRY",
  45288368: "IFCCONNECTIONPOINTECCENTRICITY",
  2614616156: "IFCCONNECTIONPOINTGEOMETRY",
  2732653382: "IFCCONNECTIONSURFACEGEOMETRY",
  775493141: "IFCCONNECTIONVOLUMEGEOMETRY",
  1959218052: "IFCCONSTRAINT",
  3898045240: "IFCCONSTRUCTIONEQUIPMENTRESOURCE",
  2185764099: "IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",
  1060000209: "IFCCONSTRUCTIONMATERIALRESOURCE",
  4105962743: "IFCCONSTRUCTIONMATERIALRESOURCETYPE",
  488727124: "IFCCONSTRUCTIONPRODUCTRESOURCE",
  1525564444: "IFCCONSTRUCTIONPRODUCTRESOURCETYPE",
  2559216714: "IFCCONSTRUCTIONRESOURCE",
  2574617495: "IFCCONSTRUCTIONRESOURCETYPE",
  3419103109: "IFCCONTEXT",
  3050246964: "IFCCONTEXTDEPENDENTUNIT",
  3293443760: "IFCCONTROL",
  25142252: "IFCCONTROLLER",
  578613899: "IFCCONTROLLERTYPE",
  2889183280: "IFCCONVERSIONBASEDUNIT",
  2713554722: "IFCCONVERSIONBASEDUNITWITHOFFSET",
  4136498852: "IFCCOOLEDBEAM",
  335055490: "IFCCOOLEDBEAMTYPE",
  3640358203: "IFCCOOLINGTOWER",
  2954562838: "IFCCOOLINGTOWERTYPE",
  1785450214: "IFCCOORDINATEOPERATION",
  1466758467: "IFCCOORDINATEREFERENCESYSTEM",
  3895139033: "IFCCOSTITEM",
  1419761937: "IFCCOSTSCHEDULE",
  602808272: "IFCCOSTVALUE",
  1973544240: "IFCCOVERING",
  1916426348: "IFCCOVERINGTYPE",
  3295246426: "IFCCREWRESOURCE",
  1815067380: "IFCCREWRESOURCETYPE",
  2506170314: "IFCCSGPRIMITIVE3D",
  2147822146: "IFCCSGSOLID",
  539742890: "IFCCURRENCYRELATIONSHIP",
  3495092785: "IFCCURTAINWALL",
  1457835157: "IFCCURTAINWALLTYPE",
  2601014836: "IFCCURVE",
  2827736869: "IFCCURVEBOUNDEDPLANE",
  2629017746: "IFCCURVEBOUNDEDSURFACE",
  1186437898: "IFCCURVESEGMENT2D",
  3800577675: "IFCCURVESTYLE",
  1105321065: "IFCCURVESTYLEFONT",
  2367409068: "IFCCURVESTYLEFONTANDSCALING",
  3510044353: "IFCCURVESTYLEFONTPATTERN",
  1213902940: "IFCCYLINDRICALSURFACE",
  4074379575: "IFCDAMPER",
  3961806047: "IFCDAMPERTYPE",
  3426335179: "IFCDEEPFOUNDATION",
  1306400036: "IFCDEEPFOUNDATIONTYPE",
  3632507154: "IFCDERIVEDPROFILEDEF",
  1765591967: "IFCDERIVEDUNIT",
  1045800335: "IFCDERIVEDUNITELEMENT",
  2949456006: "IFCDIMENSIONALEXPONENTS",
  32440307: "IFCDIRECTION",
  1335981549: "IFCDISCRETEACCESSORY",
  2635815018: "IFCDISCRETEACCESSORYTYPE",
  1945343521: "IFCDISTANCEEXPRESSION",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  1599208980: "IFCDISTRIBUTIONCHAMBERELEMENTTYPE",
  562808652: "IFCDISTRIBUTIONCIRCUIT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  2063403501: "IFCDISTRIBUTIONCONTROLELEMENTTYPE",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  3256556792: "IFCDISTRIBUTIONELEMENTTYPE",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  3849074793: "IFCDISTRIBUTIONFLOWELEMENTTYPE",
  3041715199: "IFCDISTRIBUTIONPORT",
  3205830791: "IFCDISTRIBUTIONSYSTEM",
  1154170062: "IFCDOCUMENTINFORMATION",
  770865208: "IFCDOCUMENTINFORMATIONRELATIONSHIP",
  3732053477: "IFCDOCUMENTREFERENCE",
  395920057: "IFCDOOR",
  2963535650: "IFCDOORLININGPROPERTIES",
  1714330368: "IFCDOORPANELPROPERTIES",
  3242481149: "IFCDOORSTANDARDCASE",
  526551008: "IFCDOORSTYLE",
  2323601079: "IFCDOORTYPE",
  445594917: "IFCDRAUGHTINGPREDEFINEDCOLOUR",
  4006246654: "IFCDRAUGHTINGPREDEFINEDCURVEFONT",
  342316401: "IFCDUCTFITTING",
  869906466: "IFCDUCTFITTINGTYPE",
  3518393246: "IFCDUCTSEGMENT",
  3760055223: "IFCDUCTSEGMENTTYPE",
  1360408905: "IFCDUCTSILENCER",
  2030761528: "IFCDUCTSILENCERTYPE",
  3900360178: "IFCEDGE",
  476780140: "IFCEDGECURVE",
  1472233963: "IFCEDGELOOP",
  1904799276: "IFCELECTRICAPPLIANCE",
  663422040: "IFCELECTRICAPPLIANCETYPE",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  2417008758: "IFCELECTRICDISTRIBUTIONBOARDTYPE",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  3277789161: "IFCELECTRICFLOWSTORAGEDEVICETYPE",
  264262732: "IFCELECTRICGENERATOR",
  1534661035: "IFCELECTRICGENERATORTYPE",
  402227799: "IFCELECTRICMOTOR",
  1217240411: "IFCELECTRICMOTORTYPE",
  1003880860: "IFCELECTRICTIMECONTROL",
  712377611: "IFCELECTRICTIMECONTROLTYPE",
  1758889154: "IFCELEMENT",
  4123344466: "IFCELEMENTASSEMBLY",
  2397081782: "IFCELEMENTASSEMBLYTYPE",
  1623761950: "IFCELEMENTCOMPONENT",
  2590856083: "IFCELEMENTCOMPONENTTYPE",
  1883228015: "IFCELEMENTQUANTITY",
  339256511: "IFCELEMENTTYPE",
  2777663545: "IFCELEMENTARYSURFACE",
  1704287377: "IFCELLIPSE",
  2835456948: "IFCELLIPSEPROFILEDEF",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  2107101300: "IFCENERGYCONVERSIONDEVICETYPE",
  2814081492: "IFCENGINE",
  132023988: "IFCENGINETYPE",
  3747195512: "IFCEVAPORATIVECOOLER",
  3174744832: "IFCEVAPORATIVECOOLERTYPE",
  484807127: "IFCEVAPORATOR",
  3390157468: "IFCEVAPORATORTYPE",
  4148101412: "IFCEVENT",
  211053100: "IFCEVENTTIME",
  4024345920: "IFCEVENTTYPE",
  297599258: "IFCEXTENDEDPROPERTIES",
  4294318154: "IFCEXTERNALINFORMATION",
  3200245327: "IFCEXTERNALREFERENCE",
  1437805879: "IFCEXTERNALREFERENCERELATIONSHIP",
  1209101575: "IFCEXTERNALSPATIALELEMENT",
  2853485674: "IFCEXTERNALSPATIALSTRUCTUREELEMENT",
  2242383968: "IFCEXTERNALLYDEFINEDHATCHSTYLE",
  1040185647: "IFCEXTERNALLYDEFINEDSURFACESTYLE",
  3548104201: "IFCEXTERNALLYDEFINEDTEXTFONT",
  477187591: "IFCEXTRUDEDAREASOLID",
  2804161546: "IFCEXTRUDEDAREASOLIDTAPERED",
  2556980723: "IFCFACE",
  2047409740: "IFCFACEBASEDSURFACEMODEL",
  1809719519: "IFCFACEBOUND",
  803316827: "IFCFACEOUTERBOUND",
  3008276851: "IFCFACESURFACE",
  807026263: "IFCFACETEDBREP",
  3737207727: "IFCFACETEDBREPWITHVOIDS",
  24185140: "IFCFACILITY",
  1310830890: "IFCFACILITYPART",
  4219587988: "IFCFAILURECONNECTIONCONDITION",
  3415622556: "IFCFAN",
  346874300: "IFCFANTYPE",
  647756555: "IFCFASTENER",
  2489546625: "IFCFASTENERTYPE",
  2827207264: "IFCFEATUREELEMENT",
  2143335405: "IFCFEATUREELEMENTADDITION",
  1287392070: "IFCFEATUREELEMENTSUBTRACTION",
  738692330: "IFCFILLAREASTYLE",
  374418227: "IFCFILLAREASTYLEHATCHING",
  315944413: "IFCFILLAREASTYLETILES",
  819412036: "IFCFILTER",
  1810631287: "IFCFILTERTYPE",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  4222183408: "IFCFIRESUPPRESSIONTERMINALTYPE",
  2652556860: "IFCFIXEDREFERENCESWEPTAREASOLID",
  2058353004: "IFCFLOWCONTROLLER",
  3907093117: "IFCFLOWCONTROLLERTYPE",
  4278956645: "IFCFLOWFITTING",
  3198132628: "IFCFLOWFITTINGTYPE",
  182646315: "IFCFLOWINSTRUMENT",
  4037862832: "IFCFLOWINSTRUMENTTYPE",
  2188021234: "IFCFLOWMETER",
  3815607619: "IFCFLOWMETERTYPE",
  3132237377: "IFCFLOWMOVINGDEVICE",
  1482959167: "IFCFLOWMOVINGDEVICETYPE",
  987401354: "IFCFLOWSEGMENT",
  1834744321: "IFCFLOWSEGMENTTYPE",
  707683696: "IFCFLOWSTORAGEDEVICE",
  1339347760: "IFCFLOWSTORAGEDEVICETYPE",
  2223149337: "IFCFLOWTERMINAL",
  2297155007: "IFCFLOWTERMINALTYPE",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  3009222698: "IFCFLOWTREATMENTDEVICETYPE",
  900683007: "IFCFOOTING",
  1893162501: "IFCFOOTINGTYPE",
  263784265: "IFCFURNISHINGELEMENT",
  4238390223: "IFCFURNISHINGELEMENTTYPE",
  1509553395: "IFCFURNITURE",
  1268542332: "IFCFURNITURETYPE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  4095422895: "IFCGEOGRAPHICELEMENTTYPE",
  987898635: "IFCGEOMETRICCURVESET",
  3448662350: "IFCGEOMETRICREPRESENTATIONCONTEXT",
  2453401579: "IFCGEOMETRICREPRESENTATIONITEM",
  4142052618: "IFCGEOMETRICREPRESENTATIONSUBCONTEXT",
  3590301190: "IFCGEOMETRICSET",
  3009204131: "IFCGRID",
  852622518: "IFCGRIDAXIS",
  178086475: "IFCGRIDPLACEMENT",
  2706460486: "IFCGROUP",
  812098782: "IFCHALFSPACESOLID",
  3319311131: "IFCHEATEXCHANGER",
  1251058090: "IFCHEATEXCHANGERTYPE",
  2068733104: "IFCHUMIDIFIER",
  1806887404: "IFCHUMIDIFIERTYPE",
  1484403080: "IFCISHAPEPROFILEDEF",
  3905492369: "IFCIMAGETEXTURE",
  3570813810: "IFCINDEXEDCOLOURMAP",
  2571569899: "IFCINDEXEDPOLYCURVE",
  178912537: "IFCINDEXEDPOLYGONALFACE",
  2294589976: "IFCINDEXEDPOLYGONALFACEWITHVOIDS",
  1437953363: "IFCINDEXEDTEXTUREMAP",
  2133299955: "IFCINDEXEDTRIANGLETEXTUREMAP",
  4175244083: "IFCINTERCEPTOR",
  3946677679: "IFCINTERCEPTORTYPE",
  3113134337: "IFCINTERSECTIONCURVE",
  2391368822: "IFCINVENTORY",
  3741457305: "IFCIRREGULARTIMESERIES",
  3020489413: "IFCIRREGULARTIMESERIESVALUE",
  2176052936: "IFCJUNCTIONBOX",
  4288270099: "IFCJUNCTIONBOXTYPE",
  572779678: "IFCLSHAPEPROFILEDEF",
  3827777499: "IFCLABORRESOURCE",
  428585644: "IFCLABORRESOURCETYPE",
  1585845231: "IFCLAGTIME",
  76236018: "IFCLAMP",
  1051575348: "IFCLAMPTYPE",
  2655187982: "IFCLIBRARYINFORMATION",
  3452421091: "IFCLIBRARYREFERENCE",
  4162380809: "IFCLIGHTDISTRIBUTIONDATA",
  629592764: "IFCLIGHTFIXTURE",
  1161773419: "IFCLIGHTFIXTURETYPE",
  1566485204: "IFCLIGHTINTENSITYDISTRIBUTION",
  1402838566: "IFCLIGHTSOURCE",
  125510826: "IFCLIGHTSOURCEAMBIENT",
  2604431987: "IFCLIGHTSOURCEDIRECTIONAL",
  4266656042: "IFCLIGHTSOURCEGONIOMETRIC",
  1520743889: "IFCLIGHTSOURCEPOSITIONAL",
  3422422726: "IFCLIGHTSOURCESPOT",
  1281925730: "IFCLINE",
  3092502836: "IFCLINESEGMENT2D",
  388784114: "IFCLINEARPLACEMENT",
  1154579445: "IFCLINEARPOSITIONINGELEMENT",
  2624227202: "IFCLOCALPLACEMENT",
  1008929658: "IFCLOOP",
  1425443689: "IFCMANIFOLDSOLIDBREP",
  3057273783: "IFCMAPCONVERSION",
  2347385850: "IFCMAPPEDITEM",
  1838606355: "IFCMATERIAL",
  1847130766: "IFCMATERIALCLASSIFICATIONRELATIONSHIP",
  3708119e3: "IFCMATERIALCONSTITUENT",
  2852063980: "IFCMATERIALCONSTITUENTSET",
  760658860: "IFCMATERIALDEFINITION",
  2022407955: "IFCMATERIALDEFINITIONREPRESENTATION",
  248100487: "IFCMATERIALLAYER",
  3303938423: "IFCMATERIALLAYERSET",
  1303795690: "IFCMATERIALLAYERSETUSAGE",
  1847252529: "IFCMATERIALLAYERWITHOFFSETS",
  2199411900: "IFCMATERIALLIST",
  2235152071: "IFCMATERIALPROFILE",
  164193824: "IFCMATERIALPROFILESET",
  3079605661: "IFCMATERIALPROFILESETUSAGE",
  3404854881: "IFCMATERIALPROFILESETUSAGETAPERING",
  552965576: "IFCMATERIALPROFILEWITHOFFSETS",
  3265635763: "IFCMATERIALPROPERTIES",
  853536259: "IFCMATERIALRELATIONSHIP",
  1507914824: "IFCMATERIALUSAGEDEFINITION",
  2597039031: "IFCMEASUREWITHUNIT",
  377706215: "IFCMECHANICALFASTENER",
  2108223431: "IFCMECHANICALFASTENERTYPE",
  1437502449: "IFCMEDICALDEVICE",
  1114901282: "IFCMEDICALDEVICETYPE",
  1073191201: "IFCMEMBER",
  1911478936: "IFCMEMBERSTANDARDCASE",
  3181161470: "IFCMEMBERTYPE",
  3368373690: "IFCMETRIC",
  2998442950: "IFCMIRROREDPROFILEDEF",
  2706619895: "IFCMONETARYUNIT",
  2474470126: "IFCMOTORCONNECTION",
  977012517: "IFCMOTORCONNECTIONTYPE",
  1918398963: "IFCNAMEDUNIT",
  3888040117: "IFCOBJECT",
  219451334: "IFCOBJECTDEFINITION",
  3701648758: "IFCOBJECTPLACEMENT",
  2251480897: "IFCOBJECTIVE",
  4143007308: "IFCOCCUPANT",
  590820931: "IFCOFFSETCURVE",
  3388369263: "IFCOFFSETCURVE2D",
  3505215534: "IFCOFFSETCURVE3D",
  2485787929: "IFCOFFSETCURVEBYDISTANCES",
  2665983363: "IFCOPENSHELL",
  3588315303: "IFCOPENINGELEMENT",
  3079942009: "IFCOPENINGSTANDARDCASE",
  4251960020: "IFCORGANIZATION",
  1411181986: "IFCORGANIZATIONRELATIONSHIP",
  643959842: "IFCORIENTATIONEXPRESSION",
  1029017970: "IFCORIENTEDEDGE",
  144952367: "IFCOUTERBOUNDARYCURVE",
  3694346114: "IFCOUTLET",
  2837617999: "IFCOUTLETTYPE",
  1207048766: "IFCOWNERHISTORY",
  2529465313: "IFCPARAMETERIZEDPROFILEDEF",
  2519244187: "IFCPATH",
  1682466193: "IFCPCURVE",
  2382730787: "IFCPERFORMANCEHISTORY",
  3566463478: "IFCPERMEABLECOVERINGPROPERTIES",
  3327091369: "IFCPERMIT",
  2077209135: "IFCPERSON",
  101040310: "IFCPERSONANDORGANIZATION",
  3021840470: "IFCPHYSICALCOMPLEXQUANTITY",
  2483315170: "IFCPHYSICALQUANTITY",
  2226359599: "IFCPHYSICALSIMPLEQUANTITY",
  1687234759: "IFCPILE",
  1158309216: "IFCPILETYPE",
  310824031: "IFCPIPEFITTING",
  804291784: "IFCPIPEFITTINGTYPE",
  3612865200: "IFCPIPESEGMENT",
  4231323485: "IFCPIPESEGMENTTYPE",
  597895409: "IFCPIXELTEXTURE",
  2004835150: "IFCPLACEMENT",
  603570806: "IFCPLANARBOX",
  1663979128: "IFCPLANAREXTENT",
  220341763: "IFCPLANE",
  3171933400: "IFCPLATE",
  1156407060: "IFCPLATESTANDARDCASE",
  4017108033: "IFCPLATETYPE",
  2067069095: "IFCPOINT",
  4022376103: "IFCPOINTONCURVE",
  1423911732: "IFCPOINTONSURFACE",
  2924175390: "IFCPOLYLOOP",
  2775532180: "IFCPOLYGONALBOUNDEDHALFSPACE",
  2839578677: "IFCPOLYGONALFACESET",
  3724593414: "IFCPOLYLINE",
  3740093272: "IFCPORT",
  1946335990: "IFCPOSITIONINGELEMENT",
  3355820592: "IFCPOSTALADDRESS",
  759155922: "IFCPREDEFINEDCOLOUR",
  2559016684: "IFCPREDEFINEDCURVEFONT",
  3727388367: "IFCPREDEFINEDITEM",
  3778827333: "IFCPREDEFINEDPROPERTIES",
  3967405729: "IFCPREDEFINEDPROPERTYSET",
  1775413392: "IFCPREDEFINEDTEXTFONT",
  677532197: "IFCPRESENTATIONITEM",
  2022622350: "IFCPRESENTATIONLAYERASSIGNMENT",
  1304840413: "IFCPRESENTATIONLAYERWITHSTYLE",
  3119450353: "IFCPRESENTATIONSTYLE",
  2417041796: "IFCPRESENTATIONSTYLEASSIGNMENT",
  2744685151: "IFCPROCEDURE",
  569719735: "IFCPROCEDURETYPE",
  2945172077: "IFCPROCESS",
  4208778838: "IFCPRODUCT",
  673634403: "IFCPRODUCTDEFINITIONSHAPE",
  2095639259: "IFCPRODUCTREPRESENTATION",
  3958567839: "IFCPROFILEDEF",
  2802850158: "IFCPROFILEPROPERTIES",
  103090709: "IFCPROJECT",
  653396225: "IFCPROJECTLIBRARY",
  2904328755: "IFCPROJECTORDER",
  3843373140: "IFCPROJECTEDCRS",
  3651124850: "IFCPROJECTIONELEMENT",
  2598011224: "IFCPROPERTY",
  986844984: "IFCPROPERTYABSTRACTION",
  871118103: "IFCPROPERTYBOUNDEDVALUE",
  1680319473: "IFCPROPERTYDEFINITION",
  148025276: "IFCPROPERTYDEPENDENCYRELATIONSHIP",
  4166981789: "IFCPROPERTYENUMERATEDVALUE",
  3710013099: "IFCPROPERTYENUMERATION",
  2752243245: "IFCPROPERTYLISTVALUE",
  941946838: "IFCPROPERTYREFERENCEVALUE",
  1451395588: "IFCPROPERTYSET",
  3357820518: "IFCPROPERTYSETDEFINITION",
  492091185: "IFCPROPERTYSETTEMPLATE",
  3650150729: "IFCPROPERTYSINGLEVALUE",
  110355661: "IFCPROPERTYTABLEVALUE",
  3521284610: "IFCPROPERTYTEMPLATE",
  1482703590: "IFCPROPERTYTEMPLATEDEFINITION",
  738039164: "IFCPROTECTIVEDEVICE",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  655969474: "IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",
  1842657554: "IFCPROTECTIVEDEVICETYPE",
  3219374653: "IFCPROXY",
  90941305: "IFCPUMP",
  2250791053: "IFCPUMPTYPE",
  2044713172: "IFCQUANTITYAREA",
  2093928680: "IFCQUANTITYCOUNT",
  931644368: "IFCQUANTITYLENGTH",
  2090586900: "IFCQUANTITYSET",
  3252649465: "IFCQUANTITYTIME",
  2405470396: "IFCQUANTITYVOLUME",
  825690147: "IFCQUANTITYWEIGHT",
  2262370178: "IFCRAILING",
  2893384427: "IFCRAILINGTYPE",
  3024970846: "IFCRAMP",
  3283111854: "IFCRAMPFLIGHT",
  2324767716: "IFCRAMPFLIGHTTYPE",
  1469900589: "IFCRAMPTYPE",
  1232101972: "IFCRATIONALBSPLINECURVEWITHKNOTS",
  683857671: "IFCRATIONALBSPLINESURFACEWITHKNOTS",
  2770003689: "IFCRECTANGLEHOLLOWPROFILEDEF",
  3615266464: "IFCRECTANGLEPROFILEDEF",
  2798486643: "IFCRECTANGULARPYRAMID",
  3454111270: "IFCRECTANGULARTRIMMEDSURFACE",
  3915482550: "IFCRECURRENCEPATTERN",
  2433181523: "IFCREFERENCE",
  4021432810: "IFCREFERENT",
  3413951693: "IFCREGULARTIMESERIES",
  1580146022: "IFCREINFORCEMENTBARPROPERTIES",
  3765753017: "IFCREINFORCEMENTDEFINITIONPROPERTIES",
  979691226: "IFCREINFORCINGBAR",
  2572171363: "IFCREINFORCINGBARTYPE",
  3027567501: "IFCREINFORCINGELEMENT",
  964333572: "IFCREINFORCINGELEMENTTYPE",
  2320036040: "IFCREINFORCINGMESH",
  2310774935: "IFCREINFORCINGMESHTYPE",
  160246688: "IFCRELAGGREGATES",
  3939117080: "IFCRELASSIGNS",
  1683148259: "IFCRELASSIGNSTOACTOR",
  2495723537: "IFCRELASSIGNSTOCONTROL",
  1307041759: "IFCRELASSIGNSTOGROUP",
  1027710054: "IFCRELASSIGNSTOGROUPBYFACTOR",
  4278684876: "IFCRELASSIGNSTOPROCESS",
  2857406711: "IFCRELASSIGNSTOPRODUCT",
  205026976: "IFCRELASSIGNSTORESOURCE",
  1865459582: "IFCRELASSOCIATES",
  4095574036: "IFCRELASSOCIATESAPPROVAL",
  919958153: "IFCRELASSOCIATESCLASSIFICATION",
  2728634034: "IFCRELASSOCIATESCONSTRAINT",
  982818633: "IFCRELASSOCIATESDOCUMENT",
  3840914261: "IFCRELASSOCIATESLIBRARY",
  2655215786: "IFCRELASSOCIATESMATERIAL",
  826625072: "IFCRELCONNECTS",
  1204542856: "IFCRELCONNECTSELEMENTS",
  3945020480: "IFCRELCONNECTSPATHELEMENTS",
  4201705270: "IFCRELCONNECTSPORTTOELEMENT",
  3190031847: "IFCRELCONNECTSPORTS",
  2127690289: "IFCRELCONNECTSSTRUCTURALACTIVITY",
  1638771189: "IFCRELCONNECTSSTRUCTURALMEMBER",
  504942748: "IFCRELCONNECTSWITHECCENTRICITY",
  3678494232: "IFCRELCONNECTSWITHREALIZINGELEMENTS",
  3242617779: "IFCRELCONTAINEDINSPATIALSTRUCTURE",
  886880790: "IFCRELCOVERSBLDGELEMENTS",
  2802773753: "IFCRELCOVERSSPACES",
  2565941209: "IFCRELDECLARES",
  2551354335: "IFCRELDECOMPOSES",
  693640335: "IFCRELDEFINES",
  1462361463: "IFCRELDEFINESBYOBJECT",
  4186316022: "IFCRELDEFINESBYPROPERTIES",
  307848117: "IFCRELDEFINESBYTEMPLATE",
  781010003: "IFCRELDEFINESBYTYPE",
  3940055652: "IFCRELFILLSELEMENT",
  279856033: "IFCRELFLOWCONTROLELEMENTS",
  427948657: "IFCRELINTERFERESELEMENTS",
  3268803585: "IFCRELNESTS",
  1441486842: "IFCRELPOSITIONS",
  750771296: "IFCRELPROJECTSELEMENT",
  1245217292: "IFCRELREFERENCEDINSPATIALSTRUCTURE",
  4122056220: "IFCRELSEQUENCE",
  366585022: "IFCRELSERVICESBUILDINGS",
  3451746338: "IFCRELSPACEBOUNDARY",
  3523091289: "IFCRELSPACEBOUNDARY1STLEVEL",
  1521410863: "IFCRELSPACEBOUNDARY2NDLEVEL",
  1401173127: "IFCRELVOIDSELEMENT",
  478536968: "IFCRELATIONSHIP",
  816062949: "IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",
  1076942058: "IFCREPRESENTATION",
  3377609919: "IFCREPRESENTATIONCONTEXT",
  3008791417: "IFCREPRESENTATIONITEM",
  1660063152: "IFCREPRESENTATIONMAP",
  2914609552: "IFCRESOURCE",
  2943643501: "IFCRESOURCEAPPROVALRELATIONSHIP",
  1608871552: "IFCRESOURCECONSTRAINTRELATIONSHIP",
  2439245199: "IFCRESOURCELEVELRELATIONSHIP",
  1042787934: "IFCRESOURCETIME",
  1856042241: "IFCREVOLVEDAREASOLID",
  3243963512: "IFCREVOLVEDAREASOLIDTAPERED",
  4158566097: "IFCRIGHTCIRCULARCONE",
  3626867408: "IFCRIGHTCIRCULARCYLINDER",
  2016517767: "IFCROOF",
  2781568857: "IFCROOFTYPE",
  2341007311: "IFCROOT",
  2778083089: "IFCROUNDEDRECTANGLEPROFILEDEF",
  448429030: "IFCSIUNIT",
  3053780830: "IFCSANITARYTERMINAL",
  1768891740: "IFCSANITARYTERMINALTYPE",
  1054537805: "IFCSCHEDULINGTIME",
  2157484638: "IFCSEAMCURVE",
  2042790032: "IFCSECTIONPROPERTIES",
  4165799628: "IFCSECTIONREINFORCEMENTPROPERTIES",
  1862484736: "IFCSECTIONEDSOLID",
  1290935644: "IFCSECTIONEDSOLIDHORIZONTAL",
  1509187699: "IFCSECTIONEDSPINE",
  4086658281: "IFCSENSOR",
  1783015770: "IFCSENSORTYPE",
  1329646415: "IFCSHADINGDEVICE",
  4074543187: "IFCSHADINGDEVICETYPE",
  867548509: "IFCSHAPEASPECT",
  3982875396: "IFCSHAPEMODEL",
  4240577450: "IFCSHAPEREPRESENTATION",
  4124623270: "IFCSHELLBASEDSURFACEMODEL",
  3692461612: "IFCSIMPLEPROPERTY",
  3663146110: "IFCSIMPLEPROPERTYTEMPLATE",
  4097777520: "IFCSITE",
  1529196076: "IFCSLAB",
  3127900445: "IFCSLABELEMENTEDCASE",
  3027962421: "IFCSLABSTANDARDCASE",
  2533589738: "IFCSLABTYPE",
  2609359061: "IFCSLIPPAGECONNECTIONCONDITION",
  3420628829: "IFCSOLARDEVICE",
  1072016465: "IFCSOLARDEVICETYPE",
  723233188: "IFCSOLIDMODEL",
  3856911033: "IFCSPACE",
  1999602285: "IFCSPACEHEATER",
  1305183839: "IFCSPACEHEATERTYPE",
  3812236995: "IFCSPACETYPE",
  1412071761: "IFCSPATIALELEMENT",
  710998568: "IFCSPATIALELEMENTTYPE",
  2706606064: "IFCSPATIALSTRUCTUREELEMENT",
  3893378262: "IFCSPATIALSTRUCTUREELEMENTTYPE",
  463610769: "IFCSPATIALZONE",
  2481509218: "IFCSPATIALZONETYPE",
  451544542: "IFCSPHERE",
  4015995234: "IFCSPHERICALSURFACE",
  1404847402: "IFCSTACKTERMINAL",
  3112655638: "IFCSTACKTERMINALTYPE",
  331165859: "IFCSTAIR",
  4252922144: "IFCSTAIRFLIGHT",
  1039846685: "IFCSTAIRFLIGHTTYPE",
  338393293: "IFCSTAIRTYPE",
  682877961: "IFCSTRUCTURALACTION",
  3544373492: "IFCSTRUCTURALACTIVITY",
  2515109513: "IFCSTRUCTURALANALYSISMODEL",
  1179482911: "IFCSTRUCTURALCONNECTION",
  2273995522: "IFCSTRUCTURALCONNECTIONCONDITION",
  1004757350: "IFCSTRUCTURALCURVEACTION",
  4243806635: "IFCSTRUCTURALCURVECONNECTION",
  214636428: "IFCSTRUCTURALCURVEMEMBER",
  2445595289: "IFCSTRUCTURALCURVEMEMBERVARYING",
  2757150158: "IFCSTRUCTURALCURVEREACTION",
  3136571912: "IFCSTRUCTURALITEM",
  1807405624: "IFCSTRUCTURALLINEARACTION",
  2162789131: "IFCSTRUCTURALLOAD",
  385403989: "IFCSTRUCTURALLOADCASE",
  3478079324: "IFCSTRUCTURALLOADCONFIGURATION",
  1252848954: "IFCSTRUCTURALLOADGROUP",
  1595516126: "IFCSTRUCTURALLOADLINEARFORCE",
  609421318: "IFCSTRUCTURALLOADORRESULT",
  2668620305: "IFCSTRUCTURALLOADPLANARFORCE",
  2473145415: "IFCSTRUCTURALLOADSINGLEDISPLACEMENT",
  1973038258: "IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",
  1597423693: "IFCSTRUCTURALLOADSINGLEFORCE",
  1190533807: "IFCSTRUCTURALLOADSINGLEFORCEWARPING",
  2525727697: "IFCSTRUCTURALLOADSTATIC",
  3408363356: "IFCSTRUCTURALLOADTEMPERATURE",
  530289379: "IFCSTRUCTURALMEMBER",
  1621171031: "IFCSTRUCTURALPLANARACTION",
  2082059205: "IFCSTRUCTURALPOINTACTION",
  734778138: "IFCSTRUCTURALPOINTCONNECTION",
  1235345126: "IFCSTRUCTURALPOINTREACTION",
  3689010777: "IFCSTRUCTURALREACTION",
  2986769608: "IFCSTRUCTURALRESULTGROUP",
  3657597509: "IFCSTRUCTURALSURFACEACTION",
  1975003073: "IFCSTRUCTURALSURFACECONNECTION",
  3979015343: "IFCSTRUCTURALSURFACEMEMBER",
  2218152070: "IFCSTRUCTURALSURFACEMEMBERVARYING",
  603775116: "IFCSTRUCTURALSURFACEREACTION",
  2830218821: "IFCSTYLEMODEL",
  3958052878: "IFCSTYLEDITEM",
  3049322572: "IFCSTYLEDREPRESENTATION",
  148013059: "IFCSUBCONTRACTRESOURCE",
  4095615324: "IFCSUBCONTRACTRESOURCETYPE",
  2233826070: "IFCSUBEDGE",
  2513912981: "IFCSURFACE",
  699246055: "IFCSURFACECURVE",
  2028607225: "IFCSURFACECURVESWEPTAREASOLID",
  3101698114: "IFCSURFACEFEATURE",
  2809605785: "IFCSURFACEOFLINEAREXTRUSION",
  4124788165: "IFCSURFACEOFREVOLUTION",
  2934153892: "IFCSURFACEREINFORCEMENTAREA",
  1300840506: "IFCSURFACESTYLE",
  3303107099: "IFCSURFACESTYLELIGHTING",
  1607154358: "IFCSURFACESTYLEREFRACTION",
  1878645084: "IFCSURFACESTYLERENDERING",
  846575682: "IFCSURFACESTYLESHADING",
  1351298697: "IFCSURFACESTYLEWITHTEXTURES",
  626085974: "IFCSURFACETEXTURE",
  2247615214: "IFCSWEPTAREASOLID",
  1260650574: "IFCSWEPTDISKSOLID",
  1096409881: "IFCSWEPTDISKSOLIDPOLYGONAL",
  230924584: "IFCSWEPTSURFACE",
  1162798199: "IFCSWITCHINGDEVICE",
  2315554128: "IFCSWITCHINGDEVICETYPE",
  2254336722: "IFCSYSTEM",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  1580310250: "IFCSYSTEMFURNITUREELEMENTTYPE",
  3071757647: "IFCTSHAPEPROFILEDEF",
  985171141: "IFCTABLE",
  2043862942: "IFCTABLECOLUMN",
  531007025: "IFCTABLEROW",
  812556717: "IFCTANK",
  5716631: "IFCTANKTYPE",
  3473067441: "IFCTASK",
  1549132990: "IFCTASKTIME",
  2771591690: "IFCTASKTIMERECURRING",
  3206491090: "IFCTASKTYPE",
  912023232: "IFCTELECOMADDRESS",
  3824725483: "IFCTENDON",
  2347447852: "IFCTENDONANCHOR",
  3081323446: "IFCTENDONANCHORTYPE",
  3663046924: "IFCTENDONCONDUIT",
  2281632017: "IFCTENDONCONDUITTYPE",
  2415094496: "IFCTENDONTYPE",
  2387106220: "IFCTESSELLATEDFACESET",
  901063453: "IFCTESSELLATEDITEM",
  4282788508: "IFCTEXTLITERAL",
  3124975700: "IFCTEXTLITERALWITHEXTENT",
  1447204868: "IFCTEXTSTYLE",
  1983826977: "IFCTEXTSTYLEFONTMODEL",
  2636378356: "IFCTEXTSTYLEFORDEFINEDFONT",
  1640371178: "IFCTEXTSTYLETEXTMODEL",
  280115917: "IFCTEXTURECOORDINATE",
  1742049831: "IFCTEXTURECOORDINATEGENERATOR",
  2552916305: "IFCTEXTUREMAP",
  1210645708: "IFCTEXTUREVERTEX",
  3611470254: "IFCTEXTUREVERTEXLIST",
  1199560280: "IFCTIMEPERIOD",
  3101149627: "IFCTIMESERIES",
  581633288: "IFCTIMESERIESVALUE",
  1377556343: "IFCTOPOLOGICALREPRESENTATIONITEM",
  1735638870: "IFCTOPOLOGYREPRESENTATION",
  1935646853: "IFCTOROIDALSURFACE",
  3825984169: "IFCTRANSFORMER",
  1692211062: "IFCTRANSFORMERTYPE",
  2595432518: "IFCTRANSITIONCURVESEGMENT2D",
  1620046519: "IFCTRANSPORTELEMENT",
  2097647324: "IFCTRANSPORTELEMENTTYPE",
  2715220739: "IFCTRAPEZIUMPROFILEDEF",
  2916149573: "IFCTRIANGULATEDFACESET",
  1229763772: "IFCTRIANGULATEDIRREGULARNETWORK",
  3593883385: "IFCTRIMMEDCURVE",
  3026737570: "IFCTUBEBUNDLE",
  1600972822: "IFCTUBEBUNDLETYPE",
  1628702193: "IFCTYPEOBJECT",
  3736923433: "IFCTYPEPROCESS",
  2347495698: "IFCTYPEPRODUCT",
  3698973494: "IFCTYPERESOURCE",
  427810014: "IFCUSHAPEPROFILEDEF",
  180925521: "IFCUNITASSIGNMENT",
  630975310: "IFCUNITARYCONTROLELEMENT",
  3179687236: "IFCUNITARYCONTROLELEMENTTYPE",
  4292641817: "IFCUNITARYEQUIPMENT",
  1911125066: "IFCUNITARYEQUIPMENTTYPE",
  4207607924: "IFCVALVE",
  728799441: "IFCVALVETYPE",
  1417489154: "IFCVECTOR",
  2799835756: "IFCVERTEX",
  2759199220: "IFCVERTEXLOOP",
  1907098498: "IFCVERTEXPOINT",
  1530820697: "IFCVIBRATIONDAMPER",
  3956297820: "IFCVIBRATIONDAMPERTYPE",
  2391383451: "IFCVIBRATIONISOLATOR",
  3313531582: "IFCVIBRATIONISOLATORTYPE",
  2769231204: "IFCVIRTUALELEMENT",
  891718957: "IFCVIRTUALGRIDINTERSECTION",
  926996030: "IFCVOIDINGFEATURE",
  2391406946: "IFCWALL",
  4156078855: "IFCWALLELEMENTEDCASE",
  3512223829: "IFCWALLSTANDARDCASE",
  1898987631: "IFCWALLTYPE",
  4237592921: "IFCWASTETERMINAL",
  1133259667: "IFCWASTETERMINALTYPE",
  3304561284: "IFCWINDOW",
  336235671: "IFCWINDOWLININGPROPERTIES",
  512836454: "IFCWINDOWPANELPROPERTIES",
  486154966: "IFCWINDOWSTANDARDCASE",
  1299126871: "IFCWINDOWSTYLE",
  4009809668: "IFCWINDOWTYPE",
  4088093105: "IFCWORKCALENDAR",
  1028945134: "IFCWORKCONTROL",
  4218914973: "IFCWORKPLAN",
  3342526732: "IFCWORKSCHEDULE",
  1236880293: "IFCWORKTIME",
  2543172580: "IFCZSHAPEPROFILEDEF",
  1033361043: "IFCZONE"
};

// dist/helpers/properties.ts
var PropsNames$1 = {
  aggregates: {
    name: IFCRELAGGREGATES,
    relating: "RelatingObject",
    related: "RelatedObjects",
    key: "children"
  },
  spatial: {
    name: IFCRELCONTAINEDINSPATIALSTRUCTURE,
    relating: "RelatingStructure",
    related: "RelatedElements",
    key: "children"
  },
  psets: {
    name: IFCRELDEFINESBYPROPERTIES,
    relating: "RelatingPropertyDefinition",
    related: "RelatedObjects",
    key: "hasPsets"
  },
  materials: {
    name: IFCRELASSOCIATESMATERIAL,
    relating: "RelatingMaterial",
    related: "RelatedObjects",
    key: "hasMaterial"
  },
  type: {
    name: IFCRELDEFINESBYTYPE,
    relating: "RelatingType",
    related: "RelatedObjects",
    key: "hasType"
  }
};
var Properties = class {
  constructor(api) {
    this.api = api;
  }
  getIfcType(type) {
    return IfcTypesMap$1[type];
  }
  getItemProperties(modelID, id, recursive = false) {
    return __async(this, null, function* () {
      return this.api.GetLine(modelID, id, recursive);
    });
  }
  getPropertySets(modelID, elementID, recursive = false) {
    return __async(this, null, function* () {
      return yield this.getProperty(modelID, elementID, recursive, PropsNames$1.psets);
    });
  }
  getTypeProperties(modelID, elementID, recursive = false) {
    return __async(this, null, function* () {
      return yield this.getProperty(modelID, elementID, recursive, PropsNames$1.type);
    });
  }
  getMaterialsProperties(modelID, elementID, recursive = false) {
    return __async(this, null, function* () {
      return yield this.getProperty(modelID, elementID, recursive, PropsNames$1.materials);
    });
  }
  getSpatialStructure(modelID, includeProperties) {
    return __async(this, null, function* () {
      yield this.getAllTypesOfModel(modelID);
      const chunks = yield this.getSpatialTreeChunks(modelID);
      const allLines = yield this.api.GetLineIDsWithType(modelID, IFCPROJECT);
      const projectID = allLines.get(0);
      const project = Properties.newIfcProject(projectID);
      yield this.getSpatialNode(modelID, project, chunks, includeProperties);
      this.cleanupTypes();
      return project;
    });
  }
  getAllItemsOfType(modelID, type, verbose) {
    return __async(this, null, function* () {
      let items = [];
      const lines = yield this.api.GetLineIDsWithType(modelID, type);
      for (let i = 0; i < lines.size(); i++)
        items.push(lines.get(i));
      if (!verbose)
        return items;
      const result = [];
      for (let i = 0; i < items.length; i++) {
        result.push(yield this.api.GetLine(modelID, items[i]));
      }
      return result;
    });
  }
  getProperty(modelID, elementID, recursive = false, propName) {
    return __async(this, null, function* () {
      const propSetIds = yield this.getAllRelatedItemsOfType(modelID, elementID, propName);
      const result = [];
      for (let i = 0; i < propSetIds.length; i++) {
        result.push(yield this.api.GetLine(modelID, propSetIds[i], recursive));
      }
      return result;
    });
  }
  getChunks(modelID, chunks, propNames) {
    return __async(this, null, function* () {
      const relation = yield this.api.GetLineIDsWithType(modelID, propNames.name);
      for (let i = 0; i < relation.size(); i++) {
        const rel = yield this.api.GetLine(modelID, relation.get(i), false);
        this.saveChunk(chunks, propNames, rel);
      }
    });
  }
  static isRelated(id, rel, propNames) {
    const relatedItems = rel[propNames.related];
    if (Array.isArray(relatedItems)) {
      const values = relatedItems.map((item) => item.value);
      return values.includes(id);
    }
    return relatedItems.value === id;
  }
  static newIfcProject(id) {
    return {
      expressID: id,
      type: "IFCPROJECT",
      children: []
    };
  }
  getSpatialNode(modelID, node, treeChunks, includeProperties) {
    return __async(this, null, function* () {
      yield this.getChildren(modelID, node, treeChunks, PropsNames$1.aggregates, includeProperties);
      yield this.getChildren(modelID, node, treeChunks, PropsNames$1.spatial, includeProperties);
    });
  }
  getChildren(modelID, node, treeChunks, propNames, includeProperties) {
    return __async(this, null, function* () {
      const children = treeChunks[node.expressID];
      if (children == void 0)
        return;
      const prop = propNames.key;
      const nodes = [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        let node2 = this.newNode(child);
        if (includeProperties) {
          const properties = yield this.getItemProperties(modelID, node2.expressID);
          node2 = __spreadValues(__spreadValues({}, properties), node2);
        }
        yield this.getSpatialNode(modelID, node2, treeChunks, includeProperties);
        nodes.push(node2);
      }
      node[prop] = nodes;
    });
  }
  newNode(id) {
    const typeName = this.getNodeType(id);
    return {
      expressID: id,
      type: typeName,
      children: []
    };
  }
  getNodeType(id) {
    const typeID = this.types[id];
    return IfcElements2[typeID];
  }
  getSpatialTreeChunks(modelID) {
    return __async(this, null, function* () {
      const treeChunks = {};
      yield this.getChunks(modelID, treeChunks, PropsNames$1.aggregates);
      yield this.getChunks(modelID, treeChunks, PropsNames$1.spatial);
      return treeChunks;
    });
  }
  saveChunk(chunks, propNames, rel) {
    const relating = rel[propNames.relating].value;
    const related = rel[propNames.related].map((r) => r.value);
    if (chunks[relating] == void 0) {
      chunks[relating] = related;
    } else {
      chunks[relating] = chunks[relating].concat(related);
    }
  }
  getRelated(rel, propNames, IDs) {
    const element = rel[propNames.relating];
    if (!Array.isArray(element))
      IDs.push(element.value);
    else
      element.forEach((ele) => IDs.push(ele.value));
  }
  getAllRelatedItemsOfType(modelID, id, propNames) {
    return __async(this, null, function* () {
      const lines = yield this.api.GetLineIDsWithType(modelID, propNames.name);
      const IDs = [];
      for (let i = 0; i < lines.size(); i++) {
        const rel = yield this.api.GetLine(modelID, lines.get(i));
        const isRelated = Properties.isRelated(id, rel, propNames);
        if (isRelated)
          this.getRelated(rel, propNames, IDs);
      }
      return IDs;
    });
  }
  cleanupTypes() {
    this.types = {};
  }
  getAllTypesOfModel(modelID) {
    return __async(this, null, function* () {
      const result = {};
      const elements = Object.keys(IfcElements2).map((e) => parseInt(e));
      for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        const lines = yield this.api.GetLineIDsWithType(modelID, element);
        const size = lines.size();
        for (let i2 = 0; i2 < size; i2++)
          result[lines.get(i2)] = element;
      }
      this.types = result;
    });
  }
};

// dist/web-ifc-api.ts
var WebIFCWasm;
if (typeof self !== "undefined" && self.crossOriginIsolated) {
  WebIFCWasm = require_web_ifc_mt();
} else {
  WebIFCWasm = require_web_ifc();
}
var IfcAPI2 = class {
  constructor() {
    this.wasmModule = void 0;
    this.fs = void 0;
    this.wasmPath = "";
    this.isWasmPathAbsolute = false;
    this.ifcGuidMap = new Map();
    this.properties = new Properties(this);
  }
  Init(customLocateFileHandler) {
    return __async(this, null, function* () {
      if (WebIFCWasm) {
        let locateFileHandler = (path, prefix) => {
          if (path.endsWith(".wasm")) {
            if (this.isWasmPathAbsolute) {
              return this.wasmPath + path;
            }
            return prefix + this.wasmPath + path;
          }
          return prefix + path;
        };
        this.wasmModule = yield WebIFCWasm({ noInitialRun: true, locateFile: customLocateFileHandler || locateFileHandler });
        this.fs = this.wasmModule.FS;
      } else {
        console.error(`Could not find wasm module at './web-ifc' from web-ifc-api.ts`);
      }
    });
  }
  OpenModel(data, settings) {
    let s = __spreadValues({
      COORDINATE_TO_ORIGIN: false,
      USE_FAST_BOOLS: false,
      CIRCLE_SEGMENTS_LOW: 5,
      CIRCLE_SEGMENTS_MEDIUM: 8,
      CIRCLE_SEGMENTS_HIGH: 12,
      BOOL_ABORT_THRESHOLD: 1e4
    }, settings);
    let offsetInSrc = 0;
    let result = this.wasmModule.OpenModel(s, (destPtr, destSize) => {
      let srcSize = Math.min(data.byteLength - offsetInSrc, destSize);
      let dest = this.wasmModule.HEAPU8.subarray(destPtr, destPtr + destSize);
      let src = data.subarray(offsetInSrc, offsetInSrc + srcSize);
      dest.set(src);
      offsetInSrc += srcSize;
      return srcSize;
    });
    return result;
  }
  CreateModel(settings) {
    let s = __spreadValues({
      COORDINATE_TO_ORIGIN: false,
      USE_FAST_BOOLS: false,
      CIRCLE_SEGMENTS_LOW: 5,
      CIRCLE_SEGMENTS_MEDIUM: 8,
      CIRCLE_SEGMENTS_HIGH: 12,
      BOOL_ABORT_THRESHOLD: 1e4
    }, settings);
    let result = this.wasmModule.CreateModel(s);
    return result;
  }
  ExportFileAsIFC(modelID) {
    this.wasmModule.ExportFileAsIFC(modelID);
    let result = this.fs.readFile("/export.ifc");
    this.wasmModule["FS_unlink"]("/export.ifc");
    return result;
  }
  GetGeometry(modelID, geometryExpressID) {
    return this.wasmModule.GetGeometry(modelID, geometryExpressID);
  }
  GetLine(modelID, expressID, flatten = false) {
    let rawLineData = this.GetRawLineData(modelID, expressID);
    let lineData = FromRawLineData[rawLineData.type](rawLineData);
    if (flatten) {
      this.FlattenLine(modelID, lineData);
    }
    return lineData;
  }
  GetAndClearErrors(modelID) {
    return this.wasmModule.GetAndClearErrors(modelID);
  }
  WriteLine(modelID, lineObject) {
    Object.keys(lineObject).forEach((propertyName) => {
      let property = lineObject[propertyName];
      if (property && property.expressID !== void 0) {
        this.WriteLine(modelID, property);
        lineObject[propertyName] = {
          type: 5,
          value: property.expressID
        };
      } else if (Array.isArray(property) && property.length > 0) {
        for (let i = 0; i < property.length; i++) {
          if (property[i].expressID !== void 0) {
            this.WriteLine(modelID, property[i]);
            lineObject[propertyName][i] = {
              type: 5,
              value: property[i].expressID
            };
          }
        }
      }
    });
    if (lineObject.expressID == void 0 || lineObject.type == void 0 || lineObject.ToType === void 0) {
      console.warn("Line object cannot be serialized: ", lineObject);
      return;
    }
    let rawLineData = {
      ID: lineObject.expressID,
      type: lineObject.type,
      arguments: lineObject.ToTape()
    };
    this.WriteRawLineData(modelID, rawLineData);
  }
  FlattenLine(modelID, line) {
    Object.keys(line).forEach((propertyName) => {
      let property = line[propertyName];
      if (property && property.type === 5) {
        line[propertyName] = this.GetLine(modelID, property.value, true);
      } else if (Array.isArray(property) && property.length > 0 && property[0].type === 5) {
        for (let i = 0; i < property.length; i++) {
          line[propertyName][i] = this.GetLine(modelID, property[i].value, true);
        }
      }
    });
  }
  GetRawLineData(modelID, expressID) {
    return this.wasmModule.GetLine(modelID, expressID);
  }
  WriteRawLineData(modelID, data) {
    return this.wasmModule.WriteLine(modelID, data.ID, data.type, data.arguments);
  }
  GetLineIDsWithType(modelID, type) {
    return this.wasmModule.GetLineIDsWithType(modelID, type);
  }
  GetAllLines(modelID) {
    return this.wasmModule.GetAllLines(modelID);
  }
  SetGeometryTransformation(modelID, transformationMatrix) {
    if (transformationMatrix.length != 16) {
      console.log(`Bad transformation matrix size: ${transformationMatrix.length}`);
      return;
    }
    this.wasmModule.SetGeometryTransformation(modelID, transformationMatrix);
  }
  GetCoordinationMatrix(modelID) {
    return this.wasmModule.GetCoordinationMatrix(modelID);
  }
  GetVertexArray(ptr, size) {
    return this.getSubArray(this.wasmModule.HEAPF32, ptr, size);
  }
  GetIndexArray(ptr, size) {
    return this.getSubArray(this.wasmModule.HEAPU32, ptr, size);
  }
  getSubArray(heap, startPtr, sizeBytes) {
    return heap.subarray(startPtr / 4, startPtr / 4 + sizeBytes).slice(0);
  }
  CloseModel(modelID) {
    this.ifcGuidMap.delete(modelID);
    this.wasmModule.CloseModel(modelID);
  }
  StreamAllMeshes(modelID, meshCallback) {
    this.wasmModule.StreamAllMeshes(modelID, meshCallback);
  }
  StreamAllMeshesWithTypes(modelID, types, meshCallback) {
    this.wasmModule.StreamAllMeshesWithTypes(modelID, types, meshCallback);
  }
  IsModelOpen(modelID) {
    return this.wasmModule.IsModelOpen(modelID);
  }
  LoadAllGeometry(modelID) {
    return this.wasmModule.LoadAllGeometry(modelID);
  }
  GetFlatMesh(modelID, expressID) {
    return this.wasmModule.GetFlatMesh(modelID, expressID);
  }
  CreateIfcGuidToExpressIdMapping(modelID) {
    const map = new Map();
    for (let x = 0; x < IfcElements$1.length; x++) {
      const type = IfcElements$1[x];
      const lines = this.GetLineIDsWithType(modelID, type);
      const size = lines.size();
      for (let y = 0; y < size; y++) {
        const expressID = lines.get(y);
        const info = this.GetLine(modelID, expressID);
        const globalID = info.GlobalId.value;
        map.set(expressID, globalID);
        map.set(globalID, expressID);
      }
    }
    this.ifcGuidMap.set(modelID, map);
  }
  SetWasmPath(path, absolute = false) {
    this.wasmPath = path;
    this.isWasmPathAbsolute = absolute;
  }
};

class WebIfcWorker {
    constructor(worker, serializer) {
        this.worker = worker;
        this.serializer = serializer;
        this.API = WorkerAPIs.webIfc;
        this.webIFC = new IfcAPI2();
        this.worker.initializeAPI(this.webIFC);
    }
    async Init(data) {
        await this.webIFC.Init();
        this.worker.post(data);
    }
    ;
    async Close(data) {
        this.nullifyWebIfc();
        this.webIFC = new IfcAPI2();
        await this.webIFC.Init();
        this.worker.post(data);
    }
    ;
    async DisposeWebIfc(data) {
        this.nullifyWebIfc();
        this.worker.post(data);
    }
    CloseModel(data) {
        this.webIFC.CloseModel(data.args.modelID);
        this.worker.post(data);
    }
    CreateModel(data) {
        data.result = this.webIFC.CreateModel(data.args.settings);
        this.worker.post(data);
    }
    ExportFileAsIFC(data) {
        data.result = this.webIFC.ExportFileAsIFC(data.args.modelID);
        this.worker.post(data);
    }
    FlattenLine(data) {
        this.webIFC.FlattenLine(data.args.modelID, data.args.line);
        this.worker.post(data);
    }
    GetAllLines(data) {
        const vector = this.webIFC.GetAllLines(data.args.modelID);
        data.result = this.serializer.serializeVector(vector);
        this.worker.post(data);
    }
    GetAndClearErrors(data) {
        const vector = this.webIFC.GetAndClearErrors(data.args.modelID);
        data.result = this.serializer.serializeVector(vector);
        this.worker.post(data);
    }
    GetCoordinationMatrix(data) {
        data.result = this.webIFC.GetCoordinationMatrix(data.args.modelID);
        this.worker.post(data);
    }
    GetFlatMesh(data) {
        const flatMesh = this.webIFC.GetFlatMesh(data.args.modelID, data.args.expressID);
        data.result = this.serializer.serializeFlatMesh(flatMesh);
        this.worker.post(data);
    }
    GetGeometry(data) {
        const ifcGeometry = this.webIFC.GetGeometry(data.args.modelID, data.args.geometryExpressID);
        data.result = this.serializer.serializeIfcGeometry(ifcGeometry);
        this.worker.post(data);
    }
    GetIndexArray(data) {
        data.result = this.webIFC.GetIndexArray(data.args.ptr, data.args.size);
        this.worker.post(data);
    }
    GetLine(data) {
        const args = data.args;
        try {
            data.result = this.webIFC.GetLine(args.modelID, args.expressID, args.flatten);
        }
        catch (e) {
            console.log(`There was a problem getting the properties of the item ${args.expressID}`);
            data.result = {};
        }
        this.worker.post(data);
    }
    GetLineIDsWithType(data) {
        const vector = this.webIFC.GetLineIDsWithType(data.args.modelID, data.args.type);
        data.result = this.serializer.serializeVector(vector);
        this.worker.post(data);
    }
    GetRawLineData(data) {
        data.result = this.webIFC.GetRawLineData(data.args.modelID, data.args.expressID);
        this.worker.post(data);
    }
    GetVertexArray(data) {
        data.result = this.webIFC.GetVertexArray(data.args.ptr, data.args.size);
        this.worker.post(data);
    }
    IsModelOpen(data) {
        data.result = this.webIFC.IsModelOpen(data.args.modelID);
        this.worker.post(data);
    }
    LoadAllGeometry(data) {
        const flatMeshVector = this.webIFC.LoadAllGeometry(data.args.modelID);
        data.result = this.serializer.serializeFlatMeshVector(flatMeshVector);
        this.worker.post(data);
    }
    OpenModel(data) {
        data.result = this.webIFC.OpenModel(data.args.data, data.args.settings);
        this.worker.post(data);
    }
    SetGeometryTransformation(data) {
        this.webIFC.SetGeometryTransformation(data.args.modelID, data.args.transformationMatrix);
        this.worker.post(data);
    }
    SetWasmPath(data) {
        this.webIFC.SetWasmPath(data.args.path);
        this.worker.post(data);
    }
    StreamAllMeshes(data) {
        const serializer = this.serializer.serializeFlatMesh;
        const callback = (result) => this.worker.postCallback(data, result, serializer);
        this.webIFC.StreamAllMeshes(data.args.modelID, callback);
    }
    StreamAllMeshesWithTypes(data) {
        const args = data.args;
        const serializer = this.serializer.serializeFlatMesh;
        const callback = (result) => this.worker.postCallback(data, result, serializer);
        this.webIFC.StreamAllMeshesWithTypes(args.modelID, args.types, callback);
    }
    WriteLine(data) {
        const modelID = data.args.modelID;
        const serializedObject = data.args.lineObject;
        const object = this.webIFC.GetLine(modelID, serializedObject.expressID);
        Object.keys(serializedObject).forEach(propName => {
            if (object[propName] !== undefined) {
                object[propName] = serializedObject[propName];
            }
        });
        this.webIFC.WriteLine(data.args.modelID, object);
        this.worker.post(data);
    }
    WriteRawLineData(data) {
        this.webIFC.WriteRawLineData(data.args.modelID, data.args.data);
        this.worker.post(data);
    }
    getSubArray(data) {
        const args = data.args;
        this.webIFC.getSubArray(args.heap, args.startPtr, args.sizeBytes);
        this.worker.post(data);
    }
    nullifyWebIfc() {
        this.webIFC = null;
    }
}

const IdAttrName = 'expressID';
const PropsNames = {
    aggregates: {
        name: IFCRELAGGREGATES,
        relating: 'RelatingObject',
        related: 'RelatedObjects',
        key: 'children'
    },
    spatial: {
        name: IFCRELCONTAINEDINSPATIALSTRUCTURE,
        relating: 'RelatingStructure',
        related: 'RelatedElements',
        key: 'children'
    },
    psets: {
        name: IFCRELDEFINESBYPROPERTIES,
        relating: 'RelatingPropertyDefinition',
        related: 'RelatedObjects',
        key: 'hasPsets'
    },
    materials: {
        name: IFCRELASSOCIATESMATERIAL,
        relating: 'RelatingMaterial',
        related: 'RelatedObjects',
        key: 'hasMaterial'
    },
    type: {
        name: IFCRELDEFINESBYTYPE,
        relating: 'RelatingType',
        related: 'RelatedObjects',
        key: 'hasType'
    }
};

class BasePropertyManager {
    constructor(state) {
        this.state = state;
    }
    async getPropertySets(modelID, elementID, recursive = false) {
        return await this.getProperty(modelID, elementID, recursive, PropsNames.psets);
    }
    async getTypeProperties(modelID, elementID, recursive = false) {
        return await this.getProperty(modelID, elementID, recursive, PropsNames.type);
    }
    async getMaterialsProperties(modelID, elementID, recursive = false) {
        return await this.getProperty(modelID, elementID, recursive, PropsNames.materials);
    }
    async getSpatialNode(modelID, node, treeChunks, includeProperties) {
        await this.getChildren(modelID, node, treeChunks, PropsNames.aggregates, includeProperties);
        await this.getChildren(modelID, node, treeChunks, PropsNames.spatial, includeProperties);
    }
    async getChildren(modelID, node, treeChunks, propNames, includeProperties) {
        const children = treeChunks[node.expressID];
        if (children == undefined)
            return;
        const prop = propNames.key;
        const nodes = [];
        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            let node = this.newNode(modelID, child);
            if (includeProperties) {
                const properties = await this.getItemProperties(modelID, node.expressID);
                node = { ...properties, ...node };
            }
            await this.getSpatialNode(modelID, node, treeChunks, includeProperties);
            nodes.push(node);
        }
        node[prop] = nodes;
    }
    newNode(modelID, id) {
        const typeName = this.getNodeType(modelID, id);
        return {
            expressID: id,
            type: typeName,
            children: []
        };
    }
    async getSpatialTreeChunks(modelID) {
        const treeChunks = {};
        await this.getChunks(modelID, treeChunks, PropsNames.aggregates);
        await this.getChunks(modelID, treeChunks, PropsNames.spatial);
        return treeChunks;
    }
    saveChunk(chunks, propNames, rel) {
        const relating = rel[propNames.relating].value;
        const related = rel[propNames.related].map((r) => r.value);
        if (chunks[relating] == undefined) {
            chunks[relating] = related;
        }
        else {
            chunks[relating] = chunks[relating].concat(related);
        }
    }
    getRelated(rel, propNames, IDs) {
        const element = rel[propNames.relating];
        if (!element) {
            return console.warn(`The object with ID ${rel.expressID} has a broken reference.`);
        }
        if (!Array.isArray(element))
            IDs.push(element.value);
        else
            element.forEach((ele) => IDs.push(ele.value));
    }
    static isRelated(id, rel, propNames) {
        const relatedItems = rel[propNames.related];
        if (Array.isArray(relatedItems)) {
            const values = relatedItems.map((item) => item.value);
            return values.includes(id);
        }
        return relatedItems.value === id;
    }
    static newIfcProject(id) {
        return {
            expressID: id,
            type: 'IFCPROJECT',
            children: []
        };
    }
    async getProperty(modelID, elementID, recursive = false, propName) {
    }
    async getChunks(modelID, chunks, propNames) {
    }
    async getItemProperties(modelID, expressID, recursive = false) {
    }
    getNodeType(modelID, id) {
    }
}

let IfcElements = {
    103090709: 'IFCPROJECT',
    4097777520: 'IFCSITE',
    4031249490: 'IFCBUILDING',
    3124254112: 'IFCBUILDINGSTOREY',
    3856911033: 'IFCSPACE',
    1674181508: 'IFCANNOTATION',
    25142252: 'IFCCONTROLLER',
    32344328: 'IFCBOILER',
    76236018: 'IFCLAMP',
    90941305: 'IFCPUMP',
    177149247: 'IFCAIRTERMINALBOX',
    182646315: 'IFCFLOWINSTRUMENT',
    263784265: 'IFCFURNISHINGELEMENT',
    264262732: 'IFCELECTRICGENERATOR',
    277319702: 'IFCAUDIOVISUALAPPLIANCE',
    310824031: 'IFCPIPEFITTING',
    331165859: 'IFCSTAIR',
    342316401: 'IFCDUCTFITTING',
    377706215: 'IFCMECHANICALFASTENER',
    395920057: 'IFCDOOR',
    402227799: 'IFCELECTRICMOTOR',
    413509423: 'IFCSYSTEMFURNITUREELEMENT',
    484807127: 'IFCEVAPORATOR',
    486154966: 'IFCWINDOWSTANDARDCASE',
    629592764: 'IFCLIGHTFIXTURE',
    630975310: 'IFCUNITARYCONTROLELEMENT',
    635142910: 'IFCCABLECARRIERFITTING',
    639361253: 'IFCCOIL',
    647756555: 'IFCFASTENER',
    707683696: 'IFCFLOWSTORAGEDEVICE',
    738039164: 'IFCPROTECTIVEDEVICE',
    753842376: 'IFCBEAM',
    812556717: 'IFCTANK',
    819412036: 'IFCFILTER',
    843113511: 'IFCCOLUMN',
    862014818: 'IFCELECTRICDISTRIBUTIONBOARD',
    900683007: 'IFCFOOTING',
    905975707: 'IFCCOLUMNSTANDARDCASE',
    926996030: 'IFCVOIDINGFEATURE',
    979691226: 'IFCREINFORCINGBAR',
    987401354: 'IFCFLOWSEGMENT',
    1003880860: 'IFCELECTRICTIMECONTROL',
    1051757585: 'IFCCABLEFITTING',
    1052013943: 'IFCDISTRIBUTIONCHAMBERELEMENT',
    1062813311: 'IFCDISTRIBUTIONCONTROLELEMENT',
    1073191201: 'IFCMEMBER',
    1095909175: 'IFCBUILDINGELEMENTPROXY',
    1156407060: 'IFCPLATESTANDARDCASE',
    1162798199: 'IFCSWITCHINGDEVICE',
    1329646415: 'IFCSHADINGDEVICE',
    1335981549: 'IFCDISCRETEACCESSORY',
    1360408905: 'IFCDUCTSILENCER',
    1404847402: 'IFCSTACKTERMINAL',
    1426591983: 'IFCFIRESUPPRESSIONTERMINAL',
    1437502449: 'IFCMEDICALDEVICE',
    1509553395: 'IFCFURNITURE',
    1529196076: 'IFCSLAB',
    1620046519: 'IFCTRANSPORTELEMENT',
    1634111441: 'IFCAIRTERMINAL',
    1658829314: 'IFCENERGYCONVERSIONDEVICE',
    1677625105: 'IFCCIVILELEMENT',
    1687234759: 'IFCPILE',
    1904799276: 'IFCELECTRICAPPLIANCE',
    1911478936: 'IFCMEMBERSTANDARDCASE',
    1945004755: 'IFCDISTRIBUTIONELEMENT',
    1973544240: 'IFCCOVERING',
    1999602285: 'IFCSPACEHEATER',
    2016517767: 'IFCROOF',
    2056796094: 'IFCAIRTOAIRHEATRECOVERY',
    2058353004: 'IFCFLOWCONTROLLER',
    2068733104: 'IFCHUMIDIFIER',
    2176052936: 'IFCJUNCTIONBOX',
    2188021234: 'IFCFLOWMETER',
    2223149337: 'IFCFLOWTERMINAL',
    2262370178: 'IFCRAILING',
    2272882330: 'IFCCONDENSER',
    2295281155: 'IFCPROTECTIVEDEVICETRIPPINGUNIT',
    2320036040: 'IFCREINFORCINGMESH',
    2347447852: 'IFCTENDONANCHOR',
    2391383451: 'IFCVIBRATIONISOLATOR',
    2391406946: 'IFCWALL',
    2474470126: 'IFCMOTORCONNECTION',
    2769231204: 'IFCVIRTUALELEMENT',
    2814081492: 'IFCENGINE',
    2906023776: 'IFCBEAMSTANDARDCASE',
    2938176219: 'IFCBURNER',
    2979338954: 'IFCBUILDINGELEMENTPART',
    3024970846: 'IFCRAMP',
    3026737570: 'IFCTUBEBUNDLE',
    3027962421: 'IFCSLABSTANDARDCASE',
    3040386961: 'IFCDISTRIBUTIONFLOWELEMENT',
    3053780830: 'IFCSANITARYTERMINAL',
    3079942009: 'IFCOPENINGSTANDARDCASE',
    3087945054: 'IFCALARM',
    3101698114: 'IFCSURFACEFEATURE',
    3127900445: 'IFCSLABELEMENTEDCASE',
    3132237377: 'IFCFLOWMOVINGDEVICE',
    3171933400: 'IFCPLATE',
    3221913625: 'IFCCOMMUNICATIONSAPPLIANCE',
    3242481149: 'IFCDOORSTANDARDCASE',
    3283111854: 'IFCRAMPFLIGHT',
    3296154744: 'IFCCHIMNEY',
    3304561284: 'IFCWINDOW',
    3310460725: 'IFCELECTRICFLOWSTORAGEDEVICE',
    3319311131: 'IFCHEATEXCHANGER',
    3415622556: 'IFCFAN',
    3420628829: 'IFCSOLARDEVICE',
    3493046030: 'IFCGEOGRAPHICELEMENT',
    3495092785: 'IFCCURTAINWALL',
    3508470533: 'IFCFLOWTREATMENTDEVICE',
    3512223829: 'IFCWALLSTANDARDCASE',
    3518393246: 'IFCDUCTSEGMENT',
    3571504051: 'IFCCOMPRESSOR',
    3588315303: 'IFCOPENINGELEMENT',
    3612865200: 'IFCPIPESEGMENT',
    3640358203: 'IFCCOOLINGTOWER',
    3651124850: 'IFCPROJECTIONELEMENT',
    3694346114: 'IFCOUTLET',
    3747195512: 'IFCEVAPORATIVECOOLER',
    3758799889: 'IFCCABLECARRIERSEGMENT',
    3824725483: 'IFCTENDON',
    3825984169: 'IFCTRANSFORMER',
    3902619387: 'IFCCHILLER',
    4074379575: 'IFCDAMPER',
    4086658281: 'IFCSENSOR',
    4123344466: 'IFCELEMENTASSEMBLY',
    4136498852: 'IFCCOOLEDBEAM',
    4156078855: 'IFCWALLELEMENTEDCASE',
    4175244083: 'IFCINTERCEPTOR',
    4207607924: 'IFCVALVE',
    4217484030: 'IFCCABLESEGMENT',
    4237592921: 'IFCWASTETERMINAL',
    4252922144: 'IFCSTAIRFLIGHT',
    4278956645: 'IFCFLOWFITTING',
    4288193352: 'IFCACTUATOR',
    4292641817: 'IFCUNITARYEQUIPMENT',
    3009204131: 'IFCGRID'
};

class WebIfcPropertyManager extends BasePropertyManager {
    async getItemProperties(modelID, id, recursive = false) {
        return this.state.api.GetLine(modelID, id, recursive);
    }
    async getSpatialStructure(modelID, includeProperties) {
        const chunks = await this.getSpatialTreeChunks(modelID);
        const allLines = await this.state.api.GetLineIDsWithType(modelID, IFCPROJECT);
        const projectID = allLines.get(0);
        const project = WebIfcPropertyManager.newIfcProject(projectID);
        await this.getSpatialNode(modelID, project, chunks, includeProperties);
        return project;
    }
    async getAllItemsOfType(modelID, type, verbose) {
        let items = [];
        const lines = await this.state.api.GetLineIDsWithType(modelID, type);
        for (let i = 0; i < lines.size(); i++)
            items.push(lines.get(i));
        if (!verbose)
            return items;
        const result = [];
        for (let i = 0; i < items.length; i++) {
            result.push(await this.state.api.GetLine(modelID, items[i]));
        }
        return result;
    }
    async getProperty(modelID, elementID, recursive = false, propName) {
        const propSetIds = await this.getAllRelatedItemsOfType(modelID, elementID, propName);
        const result = [];
        for (let i = 0; i < propSetIds.length; i++) {
            result.push(await this.state.api.GetLine(modelID, propSetIds[i], recursive));
        }
        return result;
    }
    getNodeType(modelID, id) {
        const typeID = this.state.models[modelID].types[id];
        return IfcElements[typeID];
    }
    async getChunks(modelID, chunks, propNames) {
        const relation = await this.state.api.GetLineIDsWithType(modelID, propNames.name);
        for (let i = 0; i < relation.size(); i++) {
            const rel = await this.state.api.GetLine(modelID, relation.get(i), false);
            this.saveChunk(chunks, propNames, rel);
        }
    }
    async getAllRelatedItemsOfType(modelID, id, propNames) {
        const lines = await this.state.api.GetLineIDsWithType(modelID, propNames.name);
        const IDs = [];
        for (let i = 0; i < lines.size(); i++) {
            const rel = await this.state.api.GetLine(modelID, lines.get(i));
            const isRelated = BasePropertyManager.isRelated(id, rel, propNames);
            if (isRelated)
                this.getRelated(rel, propNames, IDs);
        }
        return IDs;
    }
}

let IfcTypesMap = {
    3821786052: "IFCACTIONREQUEST",
    2296667514: "IFCACTOR",
    3630933823: "IFCACTORROLE",
    4288193352: "IFCACTUATOR",
    2874132201: "IFCACTUATORTYPE",
    618182010: "IFCADDRESS",
    1635779807: "IFCADVANCEDBREP",
    2603310189: "IFCADVANCEDBREPWITHVOIDS",
    3406155212: "IFCADVANCEDFACE",
    1634111441: "IFCAIRTERMINAL",
    177149247: "IFCAIRTERMINALBOX",
    1411407467: "IFCAIRTERMINALBOXTYPE",
    3352864051: "IFCAIRTERMINALTYPE",
    2056796094: "IFCAIRTOAIRHEATRECOVERY",
    1871374353: "IFCAIRTOAIRHEATRECOVERYTYPE",
    3087945054: "IFCALARM",
    3001207471: "IFCALARMTYPE",
    325726236: "IFCALIGNMENT",
    749761778: "IFCALIGNMENT2DHORIZONTAL",
    3199563722: "IFCALIGNMENT2DHORIZONTALSEGMENT",
    2483840362: "IFCALIGNMENT2DSEGMENT",
    3379348081: "IFCALIGNMENT2DVERSEGCIRCULARARC",
    3239324667: "IFCALIGNMENT2DVERSEGLINE",
    4263986512: "IFCALIGNMENT2DVERSEGPARABOLICARC",
    53199957: "IFCALIGNMENT2DVERTICAL",
    2029264950: "IFCALIGNMENT2DVERTICALSEGMENT",
    3512275521: "IFCALIGNMENTCURVE",
    1674181508: "IFCANNOTATION",
    669184980: "IFCANNOTATIONFILLAREA",
    639542469: "IFCAPPLICATION",
    411424972: "IFCAPPLIEDVALUE",
    130549933: "IFCAPPROVAL",
    3869604511: "IFCAPPROVALRELATIONSHIP",
    3798115385: "IFCARBITRARYCLOSEDPROFILEDEF",
    1310608509: "IFCARBITRARYOPENPROFILEDEF",
    2705031697: "IFCARBITRARYPROFILEDEFWITHVOIDS",
    3460190687: "IFCASSET",
    3207858831: "IFCASYMMETRICISHAPEPROFILEDEF",
    277319702: "IFCAUDIOVISUALAPPLIANCE",
    1532957894: "IFCAUDIOVISUALAPPLIANCETYPE",
    4261334040: "IFCAXIS1PLACEMENT",
    3125803723: "IFCAXIS2PLACEMENT2D",
    2740243338: "IFCAXIS2PLACEMENT3D",
    1967976161: "IFCBSPLINECURVE",
    2461110595: "IFCBSPLINECURVEWITHKNOTS",
    2887950389: "IFCBSPLINESURFACE",
    167062518: "IFCBSPLINESURFACEWITHKNOTS",
    753842376: "IFCBEAM",
    2906023776: "IFCBEAMSTANDARDCASE",
    819618141: "IFCBEAMTYPE",
    4196446775: "IFCBEARING",
    3649138523: "IFCBEARINGTYPE",
    616511568: "IFCBLOBTEXTURE",
    1334484129: "IFCBLOCK",
    32344328: "IFCBOILER",
    231477066: "IFCBOILERTYPE",
    3649129432: "IFCBOOLEANCLIPPINGRESULT",
    2736907675: "IFCBOOLEANRESULT",
    4037036970: "IFCBOUNDARYCONDITION",
    1136057603: "IFCBOUNDARYCURVE",
    1560379544: "IFCBOUNDARYEDGECONDITION",
    3367102660: "IFCBOUNDARYFACECONDITION",
    1387855156: "IFCBOUNDARYNODECONDITION",
    2069777674: "IFCBOUNDARYNODECONDITIONWARPING",
    1260505505: "IFCBOUNDEDCURVE",
    4182860854: "IFCBOUNDEDSURFACE",
    2581212453: "IFCBOUNDINGBOX",
    2713105998: "IFCBOXEDHALFSPACE",
    644574406: "IFCBRIDGE",
    963979645: "IFCBRIDGEPART",
    4031249490: "IFCBUILDING",
    3299480353: "IFCBUILDINGELEMENT",
    2979338954: "IFCBUILDINGELEMENTPART",
    39481116: "IFCBUILDINGELEMENTPARTTYPE",
    1095909175: "IFCBUILDINGELEMENTPROXY",
    1909888760: "IFCBUILDINGELEMENTPROXYTYPE",
    1950629157: "IFCBUILDINGELEMENTTYPE",
    3124254112: "IFCBUILDINGSTOREY",
    1177604601: "IFCBUILDINGSYSTEM",
    2938176219: "IFCBURNER",
    2188180465: "IFCBURNERTYPE",
    2898889636: "IFCCSHAPEPROFILEDEF",
    635142910: "IFCCABLECARRIERFITTING",
    395041908: "IFCCABLECARRIERFITTINGTYPE",
    3758799889: "IFCCABLECARRIERSEGMENT",
    3293546465: "IFCCABLECARRIERSEGMENTTYPE",
    1051757585: "IFCCABLEFITTING",
    2674252688: "IFCCABLEFITTINGTYPE",
    4217484030: "IFCCABLESEGMENT",
    1285652485: "IFCCABLESEGMENTTYPE",
    3999819293: "IFCCAISSONFOUNDATION",
    3203706013: "IFCCAISSONFOUNDATIONTYPE",
    1123145078: "IFCCARTESIANPOINT",
    574549367: "IFCCARTESIANPOINTLIST",
    1675464909: "IFCCARTESIANPOINTLIST2D",
    2059837836: "IFCCARTESIANPOINTLIST3D",
    59481748: "IFCCARTESIANTRANSFORMATIONOPERATOR",
    3749851601: "IFCCARTESIANTRANSFORMATIONOPERATOR2D",
    3486308946: "IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",
    3331915920: "IFCCARTESIANTRANSFORMATIONOPERATOR3D",
    1416205885: "IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",
    3150382593: "IFCCENTERLINEPROFILEDEF",
    3902619387: "IFCCHILLER",
    2951183804: "IFCCHILLERTYPE",
    3296154744: "IFCCHIMNEY",
    2197970202: "IFCCHIMNEYTYPE",
    2611217952: "IFCCIRCLE",
    2937912522: "IFCCIRCLEHOLLOWPROFILEDEF",
    1383045692: "IFCCIRCLEPROFILEDEF",
    1062206242: "IFCCIRCULARARCSEGMENT2D",
    1677625105: "IFCCIVILELEMENT",
    3893394355: "IFCCIVILELEMENTTYPE",
    747523909: "IFCCLASSIFICATION",
    647927063: "IFCCLASSIFICATIONREFERENCE",
    2205249479: "IFCCLOSEDSHELL",
    639361253: "IFCCOIL",
    2301859152: "IFCCOILTYPE",
    776857604: "IFCCOLOURRGB",
    3285139300: "IFCCOLOURRGBLIST",
    3264961684: "IFCCOLOURSPECIFICATION",
    843113511: "IFCCOLUMN",
    905975707: "IFCCOLUMNSTANDARDCASE",
    300633059: "IFCCOLUMNTYPE",
    3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
    400855858: "IFCCOMMUNICATIONSAPPLIANCETYPE",
    2542286263: "IFCCOMPLEXPROPERTY",
    3875453745: "IFCCOMPLEXPROPERTYTEMPLATE",
    3732776249: "IFCCOMPOSITECURVE",
    15328376: "IFCCOMPOSITECURVEONSURFACE",
    2485617015: "IFCCOMPOSITECURVESEGMENT",
    1485152156: "IFCCOMPOSITEPROFILEDEF",
    3571504051: "IFCCOMPRESSOR",
    3850581409: "IFCCOMPRESSORTYPE",
    2272882330: "IFCCONDENSER",
    2816379211: "IFCCONDENSERTYPE",
    2510884976: "IFCCONIC",
    370225590: "IFCCONNECTEDFACESET",
    1981873012: "IFCCONNECTIONCURVEGEOMETRY",
    2859738748: "IFCCONNECTIONGEOMETRY",
    45288368: "IFCCONNECTIONPOINTECCENTRICITY",
    2614616156: "IFCCONNECTIONPOINTGEOMETRY",
    2732653382: "IFCCONNECTIONSURFACEGEOMETRY",
    775493141: "IFCCONNECTIONVOLUMEGEOMETRY",
    1959218052: "IFCCONSTRAINT",
    3898045240: "IFCCONSTRUCTIONEQUIPMENTRESOURCE",
    2185764099: "IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",
    1060000209: "IFCCONSTRUCTIONMATERIALRESOURCE",
    4105962743: "IFCCONSTRUCTIONMATERIALRESOURCETYPE",
    488727124: "IFCCONSTRUCTIONPRODUCTRESOURCE",
    1525564444: "IFCCONSTRUCTIONPRODUCTRESOURCETYPE",
    2559216714: "IFCCONSTRUCTIONRESOURCE",
    2574617495: "IFCCONSTRUCTIONRESOURCETYPE",
    3419103109: "IFCCONTEXT",
    3050246964: "IFCCONTEXTDEPENDENTUNIT",
    3293443760: "IFCCONTROL",
    25142252: "IFCCONTROLLER",
    578613899: "IFCCONTROLLERTYPE",
    2889183280: "IFCCONVERSIONBASEDUNIT",
    2713554722: "IFCCONVERSIONBASEDUNITWITHOFFSET",
    4136498852: "IFCCOOLEDBEAM",
    335055490: "IFCCOOLEDBEAMTYPE",
    3640358203: "IFCCOOLINGTOWER",
    2954562838: "IFCCOOLINGTOWERTYPE",
    1785450214: "IFCCOORDINATEOPERATION",
    1466758467: "IFCCOORDINATEREFERENCESYSTEM",
    3895139033: "IFCCOSTITEM",
    1419761937: "IFCCOSTSCHEDULE",
    602808272: "IFCCOSTVALUE",
    1973544240: "IFCCOVERING",
    1916426348: "IFCCOVERINGTYPE",
    3295246426: "IFCCREWRESOURCE",
    1815067380: "IFCCREWRESOURCETYPE",
    2506170314: "IFCCSGPRIMITIVE3D",
    2147822146: "IFCCSGSOLID",
    539742890: "IFCCURRENCYRELATIONSHIP",
    3495092785: "IFCCURTAINWALL",
    1457835157: "IFCCURTAINWALLTYPE",
    2601014836: "IFCCURVE",
    2827736869: "IFCCURVEBOUNDEDPLANE",
    2629017746: "IFCCURVEBOUNDEDSURFACE",
    1186437898: "IFCCURVESEGMENT2D",
    3800577675: "IFCCURVESTYLE",
    1105321065: "IFCCURVESTYLEFONT",
    2367409068: "IFCCURVESTYLEFONTANDSCALING",
    3510044353: "IFCCURVESTYLEFONTPATTERN",
    1213902940: "IFCCYLINDRICALSURFACE",
    4074379575: "IFCDAMPER",
    3961806047: "IFCDAMPERTYPE",
    3426335179: "IFCDEEPFOUNDATION",
    1306400036: "IFCDEEPFOUNDATIONTYPE",
    3632507154: "IFCDERIVEDPROFILEDEF",
    1765591967: "IFCDERIVEDUNIT",
    1045800335: "IFCDERIVEDUNITELEMENT",
    2949456006: "IFCDIMENSIONALEXPONENTS",
    32440307: "IFCDIRECTION",
    1335981549: "IFCDISCRETEACCESSORY",
    2635815018: "IFCDISCRETEACCESSORYTYPE",
    1945343521: "IFCDISTANCEEXPRESSION",
    1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
    1599208980: "IFCDISTRIBUTIONCHAMBERELEMENTTYPE",
    562808652: "IFCDISTRIBUTIONCIRCUIT",
    1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
    2063403501: "IFCDISTRIBUTIONCONTROLELEMENTTYPE",
    1945004755: "IFCDISTRIBUTIONELEMENT",
    3256556792: "IFCDISTRIBUTIONELEMENTTYPE",
    3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
    3849074793: "IFCDISTRIBUTIONFLOWELEMENTTYPE",
    3041715199: "IFCDISTRIBUTIONPORT",
    3205830791: "IFCDISTRIBUTIONSYSTEM",
    1154170062: "IFCDOCUMENTINFORMATION",
    770865208: "IFCDOCUMENTINFORMATIONRELATIONSHIP",
    3732053477: "IFCDOCUMENTREFERENCE",
    395920057: "IFCDOOR",
    2963535650: "IFCDOORLININGPROPERTIES",
    1714330368: "IFCDOORPANELPROPERTIES",
    3242481149: "IFCDOORSTANDARDCASE",
    526551008: "IFCDOORSTYLE",
    2323601079: "IFCDOORTYPE",
    445594917: "IFCDRAUGHTINGPREDEFINEDCOLOUR",
    4006246654: "IFCDRAUGHTINGPREDEFINEDCURVEFONT",
    342316401: "IFCDUCTFITTING",
    869906466: "IFCDUCTFITTINGTYPE",
    3518393246: "IFCDUCTSEGMENT",
    3760055223: "IFCDUCTSEGMENTTYPE",
    1360408905: "IFCDUCTSILENCER",
    2030761528: "IFCDUCTSILENCERTYPE",
    3900360178: "IFCEDGE",
    476780140: "IFCEDGECURVE",
    1472233963: "IFCEDGELOOP",
    1904799276: "IFCELECTRICAPPLIANCE",
    663422040: "IFCELECTRICAPPLIANCETYPE",
    862014818: "IFCELECTRICDISTRIBUTIONBOARD",
    2417008758: "IFCELECTRICDISTRIBUTIONBOARDTYPE",
    3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
    3277789161: "IFCELECTRICFLOWSTORAGEDEVICETYPE",
    264262732: "IFCELECTRICGENERATOR",
    1534661035: "IFCELECTRICGENERATORTYPE",
    402227799: "IFCELECTRICMOTOR",
    1217240411: "IFCELECTRICMOTORTYPE",
    1003880860: "IFCELECTRICTIMECONTROL",
    712377611: "IFCELECTRICTIMECONTROLTYPE",
    1758889154: "IFCELEMENT",
    4123344466: "IFCELEMENTASSEMBLY",
    2397081782: "IFCELEMENTASSEMBLYTYPE",
    1623761950: "IFCELEMENTCOMPONENT",
    2590856083: "IFCELEMENTCOMPONENTTYPE",
    1883228015: "IFCELEMENTQUANTITY",
    339256511: "IFCELEMENTTYPE",
    2777663545: "IFCELEMENTARYSURFACE",
    1704287377: "IFCELLIPSE",
    2835456948: "IFCELLIPSEPROFILEDEF",
    1658829314: "IFCENERGYCONVERSIONDEVICE",
    2107101300: "IFCENERGYCONVERSIONDEVICETYPE",
    2814081492: "IFCENGINE",
    132023988: "IFCENGINETYPE",
    3747195512: "IFCEVAPORATIVECOOLER",
    3174744832: "IFCEVAPORATIVECOOLERTYPE",
    484807127: "IFCEVAPORATOR",
    3390157468: "IFCEVAPORATORTYPE",
    4148101412: "IFCEVENT",
    211053100: "IFCEVENTTIME",
    4024345920: "IFCEVENTTYPE",
    297599258: "IFCEXTENDEDPROPERTIES",
    4294318154: "IFCEXTERNALINFORMATION",
    3200245327: "IFCEXTERNALREFERENCE",
    1437805879: "IFCEXTERNALREFERENCERELATIONSHIP",
    1209101575: "IFCEXTERNALSPATIALELEMENT",
    2853485674: "IFCEXTERNALSPATIALSTRUCTUREELEMENT",
    2242383968: "IFCEXTERNALLYDEFINEDHATCHSTYLE",
    1040185647: "IFCEXTERNALLYDEFINEDSURFACESTYLE",
    3548104201: "IFCEXTERNALLYDEFINEDTEXTFONT",
    477187591: "IFCEXTRUDEDAREASOLID",
    2804161546: "IFCEXTRUDEDAREASOLIDTAPERED",
    2556980723: "IFCFACE",
    2047409740: "IFCFACEBASEDSURFACEMODEL",
    1809719519: "IFCFACEBOUND",
    803316827: "IFCFACEOUTERBOUND",
    3008276851: "IFCFACESURFACE",
    807026263: "IFCFACETEDBREP",
    3737207727: "IFCFACETEDBREPWITHVOIDS",
    24185140: "IFCFACILITY",
    1310830890: "IFCFACILITYPART",
    4219587988: "IFCFAILURECONNECTIONCONDITION",
    3415622556: "IFCFAN",
    346874300: "IFCFANTYPE",
    647756555: "IFCFASTENER",
    2489546625: "IFCFASTENERTYPE",
    2827207264: "IFCFEATUREELEMENT",
    2143335405: "IFCFEATUREELEMENTADDITION",
    1287392070: "IFCFEATUREELEMENTSUBTRACTION",
    738692330: "IFCFILLAREASTYLE",
    374418227: "IFCFILLAREASTYLEHATCHING",
    315944413: "IFCFILLAREASTYLETILES",
    819412036: "IFCFILTER",
    1810631287: "IFCFILTERTYPE",
    1426591983: "IFCFIRESUPPRESSIONTERMINAL",
    4222183408: "IFCFIRESUPPRESSIONTERMINALTYPE",
    2652556860: "IFCFIXEDREFERENCESWEPTAREASOLID",
    2058353004: "IFCFLOWCONTROLLER",
    3907093117: "IFCFLOWCONTROLLERTYPE",
    4278956645: "IFCFLOWFITTING",
    3198132628: "IFCFLOWFITTINGTYPE",
    182646315: "IFCFLOWINSTRUMENT",
    4037862832: "IFCFLOWINSTRUMENTTYPE",
    2188021234: "IFCFLOWMETER",
    3815607619: "IFCFLOWMETERTYPE",
    3132237377: "IFCFLOWMOVINGDEVICE",
    1482959167: "IFCFLOWMOVINGDEVICETYPE",
    987401354: "IFCFLOWSEGMENT",
    1834744321: "IFCFLOWSEGMENTTYPE",
    707683696: "IFCFLOWSTORAGEDEVICE",
    1339347760: "IFCFLOWSTORAGEDEVICETYPE",
    2223149337: "IFCFLOWTERMINAL",
    2297155007: "IFCFLOWTERMINALTYPE",
    3508470533: "IFCFLOWTREATMENTDEVICE",
    3009222698: "IFCFLOWTREATMENTDEVICETYPE",
    900683007: "IFCFOOTING",
    1893162501: "IFCFOOTINGTYPE",
    263784265: "IFCFURNISHINGELEMENT",
    4238390223: "IFCFURNISHINGELEMENTTYPE",
    1509553395: "IFCFURNITURE",
    1268542332: "IFCFURNITURETYPE",
    3493046030: "IFCGEOGRAPHICELEMENT",
    4095422895: "IFCGEOGRAPHICELEMENTTYPE",
    987898635: "IFCGEOMETRICCURVESET",
    3448662350: "IFCGEOMETRICREPRESENTATIONCONTEXT",
    2453401579: "IFCGEOMETRICREPRESENTATIONITEM",
    4142052618: "IFCGEOMETRICREPRESENTATIONSUBCONTEXT",
    3590301190: "IFCGEOMETRICSET",
    3009204131: "IFCGRID",
    852622518: "IFCGRIDAXIS",
    178086475: "IFCGRIDPLACEMENT",
    2706460486: "IFCGROUP",
    812098782: "IFCHALFSPACESOLID",
    3319311131: "IFCHEATEXCHANGER",
    1251058090: "IFCHEATEXCHANGERTYPE",
    2068733104: "IFCHUMIDIFIER",
    1806887404: "IFCHUMIDIFIERTYPE",
    1484403080: "IFCISHAPEPROFILEDEF",
    3905492369: "IFCIMAGETEXTURE",
    3570813810: "IFCINDEXEDCOLOURMAP",
    2571569899: "IFCINDEXEDPOLYCURVE",
    178912537: "IFCINDEXEDPOLYGONALFACE",
    2294589976: "IFCINDEXEDPOLYGONALFACEWITHVOIDS",
    1437953363: "IFCINDEXEDTEXTUREMAP",
    2133299955: "IFCINDEXEDTRIANGLETEXTUREMAP",
    4175244083: "IFCINTERCEPTOR",
    3946677679: "IFCINTERCEPTORTYPE",
    3113134337: "IFCINTERSECTIONCURVE",
    2391368822: "IFCINVENTORY",
    3741457305: "IFCIRREGULARTIMESERIES",
    3020489413: "IFCIRREGULARTIMESERIESVALUE",
    2176052936: "IFCJUNCTIONBOX",
    4288270099: "IFCJUNCTIONBOXTYPE",
    572779678: "IFCLSHAPEPROFILEDEF",
    3827777499: "IFCLABORRESOURCE",
    428585644: "IFCLABORRESOURCETYPE",
    1585845231: "IFCLAGTIME",
    76236018: "IFCLAMP",
    1051575348: "IFCLAMPTYPE",
    2655187982: "IFCLIBRARYINFORMATION",
    3452421091: "IFCLIBRARYREFERENCE",
    4162380809: "IFCLIGHTDISTRIBUTIONDATA",
    629592764: "IFCLIGHTFIXTURE",
    1161773419: "IFCLIGHTFIXTURETYPE",
    1566485204: "IFCLIGHTINTENSITYDISTRIBUTION",
    1402838566: "IFCLIGHTSOURCE",
    125510826: "IFCLIGHTSOURCEAMBIENT",
    2604431987: "IFCLIGHTSOURCEDIRECTIONAL",
    4266656042: "IFCLIGHTSOURCEGONIOMETRIC",
    1520743889: "IFCLIGHTSOURCEPOSITIONAL",
    3422422726: "IFCLIGHTSOURCESPOT",
    1281925730: "IFCLINE",
    3092502836: "IFCLINESEGMENT2D",
    388784114: "IFCLINEARPLACEMENT",
    1154579445: "IFCLINEARPOSITIONINGELEMENT",
    2624227202: "IFCLOCALPLACEMENT",
    1008929658: "IFCLOOP",
    1425443689: "IFCMANIFOLDSOLIDBREP",
    3057273783: "IFCMAPCONVERSION",
    2347385850: "IFCMAPPEDITEM",
    1838606355: "IFCMATERIAL",
    1847130766: "IFCMATERIALCLASSIFICATIONRELATIONSHIP",
    3708119000: "IFCMATERIALCONSTITUENT",
    2852063980: "IFCMATERIALCONSTITUENTSET",
    760658860: "IFCMATERIALDEFINITION",
    2022407955: "IFCMATERIALDEFINITIONREPRESENTATION",
    248100487: "IFCMATERIALLAYER",
    3303938423: "IFCMATERIALLAYERSET",
    1303795690: "IFCMATERIALLAYERSETUSAGE",
    1847252529: "IFCMATERIALLAYERWITHOFFSETS",
    2199411900: "IFCMATERIALLIST",
    2235152071: "IFCMATERIALPROFILE",
    164193824: "IFCMATERIALPROFILESET",
    3079605661: "IFCMATERIALPROFILESETUSAGE",
    3404854881: "IFCMATERIALPROFILESETUSAGETAPERING",
    552965576: "IFCMATERIALPROFILEWITHOFFSETS",
    3265635763: "IFCMATERIALPROPERTIES",
    853536259: "IFCMATERIALRELATIONSHIP",
    1507914824: "IFCMATERIALUSAGEDEFINITION",
    2597039031: "IFCMEASUREWITHUNIT",
    377706215: "IFCMECHANICALFASTENER",
    2108223431: "IFCMECHANICALFASTENERTYPE",
    1437502449: "IFCMEDICALDEVICE",
    1114901282: "IFCMEDICALDEVICETYPE",
    1073191201: "IFCMEMBER",
    1911478936: "IFCMEMBERSTANDARDCASE",
    3181161470: "IFCMEMBERTYPE",
    3368373690: "IFCMETRIC",
    2998442950: "IFCMIRROREDPROFILEDEF",
    2706619895: "IFCMONETARYUNIT",
    2474470126: "IFCMOTORCONNECTION",
    977012517: "IFCMOTORCONNECTIONTYPE",
    1918398963: "IFCNAMEDUNIT",
    3888040117: "IFCOBJECT",
    219451334: "IFCOBJECTDEFINITION",
    3701648758: "IFCOBJECTPLACEMENT",
    2251480897: "IFCOBJECTIVE",
    4143007308: "IFCOCCUPANT",
    590820931: "IFCOFFSETCURVE",
    3388369263: "IFCOFFSETCURVE2D",
    3505215534: "IFCOFFSETCURVE3D",
    2485787929: "IFCOFFSETCURVEBYDISTANCES",
    2665983363: "IFCOPENSHELL",
    3588315303: "IFCOPENINGELEMENT",
    3079942009: "IFCOPENINGSTANDARDCASE",
    4251960020: "IFCORGANIZATION",
    1411181986: "IFCORGANIZATIONRELATIONSHIP",
    643959842: "IFCORIENTATIONEXPRESSION",
    1029017970: "IFCORIENTEDEDGE",
    144952367: "IFCOUTERBOUNDARYCURVE",
    3694346114: "IFCOUTLET",
    2837617999: "IFCOUTLETTYPE",
    1207048766: "IFCOWNERHISTORY",
    2529465313: "IFCPARAMETERIZEDPROFILEDEF",
    2519244187: "IFCPATH",
    1682466193: "IFCPCURVE",
    2382730787: "IFCPERFORMANCEHISTORY",
    3566463478: "IFCPERMEABLECOVERINGPROPERTIES",
    3327091369: "IFCPERMIT",
    2077209135: "IFCPERSON",
    101040310: "IFCPERSONANDORGANIZATION",
    3021840470: "IFCPHYSICALCOMPLEXQUANTITY",
    2483315170: "IFCPHYSICALQUANTITY",
    2226359599: "IFCPHYSICALSIMPLEQUANTITY",
    1687234759: "IFCPILE",
    1158309216: "IFCPILETYPE",
    310824031: "IFCPIPEFITTING",
    804291784: "IFCPIPEFITTINGTYPE",
    3612865200: "IFCPIPESEGMENT",
    4231323485: "IFCPIPESEGMENTTYPE",
    597895409: "IFCPIXELTEXTURE",
    2004835150: "IFCPLACEMENT",
    603570806: "IFCPLANARBOX",
    1663979128: "IFCPLANAREXTENT",
    220341763: "IFCPLANE",
    3171933400: "IFCPLATE",
    1156407060: "IFCPLATESTANDARDCASE",
    4017108033: "IFCPLATETYPE",
    2067069095: "IFCPOINT",
    4022376103: "IFCPOINTONCURVE",
    1423911732: "IFCPOINTONSURFACE",
    2924175390: "IFCPOLYLOOP",
    2775532180: "IFCPOLYGONALBOUNDEDHALFSPACE",
    2839578677: "IFCPOLYGONALFACESET",
    3724593414: "IFCPOLYLINE",
    3740093272: "IFCPORT",
    1946335990: "IFCPOSITIONINGELEMENT",
    3355820592: "IFCPOSTALADDRESS",
    759155922: "IFCPREDEFINEDCOLOUR",
    2559016684: "IFCPREDEFINEDCURVEFONT",
    3727388367: "IFCPREDEFINEDITEM",
    3778827333: "IFCPREDEFINEDPROPERTIES",
    3967405729: "IFCPREDEFINEDPROPERTYSET",
    1775413392: "IFCPREDEFINEDTEXTFONT",
    677532197: "IFCPRESENTATIONITEM",
    2022622350: "IFCPRESENTATIONLAYERASSIGNMENT",
    1304840413: "IFCPRESENTATIONLAYERWITHSTYLE",
    3119450353: "IFCPRESENTATIONSTYLE",
    2417041796: "IFCPRESENTATIONSTYLEASSIGNMENT",
    2744685151: "IFCPROCEDURE",
    569719735: "IFCPROCEDURETYPE",
    2945172077: "IFCPROCESS",
    4208778838: "IFCPRODUCT",
    673634403: "IFCPRODUCTDEFINITIONSHAPE",
    2095639259: "IFCPRODUCTREPRESENTATION",
    3958567839: "IFCPROFILEDEF",
    2802850158: "IFCPROFILEPROPERTIES",
    103090709: "IFCPROJECT",
    653396225: "IFCPROJECTLIBRARY",
    2904328755: "IFCPROJECTORDER",
    3843373140: "IFCPROJECTEDCRS",
    3651124850: "IFCPROJECTIONELEMENT",
    2598011224: "IFCPROPERTY",
    986844984: "IFCPROPERTYABSTRACTION",
    871118103: "IFCPROPERTYBOUNDEDVALUE",
    1680319473: "IFCPROPERTYDEFINITION",
    148025276: "IFCPROPERTYDEPENDENCYRELATIONSHIP",
    4166981789: "IFCPROPERTYENUMERATEDVALUE",
    3710013099: "IFCPROPERTYENUMERATION",
    2752243245: "IFCPROPERTYLISTVALUE",
    941946838: "IFCPROPERTYREFERENCEVALUE",
    1451395588: "IFCPROPERTYSET",
    3357820518: "IFCPROPERTYSETDEFINITION",
    492091185: "IFCPROPERTYSETTEMPLATE",
    3650150729: "IFCPROPERTYSINGLEVALUE",
    110355661: "IFCPROPERTYTABLEVALUE",
    3521284610: "IFCPROPERTYTEMPLATE",
    1482703590: "IFCPROPERTYTEMPLATEDEFINITION",
    738039164: "IFCPROTECTIVEDEVICE",
    2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
    655969474: "IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",
    1842657554: "IFCPROTECTIVEDEVICETYPE",
    3219374653: "IFCPROXY",
    90941305: "IFCPUMP",
    2250791053: "IFCPUMPTYPE",
    2044713172: "IFCQUANTITYAREA",
    2093928680: "IFCQUANTITYCOUNT",
    931644368: "IFCQUANTITYLENGTH",
    2090586900: "IFCQUANTITYSET",
    3252649465: "IFCQUANTITYTIME",
    2405470396: "IFCQUANTITYVOLUME",
    825690147: "IFCQUANTITYWEIGHT",
    2262370178: "IFCRAILING",
    2893384427: "IFCRAILINGTYPE",
    3024970846: "IFCRAMP",
    3283111854: "IFCRAMPFLIGHT",
    2324767716: "IFCRAMPFLIGHTTYPE",
    1469900589: "IFCRAMPTYPE",
    1232101972: "IFCRATIONALBSPLINECURVEWITHKNOTS",
    683857671: "IFCRATIONALBSPLINESURFACEWITHKNOTS",
    2770003689: "IFCRECTANGLEHOLLOWPROFILEDEF",
    3615266464: "IFCRECTANGLEPROFILEDEF",
    2798486643: "IFCRECTANGULARPYRAMID",
    3454111270: "IFCRECTANGULARTRIMMEDSURFACE",
    3915482550: "IFCRECURRENCEPATTERN",
    2433181523: "IFCREFERENCE",
    4021432810: "IFCREFERENT",
    3413951693: "IFCREGULARTIMESERIES",
    1580146022: "IFCREINFORCEMENTBARPROPERTIES",
    3765753017: "IFCREINFORCEMENTDEFINITIONPROPERTIES",
    979691226: "IFCREINFORCINGBAR",
    2572171363: "IFCREINFORCINGBARTYPE",
    3027567501: "IFCREINFORCINGELEMENT",
    964333572: "IFCREINFORCINGELEMENTTYPE",
    2320036040: "IFCREINFORCINGMESH",
    2310774935: "IFCREINFORCINGMESHTYPE",
    160246688: "IFCRELAGGREGATES",
    3939117080: "IFCRELASSIGNS",
    1683148259: "IFCRELASSIGNSTOACTOR",
    2495723537: "IFCRELASSIGNSTOCONTROL",
    1307041759: "IFCRELASSIGNSTOGROUP",
    1027710054: "IFCRELASSIGNSTOGROUPBYFACTOR",
    4278684876: "IFCRELASSIGNSTOPROCESS",
    2857406711: "IFCRELASSIGNSTOPRODUCT",
    205026976: "IFCRELASSIGNSTORESOURCE",
    1865459582: "IFCRELASSOCIATES",
    4095574036: "IFCRELASSOCIATESAPPROVAL",
    919958153: "IFCRELASSOCIATESCLASSIFICATION",
    2728634034: "IFCRELASSOCIATESCONSTRAINT",
    982818633: "IFCRELASSOCIATESDOCUMENT",
    3840914261: "IFCRELASSOCIATESLIBRARY",
    2655215786: "IFCRELASSOCIATESMATERIAL",
    826625072: "IFCRELCONNECTS",
    1204542856: "IFCRELCONNECTSELEMENTS",
    3945020480: "IFCRELCONNECTSPATHELEMENTS",
    4201705270: "IFCRELCONNECTSPORTTOELEMENT",
    3190031847: "IFCRELCONNECTSPORTS",
    2127690289: "IFCRELCONNECTSSTRUCTURALACTIVITY",
    1638771189: "IFCRELCONNECTSSTRUCTURALMEMBER",
    504942748: "IFCRELCONNECTSWITHECCENTRICITY",
    3678494232: "IFCRELCONNECTSWITHREALIZINGELEMENTS",
    3242617779: "IFCRELCONTAINEDINSPATIALSTRUCTURE",
    886880790: "IFCRELCOVERSBLDGELEMENTS",
    2802773753: "IFCRELCOVERSSPACES",
    2565941209: "IFCRELDECLARES",
    2551354335: "IFCRELDECOMPOSES",
    693640335: "IFCRELDEFINES",
    1462361463: "IFCRELDEFINESBYOBJECT",
    4186316022: "IFCRELDEFINESBYPROPERTIES",
    307848117: "IFCRELDEFINESBYTEMPLATE",
    781010003: "IFCRELDEFINESBYTYPE",
    3940055652: "IFCRELFILLSELEMENT",
    279856033: "IFCRELFLOWCONTROLELEMENTS",
    427948657: "IFCRELINTERFERESELEMENTS",
    3268803585: "IFCRELNESTS",
    1441486842: "IFCRELPOSITIONS",
    750771296: "IFCRELPROJECTSELEMENT",
    1245217292: "IFCRELREFERENCEDINSPATIALSTRUCTURE",
    4122056220: "IFCRELSEQUENCE",
    366585022: "IFCRELSERVICESBUILDINGS",
    3451746338: "IFCRELSPACEBOUNDARY",
    3523091289: "IFCRELSPACEBOUNDARY1STLEVEL",
    1521410863: "IFCRELSPACEBOUNDARY2NDLEVEL",
    1401173127: "IFCRELVOIDSELEMENT",
    478536968: "IFCRELATIONSHIP",
    816062949: "IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",
    1076942058: "IFCREPRESENTATION",
    3377609919: "IFCREPRESENTATIONCONTEXT",
    3008791417: "IFCREPRESENTATIONITEM",
    1660063152: "IFCREPRESENTATIONMAP",
    2914609552: "IFCRESOURCE",
    2943643501: "IFCRESOURCEAPPROVALRELATIONSHIP",
    1608871552: "IFCRESOURCECONSTRAINTRELATIONSHIP",
    2439245199: "IFCRESOURCELEVELRELATIONSHIP",
    1042787934: "IFCRESOURCETIME",
    1856042241: "IFCREVOLVEDAREASOLID",
    3243963512: "IFCREVOLVEDAREASOLIDTAPERED",
    4158566097: "IFCRIGHTCIRCULARCONE",
    3626867408: "IFCRIGHTCIRCULARCYLINDER",
    2016517767: "IFCROOF",
    2781568857: "IFCROOFTYPE",
    2341007311: "IFCROOT",
    2778083089: "IFCROUNDEDRECTANGLEPROFILEDEF",
    448429030: "IFCSIUNIT",
    3053780830: "IFCSANITARYTERMINAL",
    1768891740: "IFCSANITARYTERMINALTYPE",
    1054537805: "IFCSCHEDULINGTIME",
    2157484638: "IFCSEAMCURVE",
    2042790032: "IFCSECTIONPROPERTIES",
    4165799628: "IFCSECTIONREINFORCEMENTPROPERTIES",
    1862484736: "IFCSECTIONEDSOLID",
    1290935644: "IFCSECTIONEDSOLIDHORIZONTAL",
    1509187699: "IFCSECTIONEDSPINE",
    4086658281: "IFCSENSOR",
    1783015770: "IFCSENSORTYPE",
    1329646415: "IFCSHADINGDEVICE",
    4074543187: "IFCSHADINGDEVICETYPE",
    867548509: "IFCSHAPEASPECT",
    3982875396: "IFCSHAPEMODEL",
    4240577450: "IFCSHAPEREPRESENTATION",
    4124623270: "IFCSHELLBASEDSURFACEMODEL",
    3692461612: "IFCSIMPLEPROPERTY",
    3663146110: "IFCSIMPLEPROPERTYTEMPLATE",
    4097777520: "IFCSITE",
    1529196076: "IFCSLAB",
    3127900445: "IFCSLABELEMENTEDCASE",
    3027962421: "IFCSLABSTANDARDCASE",
    2533589738: "IFCSLABTYPE",
    2609359061: "IFCSLIPPAGECONNECTIONCONDITION",
    3420628829: "IFCSOLARDEVICE",
    1072016465: "IFCSOLARDEVICETYPE",
    723233188: "IFCSOLIDMODEL",
    3856911033: "IFCSPACE",
    1999602285: "IFCSPACEHEATER",
    1305183839: "IFCSPACEHEATERTYPE",
    3812236995: "IFCSPACETYPE",
    1412071761: "IFCSPATIALELEMENT",
    710998568: "IFCSPATIALELEMENTTYPE",
    2706606064: "IFCSPATIALSTRUCTUREELEMENT",
    3893378262: "IFCSPATIALSTRUCTUREELEMENTTYPE",
    463610769: "IFCSPATIALZONE",
    2481509218: "IFCSPATIALZONETYPE",
    451544542: "IFCSPHERE",
    4015995234: "IFCSPHERICALSURFACE",
    1404847402: "IFCSTACKTERMINAL",
    3112655638: "IFCSTACKTERMINALTYPE",
    331165859: "IFCSTAIR",
    4252922144: "IFCSTAIRFLIGHT",
    1039846685: "IFCSTAIRFLIGHTTYPE",
    338393293: "IFCSTAIRTYPE",
    682877961: "IFCSTRUCTURALACTION",
    3544373492: "IFCSTRUCTURALACTIVITY",
    2515109513: "IFCSTRUCTURALANALYSISMODEL",
    1179482911: "IFCSTRUCTURALCONNECTION",
    2273995522: "IFCSTRUCTURALCONNECTIONCONDITION",
    1004757350: "IFCSTRUCTURALCURVEACTION",
    4243806635: "IFCSTRUCTURALCURVECONNECTION",
    214636428: "IFCSTRUCTURALCURVEMEMBER",
    2445595289: "IFCSTRUCTURALCURVEMEMBERVARYING",
    2757150158: "IFCSTRUCTURALCURVEREACTION",
    3136571912: "IFCSTRUCTURALITEM",
    1807405624: "IFCSTRUCTURALLINEARACTION",
    2162789131: "IFCSTRUCTURALLOAD",
    385403989: "IFCSTRUCTURALLOADCASE",
    3478079324: "IFCSTRUCTURALLOADCONFIGURATION",
    1252848954: "IFCSTRUCTURALLOADGROUP",
    1595516126: "IFCSTRUCTURALLOADLINEARFORCE",
    609421318: "IFCSTRUCTURALLOADORRESULT",
    2668620305: "IFCSTRUCTURALLOADPLANARFORCE",
    2473145415: "IFCSTRUCTURALLOADSINGLEDISPLACEMENT",
    1973038258: "IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",
    1597423693: "IFCSTRUCTURALLOADSINGLEFORCE",
    1190533807: "IFCSTRUCTURALLOADSINGLEFORCEWARPING",
    2525727697: "IFCSTRUCTURALLOADSTATIC",
    3408363356: "IFCSTRUCTURALLOADTEMPERATURE",
    530289379: "IFCSTRUCTURALMEMBER",
    1621171031: "IFCSTRUCTURALPLANARACTION",
    2082059205: "IFCSTRUCTURALPOINTACTION",
    734778138: "IFCSTRUCTURALPOINTCONNECTION",
    1235345126: "IFCSTRUCTURALPOINTREACTION",
    3689010777: "IFCSTRUCTURALREACTION",
    2986769608: "IFCSTRUCTURALRESULTGROUP",
    3657597509: "IFCSTRUCTURALSURFACEACTION",
    1975003073: "IFCSTRUCTURALSURFACECONNECTION",
    3979015343: "IFCSTRUCTURALSURFACEMEMBER",
    2218152070: "IFCSTRUCTURALSURFACEMEMBERVARYING",
    603775116: "IFCSTRUCTURALSURFACEREACTION",
    2830218821: "IFCSTYLEMODEL",
    3958052878: "IFCSTYLEDITEM",
    3049322572: "IFCSTYLEDREPRESENTATION",
    148013059: "IFCSUBCONTRACTRESOURCE",
    4095615324: "IFCSUBCONTRACTRESOURCETYPE",
    2233826070: "IFCSUBEDGE",
    2513912981: "IFCSURFACE",
    699246055: "IFCSURFACECURVE",
    2028607225: "IFCSURFACECURVESWEPTAREASOLID",
    3101698114: "IFCSURFACEFEATURE",
    2809605785: "IFCSURFACEOFLINEAREXTRUSION",
    4124788165: "IFCSURFACEOFREVOLUTION",
    2934153892: "IFCSURFACEREINFORCEMENTAREA",
    1300840506: "IFCSURFACESTYLE",
    3303107099: "IFCSURFACESTYLELIGHTING",
    1607154358: "IFCSURFACESTYLEREFRACTION",
    1878645084: "IFCSURFACESTYLERENDERING",
    846575682: "IFCSURFACESTYLESHADING",
    1351298697: "IFCSURFACESTYLEWITHTEXTURES",
    626085974: "IFCSURFACETEXTURE",
    2247615214: "IFCSWEPTAREASOLID",
    1260650574: "IFCSWEPTDISKSOLID",
    1096409881: "IFCSWEPTDISKSOLIDPOLYGONAL",
    230924584: "IFCSWEPTSURFACE",
    1162798199: "IFCSWITCHINGDEVICE",
    2315554128: "IFCSWITCHINGDEVICETYPE",
    2254336722: "IFCSYSTEM",
    413509423: "IFCSYSTEMFURNITUREELEMENT",
    1580310250: "IFCSYSTEMFURNITUREELEMENTTYPE",
    3071757647: "IFCTSHAPEPROFILEDEF",
    985171141: "IFCTABLE",
    2043862942: "IFCTABLECOLUMN",
    531007025: "IFCTABLEROW",
    812556717: "IFCTANK",
    5716631: "IFCTANKTYPE",
    3473067441: "IFCTASK",
    1549132990: "IFCTASKTIME",
    2771591690: "IFCTASKTIMERECURRING",
    3206491090: "IFCTASKTYPE",
    912023232: "IFCTELECOMADDRESS",
    3824725483: "IFCTENDON",
    2347447852: "IFCTENDONANCHOR",
    3081323446: "IFCTENDONANCHORTYPE",
    3663046924: "IFCTENDONCONDUIT",
    2281632017: "IFCTENDONCONDUITTYPE",
    2415094496: "IFCTENDONTYPE",
    2387106220: "IFCTESSELLATEDFACESET",
    901063453: "IFCTESSELLATEDITEM",
    4282788508: "IFCTEXTLITERAL",
    3124975700: "IFCTEXTLITERALWITHEXTENT",
    1447204868: "IFCTEXTSTYLE",
    1983826977: "IFCTEXTSTYLEFONTMODEL",
    2636378356: "IFCTEXTSTYLEFORDEFINEDFONT",
    1640371178: "IFCTEXTSTYLETEXTMODEL",
    280115917: "IFCTEXTURECOORDINATE",
    1742049831: "IFCTEXTURECOORDINATEGENERATOR",
    2552916305: "IFCTEXTUREMAP",
    1210645708: "IFCTEXTUREVERTEX",
    3611470254: "IFCTEXTUREVERTEXLIST",
    1199560280: "IFCTIMEPERIOD",
    3101149627: "IFCTIMESERIES",
    581633288: "IFCTIMESERIESVALUE",
    1377556343: "IFCTOPOLOGICALREPRESENTATIONITEM",
    1735638870: "IFCTOPOLOGYREPRESENTATION",
    1935646853: "IFCTOROIDALSURFACE",
    3825984169: "IFCTRANSFORMER",
    1692211062: "IFCTRANSFORMERTYPE",
    2595432518: "IFCTRANSITIONCURVESEGMENT2D",
    1620046519: "IFCTRANSPORTELEMENT",
    2097647324: "IFCTRANSPORTELEMENTTYPE",
    2715220739: "IFCTRAPEZIUMPROFILEDEF",
    2916149573: "IFCTRIANGULATEDFACESET",
    1229763772: "IFCTRIANGULATEDIRREGULARNETWORK",
    3593883385: "IFCTRIMMEDCURVE",
    3026737570: "IFCTUBEBUNDLE",
    1600972822: "IFCTUBEBUNDLETYPE",
    1628702193: "IFCTYPEOBJECT",
    3736923433: "IFCTYPEPROCESS",
    2347495698: "IFCTYPEPRODUCT",
    3698973494: "IFCTYPERESOURCE",
    427810014: "IFCUSHAPEPROFILEDEF",
    180925521: "IFCUNITASSIGNMENT",
    630975310: "IFCUNITARYCONTROLELEMENT",
    3179687236: "IFCUNITARYCONTROLELEMENTTYPE",
    4292641817: "IFCUNITARYEQUIPMENT",
    1911125066: "IFCUNITARYEQUIPMENTTYPE",
    4207607924: "IFCVALVE",
    728799441: "IFCVALVETYPE",
    1417489154: "IFCVECTOR",
    2799835756: "IFCVERTEX",
    2759199220: "IFCVERTEXLOOP",
    1907098498: "IFCVERTEXPOINT",
    1530820697: "IFCVIBRATIONDAMPER",
    3956297820: "IFCVIBRATIONDAMPERTYPE",
    2391383451: "IFCVIBRATIONISOLATOR",
    3313531582: "IFCVIBRATIONISOLATORTYPE",
    2769231204: "IFCVIRTUALELEMENT",
    891718957: "IFCVIRTUALGRIDINTERSECTION",
    926996030: "IFCVOIDINGFEATURE",
    2391406946: "IFCWALL",
    4156078855: "IFCWALLELEMENTEDCASE",
    3512223829: "IFCWALLSTANDARDCASE",
    1898987631: "IFCWALLTYPE",
    4237592921: "IFCWASTETERMINAL",
    1133259667: "IFCWASTETERMINALTYPE",
    3304561284: "IFCWINDOW",
    336235671: "IFCWINDOWLININGPROPERTIES",
    512836454: "IFCWINDOWPANELPROPERTIES",
    486154966: "IFCWINDOWSTANDARDCASE",
    1299126871: "IFCWINDOWSTYLE",
    4009809668: "IFCWINDOWTYPE",
    4088093105: "IFCWORKCALENDAR",
    1028945134: "IFCWORKCONTROL",
    4218914973: "IFCWORKPLAN",
    3342526732: "IFCWORKSCHEDULE",
    1236880293: "IFCWORKTIME",
    2543172580: "IFCZSHAPEPROFILEDEF",
    1033361043: "IFCZONE",
};

class JSONPropertyManager extends BasePropertyManager {
    async getItemProperties(modelID, id, recursive = false) {
        return { ...this.state.models[modelID].jsonData[id] };
    }
    async getSpatialStructure(modelID, includeProperties) {
        const chunks = await this.getSpatialTreeChunks(modelID);
        const projectsIDs = await this.getAllItemsOfType(modelID, IFCPROJECT, false);
        const projectID = projectsIDs[0];
        const project = JSONPropertyManager.newIfcProject(projectID);
        await this.getSpatialNode(modelID, project, chunks, includeProperties);
        return { ...project };
    }
    async getAllItemsOfType(modelID, type, verbose) {
        const data = this.state.models[modelID].jsonData;
        const typeName = IfcTypesMap[type];
        if (!typeName) {
            throw new Error(`Type not found: ${type}`);
        }
        return this.filterItemsByType(data, typeName, verbose);
    }
    async getProperty(modelID, elementID, recursive = false, propName) {
        const resultIDs = await this.getAllRelatedItemsOfType(modelID, elementID, propName);
        const result = this.getItemsByID(modelID, resultIDs);
        if (recursive) {
            result.forEach(result => this.getReferencesRecursively(modelID, result));
        }
        return result;
    }
    getNodeType(modelID, id) {
        return this.state.models[modelID].jsonData[id].type;
    }
    async getChunks(modelID, chunks, propNames) {
        const relation = await this.getAllItemsOfType(modelID, propNames.name, true);
        relation.forEach(rel => {
            this.saveChunk(chunks, propNames, rel);
        });
    }
    filterItemsByType(data, typeName, verbose) {
        const result = [];
        Object.keys(data).forEach(key => {
            const numKey = parseInt(key);
            if (data[numKey].type.toUpperCase() === typeName) {
                result.push(verbose ? { ...data[numKey] } : numKey);
            }
        });
        return result;
    }
    async getAllRelatedItemsOfType(modelID, id, propNames) {
        const lines = await this.getAllItemsOfType(modelID, propNames.name, true);
        const IDs = [];
        lines.forEach(line => {
            const isRelated = JSONPropertyManager.isRelated(id, line, propNames);
            if (isRelated)
                this.getRelated(line, propNames, IDs);
        });
        return IDs;
    }
    getItemsByID(modelID, ids) {
        const data = this.state.models[modelID].jsonData;
        const result = [];
        ids.forEach(id => result.push({ ...data[id] }));
        return result;
    }
    getReferencesRecursively(modelID, jsonObject) {
        if (jsonObject == undefined)
            return;
        const keys = Object.keys(jsonObject);
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            this.getJSONItem(modelID, jsonObject, key);
        }
    }
    getJSONItem(modelID, jsonObject, key) {
        if (Array.isArray(jsonObject[key])) {
            return this.getMultipleJSONItems(modelID, jsonObject, key);
        }
        if (jsonObject[key] && jsonObject[key].type === 5) {
            jsonObject[key] = this.getItemsByID(modelID, [jsonObject[key].value])[0];
            this.getReferencesRecursively(modelID, jsonObject[key]);
        }
    }
    getMultipleJSONItems(modelID, jsonObject, key) {
        jsonObject[key] = jsonObject[key].map((item) => {
            if (item.type === 5) {
                item = this.getItemsByID(modelID, [item.value])[0];
                this.getReferencesRecursively(modelID, item);
            }
            return item;
        });
    }
}

const geometryTypes = new Set([
    1123145078, 574549367, 1675464909, 2059837836, 3798115385, 32440307, 3125803723, 3207858831,
    2740243338, 2624227202, 4240577450, 3615266464, 3724593414, 220341763, 477187591, 1878645084,
    1300840506, 3303107099, 1607154358, 1878645084, 846575682, 1351298697, 2417041796, 3049322572,
    3331915920, 1416205885, 776857604, 3285139300, 3958052878, 2827736869, 2732653382, 673634403,
    3448662350, 4142052618, 2924175390, 803316827, 2556980723, 1809719519, 2205249479, 807026263,
    3737207727, 1660063152, 2347385850, 3940055652, 2705031697, 3732776249, 2485617015, 2611217952,
    1704287377, 2937912522, 2770003689, 1281925730, 1484403080, 3448662350, 4142052618, 3800577675,
    4006246654, 3590301190, 1383045692, 2775532180, 2047409740, 370225590, 3593883385, 2665983363,
    4124623270, 812098782, 3649129432, 987898635, 1105321065, 3510044353, 1635779807, 2603310189,
    3406155212, 1310608509, 4261334040, 2736907675, 3649129432, 1136057603, 1260505505, 4182860854,
    2713105998, 2898889636, 59481748, 3749851601, 3486308946, 3150382593, 1062206242, 3264961684,
    15328376, 1485152156, 370225590, 1981873012, 2859738748, 45288368, 2614616156, 2732653382,
    775493141, 2147822146, 2601014836, 2629017746, 1186437898, 2367409068, 1213902940, 3632507154,
    3900360178, 476780140, 1472233963, 2804161546, 3008276851, 738692330, 374418227, 315944413,
    3905492369, 3570813810, 2571569899, 178912537, 2294589976, 1437953363, 2133299955, 572779678,
    3092502836, 388784114, 2624227202, 1425443689, 3057273783, 2347385850, 1682466193, 2519244187,
    2839578677, 3958567839, 2513912981, 2830218821, 427810014
]);

class PropertySerializer {
    constructor(webIfc) {
        this.webIfc = webIfc;
    }
    dispose() {
        this.webIfc = null;
    }
    async serializeAllProperties(modelID, maxSize, event) {
        const blobs = [];
        await this.getPropertiesAsBlobs(modelID, blobs, maxSize, event);
        return blobs;
    }
    async getPropertiesAsBlobs(modelID, blobs, maxSize, event) {
        const geometriesIDs = await this.getAllGeometriesIDs(modelID);
        let properties = await this.initializePropertiesObject(modelID);
        const allLinesIDs = await this.webIfc.GetAllLines(modelID);
        const linesCount = allLinesIDs.size();
        let lastEvent = 0.1;
        let counter = 0;
        for (let i = 0; i < linesCount; i++) {
            const id = allLinesIDs.get(i);
            if (!geometriesIDs.has(id)) {
                await this.getItemProperty(modelID, id, properties);
                counter++;
            }
            if (maxSize && counter > maxSize) {
                blobs.push(new Blob([JSON.stringify(properties)], { type: 'application/json' }));
                properties = {};
                counter = 0;
            }
            if (event && i / linesCount > lastEvent) {
                event(i, linesCount);
                lastEvent += 0.1;
            }
        }
        blobs.push(new Blob([JSON.stringify(properties)], { type: 'application/json' }));
    }
    async getItemProperty(modelID, id, properties) {
        try {
            const props = await this.webIfc.GetLine(modelID, id);
            if (props.type) {
                props.type = IfcTypesMap[props.type];
            }
            this.formatItemProperties(props);
            properties[id] = props;
        }
        catch (e) {
            console.log(`There was a problem getting the properties of the item with ID ${id}`);
        }
    }
    formatItemProperties(props) {
        Object.keys(props).forEach((key) => {
            const value = props[key];
            if (value && value.value !== undefined)
                props[key] = value.value;
            else if (Array.isArray(value))
                props[key] = value.map((item) => {
                    if (item && item.value)
                        return item.value;
                    return item;
                });
        });
    }
    async initializePropertiesObject(modelID) {
        return {
            coordinationMatrix: await this.webIfc.GetCoordinationMatrix(modelID),
            globalHeight: await this.getBuildingHeight(modelID)
        };
    }
    async getBuildingHeight(modelID) {
        const building = await this.getBuilding(modelID);
        let placement;
        const siteReference = building.ObjectPlacement.PlacementRelTo;
        if (siteReference)
            placement = siteReference.RelativePlacement.Location;
        else
            placement = building.ObjectPlacement.RelativePlacement.Location;
        const transform = placement.Coordinates.map((coord) => coord.value);
        return transform[2];
    }
    async getBuilding(modelID) {
        const allBuildingsIDs = await this.webIfc.GetLineIDsWithType(modelID, IFCBUILDING);
        const buildingID = allBuildingsIDs.get(0);
        return this.webIfc.GetLine(modelID, buildingID, true);
    }
    async getAllGeometriesIDs(modelID) {
        const geometriesIDs = new Set();
        const geomTypesArray = Array.from(geometryTypes);
        for (let i = 0; i < geomTypesArray.length; i++) {
            const category = geomTypesArray[i];
            const ids = await this.webIfc.GetLineIDsWithType(modelID, category);
            const idsSize = ids.size();
            for (let j = 0; j < idsSize; j++) {
                geometriesIDs.add(ids.get(j));
            }
        }
        return geometriesIDs;
    }
}

class PropertyManager {
    constructor(state) {
        this.state = state;
        this.webIfcProps = new WebIfcPropertyManager(state);
        this.jsonProps = new JSONPropertyManager(state);
        this.currentProps = this.webIfcProps;
        this.serializer = new PropertySerializer(this.state.api);
    }
    getExpressId(geometry, faceIndex) {
        if (!geometry.index)
            throw new Error('Geometry does not have index information.');
        const geoIndex = geometry.index.array;
        const bufferAttr = geometry.attributes[IdAttrName];
        return bufferAttr.getX(geoIndex[3 * faceIndex]);
    }
    async getItemProperties(modelID, elementID, recursive = false) {
        this.updateCurrentProps();
        return this.currentProps.getItemProperties(modelID, elementID, recursive);
    }
    async getAllItemsOfType(modelID, type, verbose) {
        this.updateCurrentProps();
        return this.currentProps.getAllItemsOfType(modelID, type, verbose);
    }
    async getPropertySets(modelID, elementID, recursive = false) {
        this.updateCurrentProps();
        return this.currentProps.getPropertySets(modelID, elementID, recursive);
    }
    async getTypeProperties(modelID, elementID, recursive = false) {
        this.updateCurrentProps();
        return this.currentProps.getTypeProperties(modelID, elementID, recursive);
    }
    async getMaterialsProperties(modelID, elementID, recursive = false) {
        this.updateCurrentProps();
        return this.currentProps.getMaterialsProperties(modelID, elementID, recursive);
    }
    async getSpatialStructure(modelID, includeProperties) {
        this.updateCurrentProps();
        if (!this.state.useJSON && includeProperties) {
            console.warn('Including properties in getSpatialStructure with the JSON workflow disabled can lead to poor performance.');
        }
        return await this.currentProps.getSpatialStructure(modelID, includeProperties);
    }
    updateCurrentProps() {
        this.currentProps = this.state.useJSON ? this.jsonProps : this.webIfcProps;
    }
}

class PropertyWorker {
    constructor(worker) {
        this.worker = worker;
        this.API = WorkerAPIs.properties;
    }
    initializeProperties() {
        if (!this.properties) {
            if (!this.worker.state)
                throw new Error(ErrorRootStateNotAvailable);
            this.properties = new PropertyManager(this.worker.state);
        }
    }
    async getAllItemsOfType(data) {
        this.initializeProperties();
        if (!this.properties)
            throw new Error(ErrorPropertiesNotAvailable);
        const args = data.args;
        data.result = await this.properties.getAllItemsOfType(args.modelID, args.type, args.verbose);
        this.worker.post(data);
    }
    async getItemProperties(data) {
        this.initializeProperties();
        if (!this.properties)
            throw new Error(ErrorPropertiesNotAvailable);
        const args = data.args;
        data.result = await this.properties.getItemProperties(args.modelID, args.elementID, args.recursive);
        this.worker.post(data);
    }
    async getMaterialsProperties(data) {
        this.initializeProperties();
        if (!this.properties)
            throw new Error(ErrorPropertiesNotAvailable);
        const args = data.args;
        data.result = await this.properties.getMaterialsProperties(args.modelID, args.elementID, args.recursive);
        this.worker.post(data);
    }
    async getPropertySets(data) {
        this.initializeProperties();
        if (!this.properties)
            throw new Error(ErrorPropertiesNotAvailable);
        const args = data.args;
        data.result = await this.properties.getPropertySets(args.modelID, args.elementID, args.recursive);
        this.worker.post(data);
    }
    async getSpatialStructure(data) {
        this.initializeProperties();
        if (!this.properties)
            throw new Error(ErrorPropertiesNotAvailable);
        const args = data.args;
        data.result = await this.properties.getSpatialStructure(args.modelID, args.includeProperties);
        this.worker.post(data);
    }
    async getTypeProperties(data) {
        this.initializeProperties();
        if (!this.properties)
            throw new Error(ErrorPropertiesNotAvailable);
        const args = data.args;
        data.result = await this.properties.getTypeProperties(args.modelID, args.elementID, args.recursive);
        this.worker.post(data);
    }
}

class MemoryCleaner {
    constructor(state) {
        this.state = state;
    }
    async dispose() {
        Object.keys(this.state.models).forEach(modelID => {
            const model = this.state.models[parseInt(modelID, 10)];
            model.mesh.removeFromParent();
            const geom = model.mesh.geometry;
            if (geom.disposeBoundsTree)
                geom.disposeBoundsTree();
            geom.dispose();
            if (!Array.isArray(model.mesh.material))
                model.mesh.material.dispose();
            else
                model.mesh.material.forEach(mat => mat.dispose());
            model.mesh = null;
            model.types = null;
            model.jsonData = null;
        });
        this.state.api = null;
        this.state.models = null;
    }
}

class StateWorker {
    constructor(worker) {
        this.worker = worker;
        this.API = WorkerAPIs.workerState;
    }
    updateStateUseJson(data) {
        if (!this.worker.state)
            throw new Error(ErrorRootStateNotAvailable);
        this.worker.state.useJSON = data.args.useJson;
        this.worker.post(data);
    }
    updateStateWebIfcSettings(data) {
        if (!this.worker.state)
            throw new Error(ErrorRootStateNotAvailable);
        this.worker.state.webIfcSettings = data.args.webIfcSettings;
        this.worker.post(data);
    }
    updateModelStateJsonData(data) {
        if (!this.worker.state)
            throw new Error(ErrorRootStateNotAvailable);
        const model = this.getModel(data);
        model.jsonData = data.args.jsonData;
        this.worker.post(data);
    }
    updateModelStateTypes(data) {
        if (!this.worker.state)
            throw new Error(ErrorRootStateNotAvailable);
        const model = this.getModel(data);
        model.types = data.args.types;
        this.worker.post(data);
    }
    async dispose(data) {
        if (!this.worker.state)
            throw new Error("Error: no state was found in the worker");
        if (!this.cleaner)
            this.cleaner = new MemoryCleaner(this.worker.state);
        await this.cleaner.dispose();
        this.worker.post(data);
    }
    async loadJsonDataFromWorker(data) {
        if (!this.worker.state)
            throw new Error(ErrorRootStateNotAvailable);
        const currentModel = this.getModel(data);
        const file = await fetch(data.args.path);
        if (!file.ok)
            throw new Error(ErrorBadJsonPath);
        const json = await file.json();
        if (typeof json !== 'object')
            throw new Error(ErrorBadJson);
        currentModel.jsonData = json;
        this.worker.post(data);
    }
    getModel(data) {
        if (!this.worker.state)
            throw new Error(ErrorRootStateNotAvailable);
        const modelID = data.args.modelID;
        if (!this.worker.state.models[modelID]) {
            this.worker.state.models[modelID] = { modelID, mesh: {}, types: {}, jsonData: {} };
        }
        return this.worker.state.models[modelID];
    }
}

/**
 * @param  {Array<BufferGeometry>} geometries
 * @param  {Boolean} useGroups
 * @return {BufferGeometry}
 */
function mergeBufferGeometries( geometries, useGroups = false ) {

	const isIndexed = geometries[ 0 ].index !== null;

	const attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );
	const morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );

	const attributes = {};
	const morphAttributes = {};

	const morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;

	const mergedGeometry = new BufferGeometry();

	let offset = 0;

	for ( let i = 0; i < geometries.length; ++ i ) {

		const geometry = geometries[ i ];
		let attributesCount = 0;

		// ensure that all geometries are indexed, or none

		if ( isIndexed !== ( geometry.index !== null ) ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );
			return null;

		}

		// gather attributes, exit early if they're different

		for ( const name in geometry.attributes ) {

			if ( ! attributesUsed.has( name ) ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.' );
				return null;

			}

			if ( attributes[ name ] === undefined ) attributes[ name ] = [];

			attributes[ name ].push( geometry.attributes[ name ] );

			attributesCount ++;

		}

		// ensure geometries have the same number of attributes

		if ( attributesCount !== attributesUsed.size ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );
			return null;

		}

		// gather morph attributes, exit early if they're different

		if ( morphTargetsRelative !== geometry.morphTargetsRelative ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );
			return null;

		}

		for ( const name in geometry.morphAttributes ) {

			if ( ! morphAttributesUsed.has( name ) ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );
				return null;

			}

			if ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];

			morphAttributes[ name ].push( geometry.morphAttributes[ name ] );

		}

		if ( useGroups ) {

			let count;

			if ( isIndexed ) {

				count = geometry.index.count;

			} else if ( geometry.attributes.position !== undefined ) {

				count = geometry.attributes.position.count;

			} else {

				console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );
				return null;

			}

			mergedGeometry.addGroup( offset, count, i );

			offset += count;

		}

	}

	// merge indices

	if ( isIndexed ) {

		let indexOffset = 0;
		const mergedIndex = [];

		for ( let i = 0; i < geometries.length; ++ i ) {

			const index = geometries[ i ].index;

			for ( let j = 0; j < index.count; ++ j ) {

				mergedIndex.push( index.getX( j ) + indexOffset );

			}

			indexOffset += geometries[ i ].attributes.position.count;

		}

		mergedGeometry.setIndex( mergedIndex );

	}

	// merge attributes

	for ( const name in attributes ) {

		const mergedAttribute = mergeBufferAttributes( attributes[ name ] );

		if ( ! mergedAttribute ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.' );
			return null;

		}

		mergedGeometry.setAttribute( name, mergedAttribute );

	}

	// merge morph attributes

	for ( const name in morphAttributes ) {

		const numMorphTargets = morphAttributes[ name ][ 0 ].length;

		if ( numMorphTargets === 0 ) break;

		mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
		mergedGeometry.morphAttributes[ name ] = [];

		for ( let i = 0; i < numMorphTargets; ++ i ) {

			const morphAttributesToMerge = [];

			for ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {

				morphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );

			}

			const mergedMorphAttribute = mergeBufferAttributes( morphAttributesToMerge );

			if ( ! mergedMorphAttribute ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );
				return null;

			}

			mergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );

		}

	}

	return mergedGeometry;

}

/**
 * @param {Array<BufferAttribute>} attributes
 * @return {BufferAttribute}
 */
function mergeBufferAttributes( attributes ) {

	let TypedArray;
	let itemSize;
	let normalized;
	let arrayLength = 0;

	for ( let i = 0; i < attributes.length; ++ i ) {

		const attribute = attributes[ i ];

		if ( attribute.isInterleavedBufferAttribute ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.' );
			return null;

		}

		if ( TypedArray === undefined ) TypedArray = attribute.array.constructor;
		if ( TypedArray !== attribute.array.constructor ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );
			return null;

		}

		if ( itemSize === undefined ) itemSize = attribute.itemSize;
		if ( itemSize !== attribute.itemSize ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );
			return null;

		}

		if ( normalized === undefined ) normalized = attribute.normalized;
		if ( normalized !== attribute.normalized ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );
			return null;

		}

		arrayLength += attribute.array.length;

	}

	const array = new TypedArray( arrayLength );
	let offset = 0;

	for ( let i = 0; i < attributes.length; ++ i ) {

		array.set( attributes[ i ].array, offset );

		offset += attributes[ i ].array.length;

	}

	return new BufferAttribute( array, itemSize, normalized );

}

class IFCParser {
    constructor(state, BVH) {
        this.state = state;
        this.BVH = BVH;
        this.loadedModels = 0;
        this.optionalCategories = {
            [IFCSPACE]: true,
            [IFCOPENINGELEMENT]: false
        };
        this.geometriesByMaterials = {};
        this.loadingState = {
            total: 0,
            current: 0,
            step: 0.1
        };
        this.currentWebIfcID = -1;
        this.currentModelID = -1;
    }
    async setupOptionalCategories(config) {
        this.optionalCategories = config;
    }
    async parse(buffer, coordinationMatrix) {
        if (this.state.api.wasmModule === undefined)
            await this.state.api.Init();
        await this.newIfcModel(buffer);
        this.loadedModels++;
        if (coordinationMatrix) {
            await this.state.api.SetGeometryTransformation(this.currentWebIfcID, coordinationMatrix);
        }
        return this.loadAllGeometry(this.currentWebIfcID);
    }
    getAndClearErrors(_modelId) {
    }
    notifyProgress(loaded, total) {
        if (this.state.onProgress)
            this.state.onProgress({ loaded, total });
    }
    async newIfcModel(buffer) {
        const data = new Uint8Array(buffer);
        this.currentWebIfcID = await this.state.api.OpenModel(data, this.state.webIfcSettings);
        this.currentModelID = this.state.useJSON ? this.loadedModels : this.currentWebIfcID;
        this.state.models[this.currentModelID] = {
            modelID: this.currentModelID,
            mesh: {},
            types: {},
            jsonData: {}
        };
    }
    async loadAllGeometry(modelID) {
        this.addOptionalCategories(modelID);
        await this.initializeLoadingState(modelID);
        this.state.api.StreamAllMeshes(modelID, (mesh) => {
            this.updateLoadingState();
            this.streamMesh(modelID, mesh);
        });
        this.notifyLoadingEnded();
        const geometries = [];
        const materials = [];
        Object.keys(this.geometriesByMaterials).forEach((key) => {
            const geometriesByMaterial = this.geometriesByMaterials[key].geometries;
            const merged = mergeBufferGeometries(geometriesByMaterial);
            materials.push(this.geometriesByMaterials[key].material);
            geometries.push(merged);
        });
        const combinedGeometry = mergeBufferGeometries(geometries, true);
        this.cleanUpGeometryMemory(geometries);
        if (this.BVH)
            this.BVH.applyThreeMeshBVH(combinedGeometry);
        const model = new IFCModel(combinedGeometry, materials);
        this.state.models[this.currentModelID].mesh = model;
        return model;
    }
    async initializeLoadingState(modelID) {
        const shapes = await this.state.api.GetLineIDsWithType(modelID, IFCPRODUCTDEFINITIONSHAPE);
        this.loadingState.total = shapes.size();
        this.loadingState.current = 0;
        this.loadingState.step = 0.1;
    }
    notifyLoadingEnded() {
        this.notifyProgress(this.loadingState.total, this.loadingState.total);
    }
    updateLoadingState() {
        const realCurrentItem = Math.min(this.loadingState.current++, this.loadingState.total);
        if (realCurrentItem / this.loadingState.total >= this.loadingState.step) {
            const currentProgress = Math.ceil(this.loadingState.total * this.loadingState.step);
            this.notifyProgress(currentProgress, this.loadingState.total);
            this.loadingState.step += 0.1;
        }
    }
    addOptionalCategories(modelID) {
        const optionalTypes = [];
        for (let key in this.optionalCategories) {
            if (this.optionalCategories.hasOwnProperty(key)) {
                const category = parseInt(key);
                if (this.optionalCategories[category])
                    optionalTypes.push(category);
            }
        }
        this.state.api.StreamAllMeshesWithTypes(this.currentWebIfcID, optionalTypes, (mesh) => {
            this.streamMesh(modelID, mesh);
        });
    }
    streamMesh(modelID, mesh) {
        const placedGeometries = mesh.geometries;
        const size = placedGeometries.size();
        for (let i = 0; i < size; i++) {
            const placedGeometry = placedGeometries.get(i);
            let itemMesh = this.getPlacedGeometry(modelID, mesh.expressID, placedGeometry);
            let geom = itemMesh.geometry.applyMatrix4(itemMesh.matrix);
            this.storeGeometryByMaterial(placedGeometry.color, geom);
        }
    }
    getPlacedGeometry(modelID, expressID, placedGeometry) {
        const geometry = this.getBufferGeometry(modelID, expressID, placedGeometry);
        const mesh = new Mesh(geometry);
        mesh.matrix = this.getMeshMatrix(placedGeometry.flatTransformation);
        mesh.matrixAutoUpdate = false;
        return mesh;
    }
    getBufferGeometry(modelID, expressID, placedGeometry) {
        const geometry = this.state.api.GetGeometry(modelID, placedGeometry.geometryExpressID);
        const verts = this.state.api.GetVertexArray(geometry.GetVertexData(), geometry.GetVertexDataSize());
        const indices = this.state.api.GetIndexArray(geometry.GetIndexData(), geometry.GetIndexDataSize());
        const buffer = this.ifcGeometryToBuffer(expressID, verts, indices);
        geometry.delete();
        return buffer;
    }
    storeGeometryByMaterial(color, geometry) {
        let colID = `${color.x}${color.y}${color.z}${color.w}`;
        if (this.geometriesByMaterials[colID]) {
            this.geometriesByMaterials[colID].geometries.push(geometry);
            return;
        }
        const col = new Color(color.x, color.y, color.z);
        const material = new MeshLambertMaterial({ color: col, side: DoubleSide });
        material.transparent = color.w !== 1;
        if (material.transparent)
            material.opacity = color.w;
        this.geometriesByMaterials[colID] = { material, geometries: [geometry] };
    }
    getMeshMatrix(matrix) {
        const mat = new Matrix4();
        mat.fromArray(matrix);
        return mat;
    }
    ifcGeometryToBuffer(expressID, vertexData, indexData) {
        const geometry = new BufferGeometry();
        const posFloats = new Float32Array(vertexData.length / 2);
        const normFloats = new Float32Array(vertexData.length / 2);
        const idAttribute = new Uint32Array(vertexData.length / 6);
        for (let i = 0; i < vertexData.length; i += 6) {
            posFloats[i / 2] = vertexData[i];
            posFloats[i / 2 + 1] = vertexData[i + 1];
            posFloats[i / 2 + 2] = vertexData[i + 2];
            normFloats[i / 2] = vertexData[i + 3];
            normFloats[i / 2 + 1] = vertexData[i + 4];
            normFloats[i / 2 + 2] = vertexData[i + 5];
            idAttribute[i / 6] = expressID;
        }
        geometry.setAttribute('position', new BufferAttribute(posFloats, 3));
        geometry.setAttribute('normal', new BufferAttribute(normFloats, 3));
        geometry.setAttribute('expressID', new BufferAttribute(idAttribute, 1));
        geometry.setIndex(new BufferAttribute(indexData, 1));
        return geometry;
    }
    cleanUpGeometryMemory(geometries) {
        geometries.forEach(geometry => geometry.dispose());
        Object.keys(this.geometriesByMaterials).forEach((materialID) => {
            const geometriesByMaterial = this.geometriesByMaterials[materialID];
            geometriesByMaterial.geometries.forEach(geometry => geometry.dispose());
            geometriesByMaterial.geometries = [];
            geometriesByMaterial.material = null;
        });
        this.geometriesByMaterials = {};
    }
}

var DBOperation;
(function (DBOperation) {
    DBOperation[DBOperation["transferIfcModel"] = 0] = "transferIfcModel";
    DBOperation[DBOperation["transferIndividualItems"] = 1] = "transferIndividualItems";
})(DBOperation || (DBOperation = {}));
class IndexedDatabase {
    async save(item, id) {
        const open = IndexedDatabase.openOrCreateDB(id);
        this.createSchema(open, id);
        return new Promise((resolve, reject) => {
            open.onsuccess = () => this.saveItem(item, open, id, resolve);
        });
    }
    async load(id) {
        const open = IndexedDatabase.openOrCreateDB(id);
        return new Promise((resolve, reject) => {
            open.onsuccess = () => this.loadItem(open, id, resolve);
        });
    }
    createSchema(open, id) {
        open.onupgradeneeded = function () {
            const db = open.result;
            db.createObjectStore(id.toString(), { keyPath: "id" });
        };
    }
    saveItem(item, open, id, resolve) {
        const { db, tx, store } = IndexedDatabase.getDBItems(open, id);
        item.id = id;
        store.put(item);
        tx.oncomplete = () => IndexedDatabase.closeDB(db, tx, resolve);
    }
    loadItem(open, id, resolve) {
        const { db, tx, store } = IndexedDatabase.getDBItems(open, id);
        const item = store.get(id);
        const callback = () => {
            delete item.result.id;
            resolve(item.result);
        };
        tx.oncomplete = () => IndexedDatabase.closeDB(db, tx, callback);
    }
    static getDBItems(open, id) {
        const db = open.result;
        const tx = db.transaction(id.toString(), "readwrite");
        const store = tx.objectStore(id.toString());
        return { db, tx, store };
    }
    static openOrCreateDB(id) {
        return indexedDB.open(id.toString(), 1);
    }
    static closeDB(db, tx, resolve) {
        db.close();
        resolve("success");
    }
}

class ParserWorker {
    constructor(worker, serializer, IDB) {
        this.worker = worker;
        this.serializer = serializer;
        this.IDB = IDB;
        this.API = WorkerAPIs.parser;
    }
    initializeParser() {
        if (!this.parser) {
            if (!this.worker.state)
                throw new Error(ErrorRootStateNotAvailable);
            this.parser = new IFCParser(this.worker.state);
        }
    }
    setupOptionalCategories(data) {
        this.initializeParser();
        if (this.parser === undefined)
            throw new Error(ErrorParserNotAvailable);
        this.parser.setupOptionalCategories(data.args.config);
        this.worker.post(data);
    }
    async parse(data) {
        this.initializeParser();
        if (this.parser === undefined)
            throw new Error(ErrorParserNotAvailable);
        if (this.worker.state)
            this.worker.state.onProgress = (event) => this.onProgress(event, data);
        const serializedIfcModel = await this.getResponse(data);
        await this.IDB.save(serializedIfcModel, DBOperation.transferIfcModel);
        this.worker.post(data);
    }
    onProgress(event, data) {
        this.worker.post({ ...data, onProgress: true, result: event });
    }
    async getResponse(data) {
        if (!this.parser)
            throw new Error(ErrorParserNotAvailable);
        const ifcModel = await this.parser.parse(data.args.buffer, data.args.coordinationMatrix);
        const serializedIfcModel = this.serializer.serializeIfcModel(ifcModel);
        this.cleanUpGeometries(ifcModel);
        data.result = { modelID: ifcModel.modelID };
        return serializedIfcModel;
    }
    cleanUpGeometries(model) {
        model.geometry.dispose();
        if (Array.isArray(model.material))
            model.material.forEach(mat => mat.dispose());
        else
            model.material.dispose();
    }
}

class IFCWorker {
    constructor() {
        this.serializer = new Serializer();
        this.IDB = new IndexedDatabase();
        this.workerState = new StateWorker(this);
        this.webIfc = new WebIfcWorker(this, this.serializer);
        this.properties = new PropertyWorker(this);
        this.parser = new ParserWorker(this, this.serializer, this.IDB);
    }
    initializeAPI(api) {
        this.state = {
            models: [],
            api,
            useJSON: false,
            worker: { active: false, path: '' }
        };
    }
    post(data) {
        self.postMessage(data);
    }
    postCallback(data, result, serializer) {
        data.result = serializer ? serializer(result) : result;
        this.post(data);
    }
}
const ifcWorker = new IFCWorker();
self.onmessage = async (event) => {
    const data = event.data;
    const { worker, action } = data;
    checkRequestIsValid(worker, action);
    const requestedWorker = ifcWorker[worker];
    requestedWorker[action](data);
};
function checkRequestIsValid(worker, action) {
    if (!ifcWorker[worker]) {
        throw new Error(`The worker ${worker} does not exist.`);
    }
    const requestedWorker = ifcWorker[worker];
    if (!requestedWorker[action]) {
        throw new Error(`The action ${action} does not exist in the worker ${worker}.`);
    }
}
//# sourceMappingURL=IFCWorker.js.map
